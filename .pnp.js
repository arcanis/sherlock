#!/usr/bin/env node

try {
  Object.freeze({}).detectStrictMode = true;
} catch (error) {
  throw new Error(`The whole PnP file got strict-mode-ified, which is known to break (Emscripten libraries aren't strict mode). This usually happens when the file goes through Babel.`);
}

var __non_webpack_module__ = module;

function $$SETUP_STATE(hydrateRuntimeState, basePath) {
  return hydrateRuntimeState({
    "__info": [
      "This file is automatically generated. Do not touch it, or risk",
      "your modifications being lost. We also recommend you not to read",
      "it either without using the @yarnpkg/pnp package, as the data layout",
      "is entirely unspecified and WILL change from a version to another."
    ],
    "dependencyTreeRoots": [
      {
        "name": "@arcanis/sherlock",
        "reference": "workspace:."
      }
    ],
    "enableTopLevelFallback": true,
    "ignorePatternData": null,
    "virtualRoots": [
      "./.yarn/virtual/"
    ],
    "fallbackExclusionList": [
      ["@arcanis/sherlock", ["workspace:."]]
    ],
    "locationBlacklistData": [
    ],
    "locationLengthData": [
      212,
      206,
      203,
      188,
      185,
      179,
      158,
      144,
      132,
      131,
      125,
      120,
      118,
      114,
      112,
      110,
      108,
      106,
      104,
      102,
      100,
      96,
      95,
      94,
      93,
      92,
      91,
      90,
      89,
      88,
      87,
      86,
      85,
      84,
      83,
      82,
      80,
      79,
      78,
      77,
      76,
      75,
      74,
      73,
      72,
      71,
      70,
      69,
      68,
      66,
      65,
      64,
      63,
      62,
      60,
      2
    ],
    "packageRegistryData": [
      [null, [
        [null, {
          "packageLocation": "./",
          "packageDependencies": [
            ["@actions/core", "npm:1.2.6"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/plugin-proposal-class-properties", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@babel/plugin-proposal-decorators", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.4.4"],
            ["@babel/plugin-transform-modules-commonjs", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.0"],
            ["@babel/preset-typescript", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.3.3"],
            ["@babel/register", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@berry/pnpify", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:0.1.0"],
            ["@octokit/rest", "npm:16.28.7"],
            ["@types/git-url-parse", "npm:9.0.0"],
            ["@types/node", "npm:12.7.1"],
            ["@types/tmp", "npm:0.1.0"],
            ["@types/unist", "npm:2.0.3"],
            ["@types/yup", "npm:0.26.22"],
            ["clipanion", "npm:2.0.0-rc.16"],
            ["expect", "npm:24.8.0"],
            ["git-url-parse", "npm:11.1.2"],
            ["parse-github-url", "npm:1.0.2"],
            ["pkg-up", "npm:3.1.0"],
            ["remark", "npm:11.0.1"],
            ["tmp", "npm:0.1.0"],
            ["typescript", "npm:3.5.3"],
            ["unified", "npm:8.3.2"],
            ["unist-util-visit", "npm:2.0.0"],
            ["yup", "npm:0.27.0"]
          ],
          "linkType": "SOFT"
        }]
      ]],
      ["@actions/core", [
        ["npm:1.2.6", {
          "packageLocation": "./.yarn/cache/@actions-core-npm-1.2.6-f205abe96a-1.zip/node_modules/@actions/core/",
          "packageDependencies": [
            ["@actions/core", "npm:1.2.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@arcanis/sherlock", [
        ["workspace:.", {
          "packageLocation": "./",
          "packageDependencies": [
            ["@arcanis/sherlock", "workspace:."],
            ["@actions/core", "npm:1.2.6"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/plugin-proposal-class-properties", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@babel/plugin-proposal-decorators", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.4.4"],
            ["@babel/plugin-transform-modules-commonjs", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.0"],
            ["@babel/preset-typescript", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.3.3"],
            ["@babel/register", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@berry/pnpify", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:0.1.0"],
            ["@octokit/rest", "npm:16.28.7"],
            ["@types/git-url-parse", "npm:9.0.0"],
            ["@types/node", "npm:12.7.1"],
            ["@types/tmp", "npm:0.1.0"],
            ["@types/unist", "npm:2.0.3"],
            ["@types/yup", "npm:0.26.22"],
            ["clipanion", "npm:2.0.0-rc.16"],
            ["expect", "npm:24.8.0"],
            ["git-url-parse", "npm:11.1.2"],
            ["parse-github-url", "npm:1.0.2"],
            ["pkg-up", "npm:3.1.0"],
            ["remark", "npm:11.0.1"],
            ["tmp", "npm:0.1.0"],
            ["typescript", "npm:3.5.3"],
            ["unified", "npm:8.3.2"],
            ["unist-util-visit", "npm:2.0.0"],
            ["yup", "npm:0.27.0"]
          ],
          "linkType": "SOFT"
        }]
      ]],
      ["@babel/code-frame", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-code-frame-npm-7.5.5-7f826ed8c4-1.zip/node_modules/@babel/code-frame/",
          "packageDependencies": [
            ["@babel/code-frame", "npm:7.5.5"],
            ["@babel/highlight", "npm:7.5.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/core", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-core-npm-7.5.5-9c5fb64f1f-1.zip/node_modules/@babel/core/",
          "packageDependencies": [
            ["@babel/core", "npm:7.5.5"],
            ["@babel/code-frame", "npm:7.5.5"],
            ["@babel/generator", "npm:7.5.5"],
            ["@babel/helpers", "npm:7.5.5"],
            ["@babel/parser", "npm:7.5.5"],
            ["@babel/template", "npm:7.4.4"],
            ["@babel/traverse", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"],
            ["convert-source-map", "npm:1.6.0"],
            ["debug", "npm:4.1.1"],
            ["json5", "npm:2.1.0"],
            ["lodash", "npm:4.17.15"],
            ["resolve", "npm:1.12.0"],
            ["semver", "npm:5.7.0"],
            ["source-map", "npm:0.5.7"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/generator", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-generator-npm-7.5.5-fa41cb8ddd-1.zip/node_modules/@babel/generator/",
          "packageDependencies": [
            ["@babel/generator", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"],
            ["jsesc", "npm:2.5.2"],
            ["lodash", "npm:4.17.15"],
            ["source-map", "npm:0.5.7"],
            ["trim-right", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-create-class-features-plugin", [
        ["virtual:1ba8ab4ebb0cd14845990eb499fd740cfb9b65c9968dd458e2926e2492862fd02e6553d484aae881b14c6578162327958ca83f5b1604612558f8902968fba666#npm:7.5.5", {
          "packageLocation": "./.yarn/virtual/@babel-helper-create-class-features-plugin-virtual-9ac7a10d88/0/cache/@babel-helper-create-class-features-plugin-npm-7.5.5-e119848340-1.zip/node_modules/@babel/helper-create-class-features-plugin/",
          "packageDependencies": [
            ["@babel/helper-create-class-features-plugin", "virtual:1ba8ab4ebb0cd14845990eb499fd740cfb9b65c9968dd458e2926e2492862fd02e6553d484aae881b14c6578162327958ca83f5b1604612558f8902968fba666#npm:7.5.5"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-function-name", "npm:7.1.0"],
            ["@babel/helper-member-expression-to-functions", "npm:7.5.5"],
            ["@babel/helper-optimise-call-expression", "npm:7.0.0"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"],
            ["@babel/helper-replace-supers", "npm:7.5.5"],
            ["@babel/helper-split-export-declaration", "npm:7.4.4"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-function-name", [
        ["npm:7.1.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-function-name-npm-7.1.0-c9aa64484e-1.zip/node_modules/@babel/helper-function-name/",
          "packageDependencies": [
            ["@babel/helper-function-name", "npm:7.1.0"],
            ["@babel/helper-get-function-arity", "npm:7.0.0"],
            ["@babel/template", "npm:7.4.4"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-get-function-arity", [
        ["npm:7.0.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-get-function-arity-npm-7.0.0-aa498a0e01-1.zip/node_modules/@babel/helper-get-function-arity/",
          "packageDependencies": [
            ["@babel/helper-get-function-arity", "npm:7.0.0"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-member-expression-to-functions", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-helper-member-expression-to-functions-npm-7.5.5-3e877bfcf3-1.zip/node_modules/@babel/helper-member-expression-to-functions/",
          "packageDependencies": [
            ["@babel/helper-member-expression-to-functions", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-module-imports", [
        ["npm:7.0.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-module-imports-npm-7.0.0-3ffc47bdf3-1.zip/node_modules/@babel/helper-module-imports/",
          "packageDependencies": [
            ["@babel/helper-module-imports", "npm:7.0.0"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-module-transforms", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-helper-module-transforms-npm-7.5.5-cd153e23a8-1.zip/node_modules/@babel/helper-module-transforms/",
          "packageDependencies": [
            ["@babel/helper-module-transforms", "npm:7.5.5"],
            ["@babel/helper-module-imports", "npm:7.0.0"],
            ["@babel/helper-simple-access", "npm:7.1.0"],
            ["@babel/helper-split-export-declaration", "npm:7.4.4"],
            ["@babel/template", "npm:7.4.4"],
            ["@babel/types", "npm:7.5.5"],
            ["lodash", "npm:4.17.15"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-optimise-call-expression", [
        ["npm:7.0.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-optimise-call-expression-npm-7.0.0-5c912de01f-1.zip/node_modules/@babel/helper-optimise-call-expression/",
          "packageDependencies": [
            ["@babel/helper-optimise-call-expression", "npm:7.0.0"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-plugin-utils", [
        ["npm:7.0.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-plugin-utils-npm-7.0.0-cc9c4f7195-1.zip/node_modules/@babel/helper-plugin-utils/",
          "packageDependencies": [
            ["@babel/helper-plugin-utils", "npm:7.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-replace-supers", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-helper-replace-supers-npm-7.5.5-dcba9a4333-1.zip/node_modules/@babel/helper-replace-supers/",
          "packageDependencies": [
            ["@babel/helper-replace-supers", "npm:7.5.5"],
            ["@babel/helper-member-expression-to-functions", "npm:7.5.5"],
            ["@babel/helper-optimise-call-expression", "npm:7.0.0"],
            ["@babel/traverse", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-simple-access", [
        ["npm:7.1.0", {
          "packageLocation": "./.yarn/cache/@babel-helper-simple-access-npm-7.1.0-6b596bb36e-1.zip/node_modules/@babel/helper-simple-access/",
          "packageDependencies": [
            ["@babel/helper-simple-access", "npm:7.1.0"],
            ["@babel/template", "npm:7.4.4"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helper-split-export-declaration", [
        ["npm:7.4.4", {
          "packageLocation": "./.yarn/cache/@babel-helper-split-export-declaration-npm-7.4.4-374381fd89-1.zip/node_modules/@babel/helper-split-export-declaration/",
          "packageDependencies": [
            ["@babel/helper-split-export-declaration", "npm:7.4.4"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/helpers", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-helpers-npm-7.5.5-2acf0131a5-1.zip/node_modules/@babel/helpers/",
          "packageDependencies": [
            ["@babel/helpers", "npm:7.5.5"],
            ["@babel/template", "npm:7.4.4"],
            ["@babel/traverse", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/highlight", [
        ["npm:7.5.0", {
          "packageLocation": "./.yarn/cache/@babel-highlight-npm-7.5.0-35ab429250-1.zip/node_modules/@babel/highlight/",
          "packageDependencies": [
            ["@babel/highlight", "npm:7.5.0"],
            ["chalk", "npm:2.4.2"],
            ["esutils", "npm:2.0.3"],
            ["js-tokens", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/parser", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-parser-npm-7.5.5-90149d22bf-1.zip/node_modules/@babel/parser/",
          "packageDependencies": [
            ["@babel/parser", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-proposal-class-properties", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-proposal-class-properties-virtual-1ba8ab4ebb/0/cache/@babel-plugin-proposal-class-properties-npm-7.5.5-eee78cdcd2-1.zip/node_modules/@babel/plugin-proposal-class-properties/",
          "packageDependencies": [
            ["@babel/plugin-proposal-class-properties", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-create-class-features-plugin", "virtual:1ba8ab4ebb0cd14845990eb499fd740cfb9b65c9968dd458e2926e2492862fd02e6553d484aae881b14c6578162327958ca83f5b1604612558f8902968fba666#npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-proposal-decorators", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.4.4", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-proposal-decorators-virtual-097a984344/0/cache/@babel-plugin-proposal-decorators-npm-7.4.4-419da4df41-1.zip/node_modules/@babel/plugin-proposal-decorators/",
          "packageDependencies": [
            ["@babel/plugin-proposal-decorators", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.4.4"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-create-class-features-plugin", "virtual:1ba8ab4ebb0cd14845990eb499fd740cfb9b65c9968dd458e2926e2492862fd02e6553d484aae881b14c6578162327958ca83f5b1604612558f8902968fba666#npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"],
            ["@babel/plugin-syntax-decorators", "virtual:097a984344a1bccb927e5d846d3ea950caf14c30002a1d26d79a2a70469e9fc009e40ab841094c589356e6d5b82a6465e7f24271ce1ef38d4a12385d88a88a5a#npm:7.2.0"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-syntax-decorators", [
        ["virtual:097a984344a1bccb927e5d846d3ea950caf14c30002a1d26d79a2a70469e9fc009e40ab841094c589356e6d5b82a6465e7f24271ce1ef38d4a12385d88a88a5a#npm:7.2.0", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-syntax-decorators-virtual-9169a2cf33/0/cache/@babel-plugin-syntax-decorators-npm-7.2.0-5c8225a910-1.zip/node_modules/@babel/plugin-syntax-decorators/",
          "packageDependencies": [
            ["@babel/plugin-syntax-decorators", "virtual:097a984344a1bccb927e5d846d3ea950caf14c30002a1d26d79a2a70469e9fc009e40ab841094c589356e6d5b82a6465e7f24271ce1ef38d4a12385d88a88a5a#npm:7.2.0"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-syntax-typescript", [
        ["virtual:6a344db4b4baebcb443ff85514cf29c4957fd83ea0606aae3f7c32ab1aaa2a2107fdfb4731e2f990b35575294de2f6ffa0e6b9948c8d115603d52a2d5991a1e6#npm:7.3.3", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-syntax-typescript-virtual-8cca509ca3/0/cache/@babel-plugin-syntax-typescript-npm-7.3.3-0a6c251968-1.zip/node_modules/@babel/plugin-syntax-typescript/",
          "packageDependencies": [
            ["@babel/plugin-syntax-typescript", "virtual:6a344db4b4baebcb443ff85514cf29c4957fd83ea0606aae3f7c32ab1aaa2a2107fdfb4731e2f990b35575294de2f6ffa0e6b9948c8d115603d52a2d5991a1e6#npm:7.3.3"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-transform-modules-commonjs", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.0", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-transform-modules-commonjs-virtual-c5edf1d0bb/0/cache/@babel-plugin-transform-modules-commonjs-npm-7.5.0-235c2876be-1.zip/node_modules/@babel/plugin-transform-modules-commonjs/",
          "packageDependencies": [
            ["@babel/plugin-transform-modules-commonjs", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.0"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-module-transforms", "npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"],
            ["@babel/helper-simple-access", "npm:7.1.0"],
            ["babel-plugin-dynamic-import-node", "npm:2.3.0"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/plugin-transform-typescript", [
        ["virtual:c63a1c23c50d18fd9bcb38f0db883c01fde1c329f99eeeb7ba178ac401ad10d753ffe654062f589a20ac2775d5db2dcafd8d1b8ba434ec9c231e8dc1451de4fe#npm:7.5.5", {
          "packageLocation": "./.yarn/virtual/@babel-plugin-transform-typescript-virtual-6a344db4b4/0/cache/@babel-plugin-transform-typescript-npm-7.5.5-29f3c62140-1.zip/node_modules/@babel/plugin-transform-typescript/",
          "packageDependencies": [
            ["@babel/plugin-transform-typescript", "virtual:c63a1c23c50d18fd9bcb38f0db883c01fde1c329f99eeeb7ba178ac401ad10d753ffe654062f589a20ac2775d5db2dcafd8d1b8ba434ec9c231e8dc1451de4fe#npm:7.5.5"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-create-class-features-plugin", "virtual:1ba8ab4ebb0cd14845990eb499fd740cfb9b65c9968dd458e2926e2492862fd02e6553d484aae881b14c6578162327958ca83f5b1604612558f8902968fba666#npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"],
            ["@babel/plugin-syntax-typescript", "virtual:6a344db4b4baebcb443ff85514cf29c4957fd83ea0606aae3f7c32ab1aaa2a2107fdfb4731e2f990b35575294de2f6ffa0e6b9948c8d115603d52a2d5991a1e6#npm:7.3.3"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/preset-typescript", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.3.3", {
          "packageLocation": "./.yarn/virtual/@babel-preset-typescript-virtual-c63a1c23c5/0/cache/@babel-preset-typescript-npm-7.3.3-d8863afd80-1.zip/node_modules/@babel/preset-typescript/",
          "packageDependencies": [
            ["@babel/preset-typescript", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.3.3"],
            ["@babel/core", "npm:7.5.5"],
            ["@babel/helper-plugin-utils", "npm:7.0.0"],
            ["@babel/plugin-transform-typescript", "virtual:c63a1c23c50d18fd9bcb38f0db883c01fde1c329f99eeeb7ba178ac401ad10d753ffe654062f589a20ac2775d5db2dcafd8d1b8ba434ec9c231e8dc1451de4fe#npm:7.5.5"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/register", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5", {
          "packageLocation": "./.yarn/virtual/@babel-register-virtual-b526269d99/0/cache/@babel-register-npm-7.5.5-d5093c8df9-1.zip/node_modules/@babel/register/",
          "packageDependencies": [
            ["@babel/register", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:7.5.5"],
            ["@babel/core", "npm:7.5.5"],
            ["core-js", "npm:3.1.4"],
            ["find-cache-dir", "npm:2.1.0"],
            ["lodash", "npm:4.17.15"],
            ["mkdirp", "npm:0.5.1"],
            ["pirates", "npm:4.0.1"],
            ["source-map-support", "npm:0.5.13"]
          ],
          "packagePeers": [
            "core"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/runtime", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-runtime-npm-7.5.5-c59deac7a0-1.zip/node_modules/@babel/runtime/",
          "packageDependencies": [
            ["@babel/runtime", "npm:7.5.5"],
            ["regenerator-runtime", "npm:0.13.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/template", [
        ["npm:7.4.4", {
          "packageLocation": "./.yarn/cache/@babel-template-npm-7.4.4-70497d8e10-1.zip/node_modules/@babel/template/",
          "packageDependencies": [
            ["@babel/template", "npm:7.4.4"],
            ["@babel/code-frame", "npm:7.5.5"],
            ["@babel/parser", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/traverse", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-traverse-npm-7.5.5-fd58a38d1c-1.zip/node_modules/@babel/traverse/",
          "packageDependencies": [
            ["@babel/traverse", "npm:7.5.5"],
            ["@babel/code-frame", "npm:7.5.5"],
            ["@babel/generator", "npm:7.5.5"],
            ["@babel/helper-function-name", "npm:7.1.0"],
            ["@babel/helper-split-export-declaration", "npm:7.4.4"],
            ["@babel/parser", "npm:7.5.5"],
            ["@babel/types", "npm:7.5.5"],
            ["debug", "npm:4.1.1"],
            ["globals", "npm:11.12.0"],
            ["lodash", "npm:4.17.15"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@babel/types", [
        ["npm:7.5.5", {
          "packageLocation": "./.yarn/cache/@babel-types-npm-7.5.5-cea2e7d807-1.zip/node_modules/@babel/types/",
          "packageDependencies": [
            ["@babel/types", "npm:7.5.5"],
            ["esutils", "npm:2.0.3"],
            ["lodash", "npm:4.17.15"],
            ["to-fast-properties", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@berry/fslib", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/@berry-fslib-npm-0.1.0-2b6f080f0e-1.zip/node_modules/@berry/fslib/",
          "packageDependencies": [
            ["@berry/fslib", "npm:0.1.0"],
            ["@berry/libzip", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@berry/libzip", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/@berry-libzip-npm-0.1.0-13d8600909-1.zip/node_modules/@berry/libzip/",
          "packageDependencies": [
            ["@berry/libzip", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@berry/pnpify", [
        ["virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:0.1.0", {
          "packageLocation": "./.yarn/virtual/@berry-pnpify-virtual-f0fe483269/0/cache/@berry-pnpify-npm-0.1.0-25241ad27d-1.zip/node_modules/@berry/pnpify/",
          "packageDependencies": [
            ["@berry/pnpify", "virtual:bf34fa33bb5c250fc08064c206bce181cd1de98094464fdddee97412ec68ad5324b687b9c29832748a1141ab5fa6fda3647703daf9ecb77e4f6bb347d9a5084e#npm:0.1.0"],
            ["@berry/fslib", "npm:0.1.0"],
            ["cross-spawn", "npm:6.0.5"],
            ["eslint", null],
            ["typescript", "npm:3.5.3"]
          ],
          "packagePeers": [
            "eslint",
            "typescript"
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@jest/console", [
        ["npm:24.7.1", {
          "packageLocation": "./.yarn/cache/@jest-console-npm-24.7.1-6d394014c4-1.zip/node_modules/@jest/console/",
          "packageDependencies": [
            ["@jest/console", "npm:24.7.1"],
            ["@jest/source-map", "npm:24.3.0"],
            ["chalk", "npm:2.4.2"],
            ["slash", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@jest/source-map", [
        ["npm:24.3.0", {
          "packageLocation": "./.yarn/cache/@jest-source-map-npm-24.3.0-456dc0bd03-1.zip/node_modules/@jest/source-map/",
          "packageDependencies": [
            ["@jest/source-map", "npm:24.3.0"],
            ["callsites", "npm:3.1.0"],
            ["graceful-fs", "npm:4.2.1"],
            ["source-map", "npm:0.6.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@jest/test-result", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/@jest-test-result-npm-24.8.0-27860bcf09-1.zip/node_modules/@jest/test-result/",
          "packageDependencies": [
            ["@jest/test-result", "npm:24.8.0"],
            ["@jest/console", "npm:24.7.1"],
            ["@jest/types", "npm:24.8.0"],
            ["@types/istanbul-lib-coverage", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@jest/types", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/@jest-types-npm-24.8.0-6dad018067-1.zip/node_modules/@jest/types/",
          "packageDependencies": [
            ["@jest/types", "npm:24.8.0"],
            ["@types/istanbul-lib-coverage", "npm:2.0.1"],
            ["@types/istanbul-reports", "npm:1.1.1"],
            ["@types/yargs", "npm:12.0.12"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@octokit/endpoint", [
        ["npm:5.3.2", {
          "packageLocation": "./.yarn/cache/@octokit-endpoint-npm-5.3.2-d49ac4ff2c-1.zip/node_modules/@octokit/endpoint/",
          "packageDependencies": [
            ["@octokit/endpoint", "npm:5.3.2"],
            ["deepmerge", "npm:4.0.0"],
            ["is-plain-object", "npm:3.0.0"],
            ["universal-user-agent", "npm:3.0.0"],
            ["url-template", "npm:2.0.8"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@octokit/request", [
        ["npm:5.0.2", {
          "packageLocation": "./.yarn/cache/@octokit-request-npm-5.0.2-e1135e3942-1.zip/node_modules/@octokit/request/",
          "packageDependencies": [
            ["@octokit/request", "npm:5.0.2"],
            ["@octokit/endpoint", "npm:5.3.2"],
            ["@octokit/request-error", "npm:1.0.4"],
            ["deprecation", "npm:2.3.1"],
            ["is-plain-object", "npm:3.0.0"],
            ["node-fetch", "npm:2.6.0"],
            ["once", "npm:1.4.0"],
            ["universal-user-agent", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@octokit/request-error", [
        ["npm:1.0.4", {
          "packageLocation": "./.yarn/cache/@octokit-request-error-npm-1.0.4-0dc83cd265-1.zip/node_modules/@octokit/request-error/",
          "packageDependencies": [
            ["@octokit/request-error", "npm:1.0.4"],
            ["deprecation", "npm:2.3.1"],
            ["once", "npm:1.4.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@octokit/rest", [
        ["npm:16.28.7", {
          "packageLocation": "./.yarn/cache/@octokit-rest-npm-16.28.7-84a4ad8c76-1.zip/node_modules/@octokit/rest/",
          "packageDependencies": [
            ["@octokit/rest", "npm:16.28.7"],
            ["@octokit/request", "npm:5.0.2"],
            ["@octokit/request-error", "npm:1.0.4"],
            ["atob-lite", "npm:2.0.0"],
            ["before-after-hook", "npm:2.1.0"],
            ["btoa-lite", "npm:1.0.0"],
            ["deprecation", "npm:2.3.1"],
            ["lodash.get", "npm:4.4.2"],
            ["lodash.set", "npm:4.3.2"],
            ["lodash.uniq", "npm:4.5.0"],
            ["octokit-pagination-methods", "npm:1.1.0"],
            ["once", "npm:1.4.0"],
            ["universal-user-agent", "npm:3.0.0"],
            ["url-template", "npm:2.0.8"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/git-url-parse", [
        ["npm:9.0.0", {
          "packageLocation": "./.yarn/cache/@types-git-url-parse-npm-9.0.0-2704df37e9-1.zip/node_modules/@types/git-url-parse/",
          "packageDependencies": [
            ["@types/git-url-parse", "npm:9.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/istanbul-lib-coverage", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/@types-istanbul-lib-coverage-npm-2.0.1-c8b87e4b03-1.zip/node_modules/@types/istanbul-lib-coverage/",
          "packageDependencies": [
            ["@types/istanbul-lib-coverage", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/istanbul-lib-report", [
        ["npm:1.1.1", {
          "packageLocation": "./.yarn/cache/@types-istanbul-lib-report-npm-1.1.1-be4b2ca215-1.zip/node_modules/@types/istanbul-lib-report/",
          "packageDependencies": [
            ["@types/istanbul-lib-report", "npm:1.1.1"],
            ["@types/istanbul-lib-coverage", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/istanbul-reports", [
        ["npm:1.1.1", {
          "packageLocation": "./.yarn/cache/@types-istanbul-reports-npm-1.1.1-380bb9d636-1.zip/node_modules/@types/istanbul-reports/",
          "packageDependencies": [
            ["@types/istanbul-reports", "npm:1.1.1"],
            ["@types/istanbul-lib-coverage", "npm:2.0.1"],
            ["@types/istanbul-lib-report", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/node", [
        ["npm:12.7.1", {
          "packageLocation": "./.yarn/cache/@types-node-npm-12.7.1-8b1f00c587-1.zip/node_modules/@types/node/",
          "packageDependencies": [
            ["@types/node", "npm:12.7.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/stack-utils", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/@types-stack-utils-npm-1.0.1-e2f2f7a882-1.zip/node_modules/@types/stack-utils/",
          "packageDependencies": [
            ["@types/stack-utils", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/tmp", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/@types-tmp-npm-0.1.0-2b1dac0b33-1.zip/node_modules/@types/tmp/",
          "packageDependencies": [
            ["@types/tmp", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/unist", [
        ["npm:2.0.3", {
          "packageLocation": "./.yarn/cache/@types-unist-npm-2.0.3-4b26dedfde-1.zip/node_modules/@types/unist/",
          "packageDependencies": [
            ["@types/unist", "npm:2.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/yargs", [
        ["npm:12.0.12", {
          "packageLocation": "./.yarn/cache/@types-yargs-npm-12.0.12-de983c291f-1.zip/node_modules/@types/yargs/",
          "packageDependencies": [
            ["@types/yargs", "npm:12.0.12"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["@types/yup", [
        ["npm:0.26.22", {
          "packageLocation": "./.yarn/cache/@types-yup-npm-0.26.22-2eadb6ed1e-1.zip/node_modules/@types/yup/",
          "packageDependencies": [
            ["@types/yup", "npm:0.26.22"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["ansi-regex", [
        ["npm:4.1.0", {
          "packageLocation": "./.yarn/cache/ansi-regex-npm-4.1.0-4a7d8413fe-1.zip/node_modules/ansi-regex/",
          "packageDependencies": [
            ["ansi-regex", "npm:4.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["ansi-styles", [
        ["npm:3.2.1", {
          "packageLocation": "./.yarn/cache/ansi-styles-npm-3.2.1-8cb8107983-1.zip/node_modules/ansi-styles/",
          "packageDependencies": [
            ["ansi-styles", "npm:3.2.1"],
            ["color-convert", "npm:1.9.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["arr-diff", [
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/arr-diff-npm-4.0.0-cec86ae312-1.zip/node_modules/arr-diff/",
          "packageDependencies": [
            ["arr-diff", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["arr-flatten", [
        ["npm:1.1.0", {
          "packageLocation": "./.yarn/cache/arr-flatten-npm-1.1.0-0c12b693e4-1.zip/node_modules/arr-flatten/",
          "packageDependencies": [
            ["arr-flatten", "npm:1.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["arr-union", [
        ["npm:3.1.0", {
          "packageLocation": "./.yarn/cache/arr-union-npm-3.1.0-853ada9729-1.zip/node_modules/arr-union/",
          "packageDependencies": [
            ["arr-union", "npm:3.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["array-unique", [
        ["npm:0.3.2", {
          "packageLocation": "./.yarn/cache/array-unique-npm-0.3.2-9f62c6ac93-1.zip/node_modules/array-unique/",
          "packageDependencies": [
            ["array-unique", "npm:0.3.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["assign-symbols", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/assign-symbols-npm-1.0.0-fd803ccdf1-1.zip/node_modules/assign-symbols/",
          "packageDependencies": [
            ["assign-symbols", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["atob", [
        ["npm:2.1.2", {
          "packageLocation": "./.yarn/cache/atob-npm-2.1.2-bcb583261e-1.zip/node_modules/atob/",
          "packageDependencies": [
            ["atob", "npm:2.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["atob-lite", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/atob-lite-npm-2.0.0-62802899eb-1.zip/node_modules/atob-lite/",
          "packageDependencies": [
            ["atob-lite", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["babel-plugin-dynamic-import-node", [
        ["npm:2.3.0", {
          "packageLocation": "./.yarn/cache/babel-plugin-dynamic-import-node-npm-2.3.0-b3a9e1a67e-1.zip/node_modules/babel-plugin-dynamic-import-node/",
          "packageDependencies": [
            ["babel-plugin-dynamic-import-node", "npm:2.3.0"],
            ["object.assign", "npm:4.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["bail", [
        ["npm:1.0.4", {
          "packageLocation": "./.yarn/cache/bail-npm-1.0.4-2beb43f28d-1.zip/node_modules/bail/",
          "packageDependencies": [
            ["bail", "npm:1.0.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["balanced-match", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/balanced-match-npm-1.0.0-951a2ad706-1.zip/node_modules/balanced-match/",
          "packageDependencies": [
            ["balanced-match", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["base", [
        ["npm:0.11.2", {
          "packageLocation": "./.yarn/cache/base-npm-0.11.2-a9bde462d6-1.zip/node_modules/base/",
          "packageDependencies": [
            ["base", "npm:0.11.2"],
            ["cache-base", "npm:1.0.1"],
            ["class-utils", "npm:0.3.6"],
            ["component-emitter", "npm:1.3.0"],
            ["define-property", "npm:1.0.0"],
            ["isobject", "npm:3.0.1"],
            ["mixin-deep", "npm:1.3.2"],
            ["pascalcase", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["before-after-hook", [
        ["npm:2.1.0", {
          "packageLocation": "./.yarn/cache/before-after-hook-npm-2.1.0-68b62dea36-1.zip/node_modules/before-after-hook/",
          "packageDependencies": [
            ["before-after-hook", "npm:2.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["brace-expansion", [
        ["npm:1.1.11", {
          "packageLocation": "./.yarn/cache/brace-expansion-npm-1.1.11-fb95eb05ad-1.zip/node_modules/brace-expansion/",
          "packageDependencies": [
            ["brace-expansion", "npm:1.1.11"],
            ["balanced-match", "npm:1.0.0"],
            ["concat-map", "npm:0.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["braces", [
        ["npm:2.3.2", {
          "packageLocation": "./.yarn/cache/braces-npm-2.3.2-19cadb3384-1.zip/node_modules/braces/",
          "packageDependencies": [
            ["braces", "npm:2.3.2"],
            ["arr-flatten", "npm:1.1.0"],
            ["array-unique", "npm:0.3.2"],
            ["extend-shallow", "npm:2.0.1"],
            ["fill-range", "npm:4.0.0"],
            ["isobject", "npm:3.0.1"],
            ["repeat-element", "npm:1.1.3"],
            ["snapdragon", "npm:0.8.2"],
            ["snapdragon-node", "npm:2.1.1"],
            ["split-string", "npm:3.1.0"],
            ["to-regex", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["btoa-lite", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/btoa-lite-npm-1.0.0-e85ee9286e-1.zip/node_modules/btoa-lite/",
          "packageDependencies": [
            ["btoa-lite", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["buffer-from", [
        ["npm:1.1.1", {
          "packageLocation": "./.yarn/cache/buffer-from-npm-1.1.1-22917b8ed8-1.zip/node_modules/buffer-from/",
          "packageDependencies": [
            ["buffer-from", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["cache-base", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/cache-base-npm-1.0.1-1538417cb9-1.zip/node_modules/cache-base/",
          "packageDependencies": [
            ["cache-base", "npm:1.0.1"],
            ["collection-visit", "npm:1.0.0"],
            ["component-emitter", "npm:1.3.0"],
            ["get-value", "npm:2.0.6"],
            ["has-value", "npm:1.0.0"],
            ["isobject", "npm:3.0.1"],
            ["set-value", "npm:2.0.1"],
            ["to-object-path", "npm:0.3.0"],
            ["union-value", "npm:1.0.1"],
            ["unset-value", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["callsites", [
        ["npm:3.1.0", {
          "packageLocation": "./.yarn/cache/callsites-npm-3.1.0-268f989910-1.zip/node_modules/callsites/",
          "packageDependencies": [
            ["callsites", "npm:3.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["ccount", [
        ["npm:1.0.4", {
          "packageLocation": "./.yarn/cache/ccount-npm-1.0.4-d5765a2389-1.zip/node_modules/ccount/",
          "packageDependencies": [
            ["ccount", "npm:1.0.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["chalk", [
        ["npm:2.4.2", {
          "packageLocation": "./.yarn/cache/chalk-npm-2.4.2-3ea16dd91e-1.zip/node_modules/chalk/",
          "packageDependencies": [
            ["chalk", "npm:2.4.2"],
            ["ansi-styles", "npm:3.2.1"],
            ["escape-string-regexp", "npm:1.0.5"],
            ["supports-color", "npm:5.5.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["character-entities", [
        ["npm:1.2.3", {
          "packageLocation": "./.yarn/cache/character-entities-npm-1.2.3-dec832362b-1.zip/node_modules/character-entities/",
          "packageDependencies": [
            ["character-entities", "npm:1.2.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["character-entities-html4", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/character-entities-html4-npm-1.1.3-1cf5f6bd99-1.zip/node_modules/character-entities-html4/",
          "packageDependencies": [
            ["character-entities-html4", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["character-entities-legacy", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/character-entities-legacy-npm-1.1.3-5b4b02fb0c-1.zip/node_modules/character-entities-legacy/",
          "packageDependencies": [
            ["character-entities-legacy", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["character-reference-invalid", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/character-reference-invalid-npm-1.1.3-33113bef4b-1.zip/node_modules/character-reference-invalid/",
          "packageDependencies": [
            ["character-reference-invalid", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["class-utils", [
        ["npm:0.3.6", {
          "packageLocation": "./.yarn/cache/class-utils-npm-0.3.6-2c691ad006-1.zip/node_modules/class-utils/",
          "packageDependencies": [
            ["class-utils", "npm:0.3.6"],
            ["arr-union", "npm:3.1.0"],
            ["define-property", "npm:0.2.5"],
            ["isobject", "npm:3.0.1"],
            ["static-extend", "npm:0.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["clipanion", [
        ["npm:2.0.0-rc.16", {
          "packageLocation": "./.yarn/cache/clipanion-npm-2.0.0-rc.16-b9444aaf89-1.zip/node_modules/clipanion/",
          "packageDependencies": [
            ["clipanion", "npm:2.0.0-rc.16"],
            ["chalk", "npm:2.4.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["collapse-white-space", [
        ["npm:1.0.5", {
          "packageLocation": "./.yarn/cache/collapse-white-space-npm-1.0.5-94cbad9532-1.zip/node_modules/collapse-white-space/",
          "packageDependencies": [
            ["collapse-white-space", "npm:1.0.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["collection-visit", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/collection-visit-npm-1.0.0-aba2d5defc-1.zip/node_modules/collection-visit/",
          "packageDependencies": [
            ["collection-visit", "npm:1.0.0"],
            ["map-visit", "npm:1.0.0"],
            ["object-visit", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["color-convert", [
        ["npm:1.9.3", {
          "packageLocation": "./.yarn/cache/color-convert-npm-1.9.3-1fe690075e-1.zip/node_modules/color-convert/",
          "packageDependencies": [
            ["color-convert", "npm:1.9.3"],
            ["color-name", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["color-name", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/color-name-npm-1.1.3-728b7b5d39-1.zip/node_modules/color-name/",
          "packageDependencies": [
            ["color-name", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["commondir", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/commondir-npm-1.0.1-291b790340-1.zip/node_modules/commondir/",
          "packageDependencies": [
            ["commondir", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["component-emitter", [
        ["npm:1.3.0", {
          "packageLocation": "./.yarn/cache/component-emitter-npm-1.3.0-4b848565b9-1.zip/node_modules/component-emitter/",
          "packageDependencies": [
            ["component-emitter", "npm:1.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["concat-map", [
        ["npm:0.0.1", {
          "packageLocation": "./.yarn/cache/concat-map-npm-0.0.1-85a921b7ee-1.zip/node_modules/concat-map/",
          "packageDependencies": [
            ["concat-map", "npm:0.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["convert-source-map", [
        ["npm:1.6.0", {
          "packageLocation": "./.yarn/cache/convert-source-map-npm-1.6.0-4ea8a63d11-1.zip/node_modules/convert-source-map/",
          "packageDependencies": [
            ["convert-source-map", "npm:1.6.0"],
            ["safe-buffer", "npm:5.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["copy-descriptor", [
        ["npm:0.1.1", {
          "packageLocation": "./.yarn/cache/copy-descriptor-npm-0.1.1-864db4ab66-1.zip/node_modules/copy-descriptor/",
          "packageDependencies": [
            ["copy-descriptor", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["core-js", [
        ["npm:3.1.4", {
          "packageLocation": "./.yarn/cache/core-js-npm-3.1.4-ec86906935-1.zip/node_modules/core-js/",
          "packageDependencies": [
            ["core-js", "npm:3.1.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["cross-spawn", [
        ["npm:6.0.5", {
          "packageLocation": "./.yarn/cache/cross-spawn-npm-6.0.5-2deab6c280-1.zip/node_modules/cross-spawn/",
          "packageDependencies": [
            ["cross-spawn", "npm:6.0.5"],
            ["nice-try", "npm:1.0.5"],
            ["path-key", "npm:2.0.1"],
            ["semver", "npm:5.7.0"],
            ["shebang-command", "npm:1.2.0"],
            ["which", "npm:1.3.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["debug", [
        ["npm:2.6.9", {
          "packageLocation": "./.yarn/cache/debug-npm-2.6.9-7d4cb597dc-1.zip/node_modules/debug/",
          "packageDependencies": [
            ["debug", "npm:2.6.9"],
            ["ms", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:4.1.1", {
          "packageLocation": "./.yarn/cache/debug-npm-4.1.1-540248b3aa-1.zip/node_modules/debug/",
          "packageDependencies": [
            ["debug", "npm:4.1.1"],
            ["ms", "npm:2.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["decode-uri-component", [
        ["npm:0.2.0", {
          "packageLocation": "./.yarn/cache/decode-uri-component-npm-0.2.0-5bcc0f3597-1.zip/node_modules/decode-uri-component/",
          "packageDependencies": [
            ["decode-uri-component", "npm:0.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["deepmerge", [
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/deepmerge-npm-4.0.0-fb84ac55a8-1.zip/node_modules/deepmerge/",
          "packageDependencies": [
            ["deepmerge", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["define-properties", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/define-properties-npm-1.1.3-0f3115e2b9-1.zip/node_modules/define-properties/",
          "packageDependencies": [
            ["define-properties", "npm:1.1.3"],
            ["object-keys", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["define-property", [
        ["npm:0.2.5", {
          "packageLocation": "./.yarn/cache/define-property-npm-0.2.5-44a0da3575-1.zip/node_modules/define-property/",
          "packageDependencies": [
            ["define-property", "npm:0.2.5"],
            ["is-descriptor", "npm:0.1.6"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/define-property-npm-1.0.0-e2fb9f44c6-1.zip/node_modules/define-property/",
          "packageDependencies": [
            ["define-property", "npm:1.0.0"],
            ["is-descriptor", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }],
        ["npm:2.0.2", {
          "packageLocation": "./.yarn/cache/define-property-npm-2.0.2-4a2067c3ba-1.zip/node_modules/define-property/",
          "packageDependencies": [
            ["define-property", "npm:2.0.2"],
            ["is-descriptor", "npm:1.0.2"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["deprecation", [
        ["npm:2.3.1", {
          "packageLocation": "./.yarn/cache/deprecation-npm-2.3.1-e19c92d6e7-1.zip/node_modules/deprecation/",
          "packageDependencies": [
            ["deprecation", "npm:2.3.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["diff-sequences", [
        ["npm:24.3.0", {
          "packageLocation": "./.yarn/cache/diff-sequences-npm-24.3.0-bb6b7a7fe8-1.zip/node_modules/diff-sequences/",
          "packageDependencies": [
            ["diff-sequences", "npm:24.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["end-of-stream", [
        ["npm:1.4.1", {
          "packageLocation": "./.yarn/cache/end-of-stream-npm-1.4.1-ccccf6139c-1.zip/node_modules/end-of-stream/",
          "packageDependencies": [
            ["end-of-stream", "npm:1.4.1"],
            ["once", "npm:1.4.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["escape-string-regexp", [
        ["npm:1.0.5", {
          "packageLocation": "./.yarn/cache/escape-string-regexp-npm-1.0.5-3284de402f-1.zip/node_modules/escape-string-regexp/",
          "packageDependencies": [
            ["escape-string-regexp", "npm:1.0.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["esutils", [
        ["npm:2.0.3", {
          "packageLocation": "./.yarn/cache/esutils-npm-2.0.3-f865beafd5-1.zip/node_modules/esutils/",
          "packageDependencies": [
            ["esutils", "npm:2.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["execa", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/execa-npm-1.0.0-7028e37029-1.zip/node_modules/execa/",
          "packageDependencies": [
            ["execa", "npm:1.0.0"],
            ["cross-spawn", "npm:6.0.5"],
            ["get-stream", "npm:4.1.0"],
            ["is-stream", "npm:1.1.0"],
            ["npm-run-path", "npm:2.0.2"],
            ["p-finally", "npm:1.0.0"],
            ["signal-exit", "npm:3.0.2"],
            ["strip-eof", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["expand-brackets", [
        ["npm:2.1.4", {
          "packageLocation": "./.yarn/cache/expand-brackets-npm-2.1.4-392c703c48-1.zip/node_modules/expand-brackets/",
          "packageDependencies": [
            ["expand-brackets", "npm:2.1.4"],
            ["debug", "npm:2.6.9"],
            ["define-property", "npm:0.2.5"],
            ["extend-shallow", "npm:2.0.1"],
            ["posix-character-classes", "npm:0.1.1"],
            ["regex-not", "npm:1.0.2"],
            ["snapdragon", "npm:0.8.2"],
            ["to-regex", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["expect", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/expect-npm-24.8.0-8c7640c562-1.zip/node_modules/expect/",
          "packageDependencies": [
            ["expect", "npm:24.8.0"],
            ["@jest/types", "npm:24.8.0"],
            ["ansi-styles", "npm:3.2.1"],
            ["jest-get-type", "npm:24.8.0"],
            ["jest-matcher-utils", "npm:24.8.0"],
            ["jest-message-util", "npm:24.8.0"],
            ["jest-regex-util", "npm:24.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["extend", [
        ["npm:3.0.2", {
          "packageLocation": "./.yarn/cache/extend-npm-3.0.2-e1ca07ac54-1.zip/node_modules/extend/",
          "packageDependencies": [
            ["extend", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["extend-shallow", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/extend-shallow-npm-2.0.1-e6ef52b29c-1.zip/node_modules/extend-shallow/",
          "packageDependencies": [
            ["extend-shallow", "npm:2.0.1"],
            ["is-extendable", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }],
        ["npm:3.0.2", {
          "packageLocation": "./.yarn/cache/extend-shallow-npm-3.0.2-77bbe1bbf5-1.zip/node_modules/extend-shallow/",
          "packageDependencies": [
            ["extend-shallow", "npm:3.0.2"],
            ["assign-symbols", "npm:1.0.0"],
            ["is-extendable", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["extglob", [
        ["npm:2.0.4", {
          "packageLocation": "./.yarn/cache/extglob-npm-2.0.4-0f39bc9899-1.zip/node_modules/extglob/",
          "packageDependencies": [
            ["extglob", "npm:2.0.4"],
            ["array-unique", "npm:0.3.2"],
            ["define-property", "npm:1.0.0"],
            ["expand-brackets", "npm:2.1.4"],
            ["extend-shallow", "npm:2.0.1"],
            ["fragment-cache", "npm:0.2.1"],
            ["regex-not", "npm:1.0.2"],
            ["snapdragon", "npm:0.8.2"],
            ["to-regex", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["fill-range", [
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/fill-range-npm-4.0.0-95a6e45784-1.zip/node_modules/fill-range/",
          "packageDependencies": [
            ["fill-range", "npm:4.0.0"],
            ["extend-shallow", "npm:2.0.1"],
            ["is-number", "npm:3.0.0"],
            ["repeat-string", "npm:1.6.1"],
            ["to-regex-range", "npm:2.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["find-cache-dir", [
        ["npm:2.1.0", {
          "packageLocation": "./.yarn/cache/find-cache-dir-npm-2.1.0-772aa82638-1.zip/node_modules/find-cache-dir/",
          "packageDependencies": [
            ["find-cache-dir", "npm:2.1.0"],
            ["commondir", "npm:1.0.1"],
            ["make-dir", "npm:2.1.0"],
            ["pkg-dir", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["find-up", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/find-up-npm-3.0.0-a2d4b1b317-1.zip/node_modules/find-up/",
          "packageDependencies": [
            ["find-up", "npm:3.0.0"],
            ["locate-path", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["fn-name", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/fn-name-npm-2.0.1-955ccc097e-1.zip/node_modules/fn-name/",
          "packageDependencies": [
            ["fn-name", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["for-in", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/for-in-npm-1.0.2-37e3d7aae5-1.zip/node_modules/for-in/",
          "packageDependencies": [
            ["for-in", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["fragment-cache", [
        ["npm:0.2.1", {
          "packageLocation": "./.yarn/cache/fragment-cache-npm-0.2.1-407fe74319-1.zip/node_modules/fragment-cache/",
          "packageDependencies": [
            ["fragment-cache", "npm:0.2.1"],
            ["map-cache", "npm:0.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["fs.realpath", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/fs.realpath-npm-1.0.0-c8f05d8126-1.zip/node_modules/fs.realpath/",
          "packageDependencies": [
            ["fs.realpath", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["function-bind", [
        ["npm:1.1.1", {
          "packageLocation": "./.yarn/cache/function-bind-npm-1.1.1-b56b322ae9-1.zip/node_modules/function-bind/",
          "packageDependencies": [
            ["function-bind", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["get-stream", [
        ["npm:4.1.0", {
          "packageLocation": "./.yarn/cache/get-stream-npm-4.1.0-314d430a5d-1.zip/node_modules/get-stream/",
          "packageDependencies": [
            ["get-stream", "npm:4.1.0"],
            ["pump", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["get-value", [
        ["npm:2.0.6", {
          "packageLocation": "./.yarn/cache/get-value-npm-2.0.6-03cd422e0a-1.zip/node_modules/get-value/",
          "packageDependencies": [
            ["get-value", "npm:2.0.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["git-up", [
        ["npm:4.0.1", {
          "packageLocation": "./.yarn/cache/git-up-npm-4.0.1-53f2054422-1.zip/node_modules/git-up/",
          "packageDependencies": [
            ["git-up", "npm:4.0.1"],
            ["is-ssh", "npm:1.3.1"],
            ["parse-url", "npm:5.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["git-url-parse", [
        ["npm:11.1.2", {
          "packageLocation": "./.yarn/cache/git-url-parse-npm-11.1.2-f0b367da09-1.zip/node_modules/git-url-parse/",
          "packageDependencies": [
            ["git-url-parse", "npm:11.1.2"],
            ["git-up", "npm:4.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["glob", [
        ["npm:7.1.4", {
          "packageLocation": "./.yarn/cache/glob-npm-7.1.4-8bd8317a74-1.zip/node_modules/glob/",
          "packageDependencies": [
            ["glob", "npm:7.1.4"],
            ["fs.realpath", "npm:1.0.0"],
            ["inflight", "npm:1.0.6"],
            ["inherits", "npm:2.0.4"],
            ["minimatch", "npm:3.0.4"],
            ["once", "npm:1.4.0"],
            ["path-is-absolute", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["globals", [
        ["npm:11.12.0", {
          "packageLocation": "./.yarn/cache/globals-npm-11.12.0-1fa7f41a6c-1.zip/node_modules/globals/",
          "packageDependencies": [
            ["globals", "npm:11.12.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["graceful-fs", [
        ["npm:4.2.1", {
          "packageLocation": "./.yarn/cache/graceful-fs-npm-4.2.1-2ea4c3074c-1.zip/node_modules/graceful-fs/",
          "packageDependencies": [
            ["graceful-fs", "npm:4.2.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["has-flag", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/has-flag-npm-3.0.0-16ac11fe05-1.zip/node_modules/has-flag/",
          "packageDependencies": [
            ["has-flag", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["has-symbols", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/has-symbols-npm-1.0.0-3862f1feea-1.zip/node_modules/has-symbols/",
          "packageDependencies": [
            ["has-symbols", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["has-value", [
        ["npm:0.3.1", {
          "packageLocation": "./.yarn/cache/has-value-npm-0.3.1-4a15b6c29f-1.zip/node_modules/has-value/",
          "packageDependencies": [
            ["has-value", "npm:0.3.1"],
            ["get-value", "npm:2.0.6"],
            ["has-values", "npm:0.1.4"],
            ["isobject", "npm:2.1.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/has-value-npm-1.0.0-19d82fd04b-1.zip/node_modules/has-value/",
          "packageDependencies": [
            ["has-value", "npm:1.0.0"],
            ["get-value", "npm:2.0.6"],
            ["has-values", "npm:1.0.0"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["has-values", [
        ["npm:0.1.4", {
          "packageLocation": "./.yarn/cache/has-values-npm-0.1.4-6b4397786d-1.zip/node_modules/has-values/",
          "packageDependencies": [
            ["has-values", "npm:0.1.4"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/has-values-npm-1.0.0-890c077bbd-1.zip/node_modules/has-values/",
          "packageDependencies": [
            ["has-values", "npm:1.0.0"],
            ["is-number", "npm:3.0.0"],
            ["kind-of", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["inflight", [
        ["npm:1.0.6", {
          "packageLocation": "./.yarn/cache/inflight-npm-1.0.6-ccedb4b908-1.zip/node_modules/inflight/",
          "packageDependencies": [
            ["inflight", "npm:1.0.6"],
            ["once", "npm:1.4.0"],
            ["wrappy", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["inherits", [
        ["npm:2.0.4", {
          "packageLocation": "./.yarn/cache/inherits-npm-2.0.4-c66b3957a0-1.zip/node_modules/inherits/",
          "packageDependencies": [
            ["inherits", "npm:2.0.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-accessor-descriptor", [
        ["npm:0.1.6", {
          "packageLocation": "./.yarn/cache/is-accessor-descriptor-npm-0.1.6-41c495d517-1.zip/node_modules/is-accessor-descriptor/",
          "packageDependencies": [
            ["is-accessor-descriptor", "npm:0.1.6"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/is-accessor-descriptor-npm-1.0.0-d8ce016e98-1.zip/node_modules/is-accessor-descriptor/",
          "packageDependencies": [
            ["is-accessor-descriptor", "npm:1.0.0"],
            ["kind-of", "npm:6.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-alphabetical", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-alphabetical-npm-1.0.3-99341afaed-1.zip/node_modules/is-alphabetical/",
          "packageDependencies": [
            ["is-alphabetical", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-alphanumeric", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/is-alphanumeric-npm-1.0.0-d58b7d3fab-1.zip/node_modules/is-alphanumeric/",
          "packageDependencies": [
            ["is-alphanumeric", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-alphanumerical", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-alphanumerical-npm-1.0.3-5233afb71b-1.zip/node_modules/is-alphanumerical/",
          "packageDependencies": [
            ["is-alphanumerical", "npm:1.0.3"],
            ["is-alphabetical", "npm:1.0.3"],
            ["is-decimal", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-buffer", [
        ["npm:1.1.6", {
          "packageLocation": "./.yarn/cache/is-buffer-npm-1.1.6-08199d9ccc-1.zip/node_modules/is-buffer/",
          "packageDependencies": [
            ["is-buffer", "npm:1.1.6"]
          ],
          "linkType": "HARD"
        }],
        ["npm:2.0.3", {
          "packageLocation": "./.yarn/cache/is-buffer-npm-2.0.3-c351d6164e-1.zip/node_modules/is-buffer/",
          "packageDependencies": [
            ["is-buffer", "npm:2.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-data-descriptor", [
        ["npm:0.1.4", {
          "packageLocation": "./.yarn/cache/is-data-descriptor-npm-0.1.4-6f53f71c67-1.zip/node_modules/is-data-descriptor/",
          "packageDependencies": [
            ["is-data-descriptor", "npm:0.1.4"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/is-data-descriptor-npm-1.0.0-f7d2e852ca-1.zip/node_modules/is-data-descriptor/",
          "packageDependencies": [
            ["is-data-descriptor", "npm:1.0.0"],
            ["kind-of", "npm:6.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-decimal", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-decimal-npm-1.0.3-e78f76a38e-1.zip/node_modules/is-decimal/",
          "packageDependencies": [
            ["is-decimal", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-descriptor", [
        ["npm:0.1.6", {
          "packageLocation": "./.yarn/cache/is-descriptor-npm-0.1.6-15c7346839-1.zip/node_modules/is-descriptor/",
          "packageDependencies": [
            ["is-descriptor", "npm:0.1.6"],
            ["is-accessor-descriptor", "npm:0.1.6"],
            ["is-data-descriptor", "npm:0.1.4"],
            ["kind-of", "npm:5.1.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/is-descriptor-npm-1.0.2-5cfc02c444-1.zip/node_modules/is-descriptor/",
          "packageDependencies": [
            ["is-descriptor", "npm:1.0.2"],
            ["is-accessor-descriptor", "npm:1.0.0"],
            ["is-data-descriptor", "npm:1.0.0"],
            ["kind-of", "npm:6.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-extendable", [
        ["npm:0.1.1", {
          "packageLocation": "./.yarn/cache/is-extendable-npm-0.1.1-322b4649ec-1.zip/node_modules/is-extendable/",
          "packageDependencies": [
            ["is-extendable", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/is-extendable-npm-1.0.1-7095ad8b16-1.zip/node_modules/is-extendable/",
          "packageDependencies": [
            ["is-extendable", "npm:1.0.1"],
            ["is-plain-object", "npm:2.0.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-hexadecimal", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-hexadecimal-npm-1.0.3-bbfe0f2bb5-1.zip/node_modules/is-hexadecimal/",
          "packageDependencies": [
            ["is-hexadecimal", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-number", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/is-number-npm-3.0.0-9088035ade-1.zip/node_modules/is-number/",
          "packageDependencies": [
            ["is-number", "npm:3.0.0"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-plain-obj", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/is-plain-obj-npm-2.0.0-381d32333d-1.zip/node_modules/is-plain-obj/",
          "packageDependencies": [
            ["is-plain-obj", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-plain-object", [
        ["npm:2.0.4", {
          "packageLocation": "./.yarn/cache/is-plain-object-npm-2.0.4-da3265d804-1.zip/node_modules/is-plain-object/",
          "packageDependencies": [
            ["is-plain-object", "npm:2.0.4"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }],
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/is-plain-object-npm-3.0.0-c59a1b626c-1.zip/node_modules/is-plain-object/",
          "packageDependencies": [
            ["is-plain-object", "npm:3.0.0"],
            ["isobject", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-ssh", [
        ["npm:1.3.1", {
          "packageLocation": "./.yarn/cache/is-ssh-npm-1.3.1-a45ec50c50-1.zip/node_modules/is-ssh/",
          "packageDependencies": [
            ["is-ssh", "npm:1.3.1"],
            ["protocols", "npm:1.4.7"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-stream", [
        ["npm:1.1.0", {
          "packageLocation": "./.yarn/cache/is-stream-npm-1.1.0-818ecbf6bb-1.zip/node_modules/is-stream/",
          "packageDependencies": [
            ["is-stream", "npm:1.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-whitespace-character", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-whitespace-character-npm-1.0.3-e641c3dd0b-1.zip/node_modules/is-whitespace-character/",
          "packageDependencies": [
            ["is-whitespace-character", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-windows", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/is-windows-npm-1.0.2-898cd6f3d7-1.zip/node_modules/is-windows/",
          "packageDependencies": [
            ["is-windows", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["is-word-character", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/is-word-character-npm-1.0.3-7db3267f64-1.zip/node_modules/is-word-character/",
          "packageDependencies": [
            ["is-word-character", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["isarray", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/isarray-npm-1.0.0-db4f547720-1.zip/node_modules/isarray/",
          "packageDependencies": [
            ["isarray", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["isexe", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/isexe-npm-2.0.0-b58870bd2e-1.zip/node_modules/isexe/",
          "packageDependencies": [
            ["isexe", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["isobject", [
        ["npm:2.1.0", {
          "packageLocation": "./.yarn/cache/isobject-npm-2.1.0-2798cf0d94-1.zip/node_modules/isobject/",
          "packageDependencies": [
            ["isobject", "npm:2.1.0"],
            ["isarray", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:3.0.1", {
          "packageLocation": "./.yarn/cache/isobject-npm-3.0.1-8145901fd2-1.zip/node_modules/isobject/",
          "packageDependencies": [
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }],
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/isobject-npm-4.0.0-9c5174125b-1.zip/node_modules/isobject/",
          "packageDependencies": [
            ["isobject", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jest-diff", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/jest-diff-npm-24.8.0-6b77072d7c-1.zip/node_modules/jest-diff/",
          "packageDependencies": [
            ["jest-diff", "npm:24.8.0"],
            ["chalk", "npm:2.4.2"],
            ["diff-sequences", "npm:24.3.0"],
            ["jest-get-type", "npm:24.8.0"],
            ["pretty-format", "npm:24.8.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jest-get-type", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/jest-get-type-npm-24.8.0-5b4aa7295b-1.zip/node_modules/jest-get-type/",
          "packageDependencies": [
            ["jest-get-type", "npm:24.8.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jest-matcher-utils", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/jest-matcher-utils-npm-24.8.0-e99928f3b9-1.zip/node_modules/jest-matcher-utils/",
          "packageDependencies": [
            ["jest-matcher-utils", "npm:24.8.0"],
            ["chalk", "npm:2.4.2"],
            ["jest-diff", "npm:24.8.0"],
            ["jest-get-type", "npm:24.8.0"],
            ["pretty-format", "npm:24.8.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jest-message-util", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/jest-message-util-npm-24.8.0-1bc641bd0f-1.zip/node_modules/jest-message-util/",
          "packageDependencies": [
            ["jest-message-util", "npm:24.8.0"],
            ["@babel/code-frame", "npm:7.5.5"],
            ["@jest/test-result", "npm:24.8.0"],
            ["@jest/types", "npm:24.8.0"],
            ["@types/stack-utils", "npm:1.0.1"],
            ["chalk", "npm:2.4.2"],
            ["micromatch", "npm:3.1.10"],
            ["slash", "npm:2.0.0"],
            ["stack-utils", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jest-regex-util", [
        ["npm:24.3.0", {
          "packageLocation": "./.yarn/cache/jest-regex-util-npm-24.3.0-46bf162a7a-1.zip/node_modules/jest-regex-util/",
          "packageDependencies": [
            ["jest-regex-util", "npm:24.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["js-tokens", [
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/js-tokens-npm-4.0.0-0ac852e9e2-1.zip/node_modules/js-tokens/",
          "packageDependencies": [
            ["js-tokens", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["jsesc", [
        ["npm:2.5.2", {
          "packageLocation": "./.yarn/cache/jsesc-npm-2.5.2-c5acb78804-1.zip/node_modules/jsesc/",
          "packageDependencies": [
            ["jsesc", "npm:2.5.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["json5", [
        ["npm:2.1.0", {
          "packageLocation": "./.yarn/cache/json5-npm-2.1.0-8e9ce80b06-1.zip/node_modules/json5/",
          "packageDependencies": [
            ["json5", "npm:2.1.0"],
            ["minimist", "npm:1.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["kind-of", [
        ["npm:3.2.2", {
          "packageLocation": "./.yarn/cache/kind-of-npm-3.2.2-7deaffa5f9-1.zip/node_modules/kind-of/",
          "packageDependencies": [
            ["kind-of", "npm:3.2.2"],
            ["is-buffer", "npm:1.1.6"]
          ],
          "linkType": "HARD"
        }],
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/kind-of-npm-4.0.0-69fd153375-1.zip/node_modules/kind-of/",
          "packageDependencies": [
            ["kind-of", "npm:4.0.0"],
            ["is-buffer", "npm:1.1.6"]
          ],
          "linkType": "HARD"
        }],
        ["npm:5.1.0", {
          "packageLocation": "./.yarn/cache/kind-of-npm-5.1.0-ce82f43eaa-1.zip/node_modules/kind-of/",
          "packageDependencies": [
            ["kind-of", "npm:5.1.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:6.0.2", {
          "packageLocation": "./.yarn/cache/kind-of-npm-6.0.2-0465b47e72-1.zip/node_modules/kind-of/",
          "packageDependencies": [
            ["kind-of", "npm:6.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["locate-path", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/locate-path-npm-3.0.0-991671ae9f-1.zip/node_modules/locate-path/",
          "packageDependencies": [
            ["locate-path", "npm:3.0.0"],
            ["p-locate", "npm:3.0.0"],
            ["path-exists", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["lodash", [
        ["npm:4.17.15", {
          "packageLocation": "./.yarn/cache/lodash-npm-4.17.15-566d9324f7-1.zip/node_modules/lodash/",
          "packageDependencies": [
            ["lodash", "npm:4.17.15"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["lodash.get", [
        ["npm:4.4.2", {
          "packageLocation": "./.yarn/cache/lodash.get-npm-4.4.2-7bda64ed87-1.zip/node_modules/lodash.get/",
          "packageDependencies": [
            ["lodash.get", "npm:4.4.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["lodash.set", [
        ["npm:4.3.2", {
          "packageLocation": "./.yarn/cache/lodash.set-npm-4.3.2-7586c942c2-1.zip/node_modules/lodash.set/",
          "packageDependencies": [
            ["lodash.set", "npm:4.3.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["lodash.uniq", [
        ["npm:4.5.0", {
          "packageLocation": "./.yarn/cache/lodash.uniq-npm-4.5.0-7c270dca85-1.zip/node_modules/lodash.uniq/",
          "packageDependencies": [
            ["lodash.uniq", "npm:4.5.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["longest-streak", [
        ["npm:2.0.3", {
          "packageLocation": "./.yarn/cache/longest-streak-npm-2.0.3-65d23aca91-1.zip/node_modules/longest-streak/",
          "packageDependencies": [
            ["longest-streak", "npm:2.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["macos-release", [
        ["npm:2.3.0", {
          "packageLocation": "./.yarn/cache/macos-release-npm-2.3.0-68f3012f58-1.zip/node_modules/macos-release/",
          "packageDependencies": [
            ["macos-release", "npm:2.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["make-dir", [
        ["npm:2.1.0", {
          "packageLocation": "./.yarn/cache/make-dir-npm-2.1.0-1ddaf205e7-1.zip/node_modules/make-dir/",
          "packageDependencies": [
            ["make-dir", "npm:2.1.0"],
            ["pify", "npm:4.0.1"],
            ["semver", "npm:5.7.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["map-cache", [
        ["npm:0.2.2", {
          "packageLocation": "./.yarn/cache/map-cache-npm-0.2.2-1620199b05-1.zip/node_modules/map-cache/",
          "packageDependencies": [
            ["map-cache", "npm:0.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["map-visit", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/map-visit-npm-1.0.0-33a7988a9d-1.zip/node_modules/map-visit/",
          "packageDependencies": [
            ["map-visit", "npm:1.0.0"],
            ["object-visit", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["markdown-escapes", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/markdown-escapes-npm-1.0.3-f199ab1614-1.zip/node_modules/markdown-escapes/",
          "packageDependencies": [
            ["markdown-escapes", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["markdown-table", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/markdown-table-npm-1.1.3-b4e801a569-1.zip/node_modules/markdown-table/",
          "packageDependencies": [
            ["markdown-table", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["mdast-util-compact", [
        ["npm:1.0.3", {
          "packageLocation": "./.yarn/cache/mdast-util-compact-npm-1.0.3-24e2b193fa-1.zip/node_modules/mdast-util-compact/",
          "packageDependencies": [
            ["mdast-util-compact", "npm:1.0.3"],
            ["unist-util-visit", "npm:1.4.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["micromatch", [
        ["npm:3.1.10", {
          "packageLocation": "./.yarn/cache/micromatch-npm-3.1.10-016e80c79d-1.zip/node_modules/micromatch/",
          "packageDependencies": [
            ["micromatch", "npm:3.1.10"],
            ["arr-diff", "npm:4.0.0"],
            ["array-unique", "npm:0.3.2"],
            ["braces", "npm:2.3.2"],
            ["define-property", "npm:2.0.2"],
            ["extend-shallow", "npm:3.0.2"],
            ["extglob", "npm:2.0.4"],
            ["fragment-cache", "npm:0.2.1"],
            ["kind-of", "npm:6.0.2"],
            ["nanomatch", "npm:1.2.13"],
            ["object.pick", "npm:1.3.0"],
            ["regex-not", "npm:1.0.2"],
            ["snapdragon", "npm:0.8.2"],
            ["to-regex", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["minimatch", [
        ["npm:3.0.4", {
          "packageLocation": "./.yarn/cache/minimatch-npm-3.0.4-6e76f51c23-1.zip/node_modules/minimatch/",
          "packageDependencies": [
            ["minimatch", "npm:3.0.4"],
            ["brace-expansion", "npm:1.1.11"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["minimist", [
        ["npm:0.0.8", {
          "packageLocation": "./.yarn/cache/minimist-npm-0.0.8-8139f8b2f5-1.zip/node_modules/minimist/",
          "packageDependencies": [
            ["minimist", "npm:0.0.8"]
          ],
          "linkType": "HARD"
        }],
        ["npm:1.2.0", {
          "packageLocation": "./.yarn/cache/minimist-npm-1.2.0-214f53c090-1.zip/node_modules/minimist/",
          "packageDependencies": [
            ["minimist", "npm:1.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["mixin-deep", [
        ["npm:1.3.2", {
          "packageLocation": "./.yarn/cache/mixin-deep-npm-1.3.2-29b528e571-1.zip/node_modules/mixin-deep/",
          "packageDependencies": [
            ["mixin-deep", "npm:1.3.2"],
            ["for-in", "npm:1.0.2"],
            ["is-extendable", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["mkdirp", [
        ["npm:0.5.1", {
          "packageLocation": "./.yarn/cache/mkdirp-npm-0.5.1-33a164c39d-1.zip/node_modules/mkdirp/",
          "packageDependencies": [
            ["mkdirp", "npm:0.5.1"],
            ["minimist", "npm:0.0.8"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["ms", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/ms-npm-2.0.0-9e1101a471-1.zip/node_modules/ms/",
          "packageDependencies": [
            ["ms", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:2.1.2", {
          "packageLocation": "./.yarn/cache/ms-npm-2.1.2-ec0c1512ff-1.zip/node_modules/ms/",
          "packageDependencies": [
            ["ms", "npm:2.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["nanomatch", [
        ["npm:1.2.13", {
          "packageLocation": "./.yarn/cache/nanomatch-npm-1.2.13-bc9173dbe7-1.zip/node_modules/nanomatch/",
          "packageDependencies": [
            ["nanomatch", "npm:1.2.13"],
            ["arr-diff", "npm:4.0.0"],
            ["array-unique", "npm:0.3.2"],
            ["define-property", "npm:2.0.2"],
            ["extend-shallow", "npm:3.0.2"],
            ["fragment-cache", "npm:0.2.1"],
            ["is-windows", "npm:1.0.2"],
            ["kind-of", "npm:6.0.2"],
            ["object.pick", "npm:1.3.0"],
            ["regex-not", "npm:1.0.2"],
            ["snapdragon", "npm:0.8.2"],
            ["to-regex", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["nice-try", [
        ["npm:1.0.5", {
          "packageLocation": "./.yarn/cache/nice-try-npm-1.0.5-963856b16f-1.zip/node_modules/nice-try/",
          "packageDependencies": [
            ["nice-try", "npm:1.0.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["node-fetch", [
        ["npm:2.6.0", {
          "packageLocation": "./.yarn/cache/node-fetch-npm-2.6.0-29c7a53447-1.zip/node_modules/node-fetch/",
          "packageDependencies": [
            ["node-fetch", "npm:2.6.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["node-modules-regexp", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/node-modules-regexp-npm-1.0.0-2f5f5ba9c6-1.zip/node_modules/node-modules-regexp/",
          "packageDependencies": [
            ["node-modules-regexp", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["normalize-url", [
        ["npm:3.3.0", {
          "packageLocation": "./.yarn/cache/normalize-url-npm-3.3.0-f91cbdff7c-1.zip/node_modules/normalize-url/",
          "packageDependencies": [
            ["normalize-url", "npm:3.3.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["npm-run-path", [
        ["npm:2.0.2", {
          "packageLocation": "./.yarn/cache/npm-run-path-npm-2.0.2-96c8b48857-1.zip/node_modules/npm-run-path/",
          "packageDependencies": [
            ["npm-run-path", "npm:2.0.2"],
            ["path-key", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["object-copy", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/object-copy-npm-0.1.0-e229d02f2b-1.zip/node_modules/object-copy/",
          "packageDependencies": [
            ["object-copy", "npm:0.1.0"],
            ["copy-descriptor", "npm:0.1.1"],
            ["define-property", "npm:0.2.5"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["object-keys", [
        ["npm:1.1.1", {
          "packageLocation": "./.yarn/cache/object-keys-npm-1.1.1-1bf2f1be93-1.zip/node_modules/object-keys/",
          "packageDependencies": [
            ["object-keys", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["object-visit", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/object-visit-npm-1.0.1-c5c9057c24-1.zip/node_modules/object-visit/",
          "packageDependencies": [
            ["object-visit", "npm:1.0.1"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["object.assign", [
        ["npm:4.1.0", {
          "packageLocation": "./.yarn/cache/object.assign-npm-4.1.0-2a284b2bf7-1.zip/node_modules/object.assign/",
          "packageDependencies": [
            ["object.assign", "npm:4.1.0"],
            ["define-properties", "npm:1.1.3"],
            ["function-bind", "npm:1.1.1"],
            ["has-symbols", "npm:1.0.0"],
            ["object-keys", "npm:1.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["object.pick", [
        ["npm:1.3.0", {
          "packageLocation": "./.yarn/cache/object.pick-npm-1.3.0-dad8eae8fb-1.zip/node_modules/object.pick/",
          "packageDependencies": [
            ["object.pick", "npm:1.3.0"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["octokit-pagination-methods", [
        ["npm:1.1.0", {
          "packageLocation": "./.yarn/cache/octokit-pagination-methods-npm-1.1.0-ce2bd023d6-1.zip/node_modules/octokit-pagination-methods/",
          "packageDependencies": [
            ["octokit-pagination-methods", "npm:1.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["once", [
        ["npm:1.4.0", {
          "packageLocation": "./.yarn/cache/once-npm-1.4.0-ccf03ef07a-1.zip/node_modules/once/",
          "packageDependencies": [
            ["once", "npm:1.4.0"],
            ["wrappy", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["os-name", [
        ["npm:3.1.0", {
          "packageLocation": "./.yarn/cache/os-name-npm-3.1.0-b5e3fb36cd-1.zip/node_modules/os-name/",
          "packageDependencies": [
            ["os-name", "npm:3.1.0"],
            ["macos-release", "npm:2.3.0"],
            ["windows-release", "npm:3.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["p-finally", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/p-finally-npm-1.0.0-35fbaa57c6-1.zip/node_modules/p-finally/",
          "packageDependencies": [
            ["p-finally", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["p-limit", [
        ["npm:2.2.0", {
          "packageLocation": "./.yarn/cache/p-limit-npm-2.2.0-d458ce1c4b-1.zip/node_modules/p-limit/",
          "packageDependencies": [
            ["p-limit", "npm:2.2.0"],
            ["p-try", "npm:2.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["p-locate", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/p-locate-npm-3.0.0-74de74f952-1.zip/node_modules/p-locate/",
          "packageDependencies": [
            ["p-locate", "npm:3.0.0"],
            ["p-limit", "npm:2.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["p-try", [
        ["npm:2.2.0", {
          "packageLocation": "./.yarn/cache/p-try-npm-2.2.0-e0390dbaf8-1.zip/node_modules/p-try/",
          "packageDependencies": [
            ["p-try", "npm:2.2.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["parse-entities", [
        ["npm:1.2.2", {
          "packageLocation": "./.yarn/cache/parse-entities-npm-1.2.2-6be249f6ff-1.zip/node_modules/parse-entities/",
          "packageDependencies": [
            ["parse-entities", "npm:1.2.2"],
            ["character-entities", "npm:1.2.3"],
            ["character-entities-legacy", "npm:1.1.3"],
            ["character-reference-invalid", "npm:1.1.3"],
            ["is-alphanumerical", "npm:1.0.3"],
            ["is-decimal", "npm:1.0.3"],
            ["is-hexadecimal", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["parse-github-url", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/parse-github-url-npm-1.0.2-290c32ecbc-1.zip/node_modules/parse-github-url/",
          "packageDependencies": [
            ["parse-github-url", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["parse-path", [
        ["npm:4.0.1", {
          "packageLocation": "./.yarn/cache/parse-path-npm-4.0.1-2df1e9ed3e-1.zip/node_modules/parse-path/",
          "packageDependencies": [
            ["parse-path", "npm:4.0.1"],
            ["is-ssh", "npm:1.3.1"],
            ["protocols", "npm:1.4.7"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["parse-url", [
        ["npm:5.0.1", {
          "packageLocation": "./.yarn/cache/parse-url-npm-5.0.1-57615de346-1.zip/node_modules/parse-url/",
          "packageDependencies": [
            ["parse-url", "npm:5.0.1"],
            ["is-ssh", "npm:1.3.1"],
            ["normalize-url", "npm:3.3.0"],
            ["parse-path", "npm:4.0.1"],
            ["protocols", "npm:1.4.7"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pascalcase", [
        ["npm:0.1.1", {
          "packageLocation": "./.yarn/cache/pascalcase-npm-0.1.1-d04964fcda-1.zip/node_modules/pascalcase/",
          "packageDependencies": [
            ["pascalcase", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["path-exists", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/path-exists-npm-3.0.0-e80371aa68-1.zip/node_modules/path-exists/",
          "packageDependencies": [
            ["path-exists", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["path-is-absolute", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/path-is-absolute-npm-1.0.1-31bc695ffd-1.zip/node_modules/path-is-absolute/",
          "packageDependencies": [
            ["path-is-absolute", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["path-key", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/path-key-npm-2.0.1-b1a971833d-1.zip/node_modules/path-key/",
          "packageDependencies": [
            ["path-key", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["path-parse", [
        ["npm:1.0.6", {
          "packageLocation": "./.yarn/cache/path-parse-npm-1.0.6-4a4c90546c-1.zip/node_modules/path-parse/",
          "packageDependencies": [
            ["path-parse", "npm:1.0.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pify", [
        ["npm:4.0.1", {
          "packageLocation": "./.yarn/cache/pify-npm-4.0.1-062756097b-1.zip/node_modules/pify/",
          "packageDependencies": [
            ["pify", "npm:4.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pirates", [
        ["npm:4.0.1", {
          "packageLocation": "./.yarn/cache/pirates-npm-4.0.1-377058e8fc-1.zip/node_modules/pirates/",
          "packageDependencies": [
            ["pirates", "npm:4.0.1"],
            ["node-modules-regexp", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pkg-dir", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/pkg-dir-npm-3.0.0-16d8d93783-1.zip/node_modules/pkg-dir/",
          "packageDependencies": [
            ["pkg-dir", "npm:3.0.0"],
            ["find-up", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pkg-up", [
        ["npm:3.1.0", {
          "packageLocation": "./.yarn/cache/pkg-up-npm-3.1.0-1eebe033b7-1.zip/node_modules/pkg-up/",
          "packageDependencies": [
            ["pkg-up", "npm:3.1.0"],
            ["find-up", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["posix-character-classes", [
        ["npm:0.1.1", {
          "packageLocation": "./.yarn/cache/posix-character-classes-npm-0.1.1-3e228a6e15-1.zip/node_modules/posix-character-classes/",
          "packageDependencies": [
            ["posix-character-classes", "npm:0.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pretty-format", [
        ["npm:24.8.0", {
          "packageLocation": "./.yarn/cache/pretty-format-npm-24.8.0-1dfe5ab0f7-1.zip/node_modules/pretty-format/",
          "packageDependencies": [
            ["pretty-format", "npm:24.8.0"],
            ["@jest/types", "npm:24.8.0"],
            ["ansi-regex", "npm:4.1.0"],
            ["ansi-styles", "npm:3.2.1"],
            ["react-is", "npm:16.8.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["property-expr", [
        ["npm:1.5.1", {
          "packageLocation": "./.yarn/cache/property-expr-npm-1.5.1-110ed85215-1.zip/node_modules/property-expr/",
          "packageDependencies": [
            ["property-expr", "npm:1.5.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["protocols", [
        ["npm:1.4.7", {
          "packageLocation": "./.yarn/cache/protocols-npm-1.4.7-490c536d90-1.zip/node_modules/protocols/",
          "packageDependencies": [
            ["protocols", "npm:1.4.7"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["pump", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/pump-npm-3.0.0-0080bf6a7a-1.zip/node_modules/pump/",
          "packageDependencies": [
            ["pump", "npm:3.0.0"],
            ["end-of-stream", "npm:1.4.1"],
            ["once", "npm:1.4.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["react-is", [
        ["npm:16.8.6", {
          "packageLocation": "./.yarn/cache/react-is-npm-16.8.6-8393ba3817-1.zip/node_modules/react-is/",
          "packageDependencies": [
            ["react-is", "npm:16.8.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["regenerator-runtime", [
        ["npm:0.13.3", {
          "packageLocation": "./.yarn/cache/regenerator-runtime-npm-0.13.3-bc3b9ae29d-1.zip/node_modules/regenerator-runtime/",
          "packageDependencies": [
            ["regenerator-runtime", "npm:0.13.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["regex-not", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/regex-not-npm-1.0.2-06a03c9206-1.zip/node_modules/regex-not/",
          "packageDependencies": [
            ["regex-not", "npm:1.0.2"],
            ["extend-shallow", "npm:3.0.2"],
            ["safe-regex", "npm:1.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["remark", [
        ["npm:11.0.1", {
          "packageLocation": "./.yarn/cache/remark-npm-11.0.1-c720a2d635-1.zip/node_modules/remark/",
          "packageDependencies": [
            ["remark", "npm:11.0.1"],
            ["remark-parse", "npm:7.0.1"],
            ["remark-stringify", "npm:7.0.2"],
            ["unified", "npm:8.3.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["remark-parse", [
        ["npm:7.0.1", {
          "packageLocation": "./.yarn/cache/remark-parse-npm-7.0.1-a7c13abb40-1.zip/node_modules/remark-parse/",
          "packageDependencies": [
            ["remark-parse", "npm:7.0.1"],
            ["collapse-white-space", "npm:1.0.5"],
            ["is-alphabetical", "npm:1.0.3"],
            ["is-decimal", "npm:1.0.3"],
            ["is-whitespace-character", "npm:1.0.3"],
            ["is-word-character", "npm:1.0.3"],
            ["markdown-escapes", "npm:1.0.3"],
            ["parse-entities", "npm:1.2.2"],
            ["repeat-string", "npm:1.6.1"],
            ["state-toggle", "npm:1.0.2"],
            ["trim", "npm:0.0.1"],
            ["trim-trailing-lines", "npm:1.1.2"],
            ["unherit", "npm:1.1.2"],
            ["unist-util-remove-position", "npm:1.1.3"],
            ["vfile-location", "npm:2.0.5"],
            ["xtend", "npm:4.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["remark-stringify", [
        ["npm:7.0.2", {
          "packageLocation": "./.yarn/cache/remark-stringify-npm-7.0.2-5b57630b9e-1.zip/node_modules/remark-stringify/",
          "packageDependencies": [
            ["remark-stringify", "npm:7.0.2"],
            ["ccount", "npm:1.0.4"],
            ["is-alphanumeric", "npm:1.0.0"],
            ["is-decimal", "npm:1.0.3"],
            ["is-whitespace-character", "npm:1.0.3"],
            ["longest-streak", "npm:2.0.3"],
            ["markdown-escapes", "npm:1.0.3"],
            ["markdown-table", "npm:1.1.3"],
            ["mdast-util-compact", "npm:1.0.3"],
            ["parse-entities", "npm:1.2.2"],
            ["repeat-string", "npm:1.6.1"],
            ["state-toggle", "npm:1.0.2"],
            ["stringify-entities", "npm:2.0.0"],
            ["unherit", "npm:1.1.2"],
            ["xtend", "npm:4.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["repeat-element", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/repeat-element-npm-1.1.3-a9dee226b4-1.zip/node_modules/repeat-element/",
          "packageDependencies": [
            ["repeat-element", "npm:1.1.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["repeat-string", [
        ["npm:1.6.1", {
          "packageLocation": "./.yarn/cache/repeat-string-npm-1.6.1-bc8e388655-1.zip/node_modules/repeat-string/",
          "packageDependencies": [
            ["repeat-string", "npm:1.6.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["replace-ext", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/replace-ext-npm-1.0.0-5d4ecb34ac-1.zip/node_modules/replace-ext/",
          "packageDependencies": [
            ["replace-ext", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["resolve", [
        ["npm:1.12.0", {
          "packageLocation": "./.yarn/cache/resolve-npm-1.12.0-3d72fc562f-1.zip/node_modules/resolve/",
          "packageDependencies": [
            ["resolve", "npm:1.12.0"],
            ["path-parse", "npm:1.0.6"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["resolve-url", [
        ["npm:0.2.1", {
          "packageLocation": "./.yarn/cache/resolve-url-npm-0.2.1-39edb8f908-1.zip/node_modules/resolve-url/",
          "packageDependencies": [
            ["resolve-url", "npm:0.2.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["ret", [
        ["npm:0.1.15", {
          "packageLocation": "./.yarn/cache/ret-npm-0.1.15-0d3c19de76-1.zip/node_modules/ret/",
          "packageDependencies": [
            ["ret", "npm:0.1.15"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["rimraf", [
        ["npm:2.6.3", {
          "packageLocation": "./.yarn/cache/rimraf-npm-2.6.3-f34c6c72ec-1.zip/node_modules/rimraf/",
          "packageDependencies": [
            ["rimraf", "npm:2.6.3"],
            ["glob", "npm:7.1.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["safe-buffer", [
        ["npm:5.1.2", {
          "packageLocation": "./.yarn/cache/safe-buffer-npm-5.1.2-c27fedf6c4-1.zip/node_modules/safe-buffer/",
          "packageDependencies": [
            ["safe-buffer", "npm:5.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["safe-regex", [
        ["npm:1.1.0", {
          "packageLocation": "./.yarn/cache/safe-regex-npm-1.1.0-a908e8515c-1.zip/node_modules/safe-regex/",
          "packageDependencies": [
            ["safe-regex", "npm:1.1.0"],
            ["ret", "npm:0.1.15"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["semver", [
        ["npm:5.7.0", {
          "packageLocation": "./.yarn/cache/semver-npm-5.7.0-c5ad532a17-1.zip/node_modules/semver/",
          "packageDependencies": [
            ["semver", "npm:5.7.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["set-value", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/set-value-npm-2.0.1-35da5f8180-1.zip/node_modules/set-value/",
          "packageDependencies": [
            ["set-value", "npm:2.0.1"],
            ["extend-shallow", "npm:2.0.1"],
            ["is-extendable", "npm:0.1.1"],
            ["is-plain-object", "npm:2.0.4"],
            ["split-string", "npm:3.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["shebang-command", [
        ["npm:1.2.0", {
          "packageLocation": "./.yarn/cache/shebang-command-npm-1.2.0-8990ba5d1d-1.zip/node_modules/shebang-command/",
          "packageDependencies": [
            ["shebang-command", "npm:1.2.0"],
            ["shebang-regex", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["shebang-regex", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/shebang-regex-npm-1.0.0-c3612b74e9-1.zip/node_modules/shebang-regex/",
          "packageDependencies": [
            ["shebang-regex", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["signal-exit", [
        ["npm:3.0.2", {
          "packageLocation": "./.yarn/cache/signal-exit-npm-3.0.2-5919f57fbd-1.zip/node_modules/signal-exit/",
          "packageDependencies": [
            ["signal-exit", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["slash", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/slash-npm-2.0.0-69009eac54-1.zip/node_modules/slash/",
          "packageDependencies": [
            ["slash", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["snapdragon", [
        ["npm:0.8.2", {
          "packageLocation": "./.yarn/cache/snapdragon-npm-0.8.2-2bcc47d217-1.zip/node_modules/snapdragon/",
          "packageDependencies": [
            ["snapdragon", "npm:0.8.2"],
            ["base", "npm:0.11.2"],
            ["debug", "npm:2.6.9"],
            ["define-property", "npm:0.2.5"],
            ["extend-shallow", "npm:2.0.1"],
            ["map-cache", "npm:0.2.2"],
            ["source-map", "npm:0.5.7"],
            ["source-map-resolve", "npm:0.5.2"],
            ["use", "npm:3.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["snapdragon-node", [
        ["npm:2.1.1", {
          "packageLocation": "./.yarn/cache/snapdragon-node-npm-2.1.1-78bc70e8e2-1.zip/node_modules/snapdragon-node/",
          "packageDependencies": [
            ["snapdragon-node", "npm:2.1.1"],
            ["define-property", "npm:1.0.0"],
            ["isobject", "npm:3.0.1"],
            ["snapdragon-util", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["snapdragon-util", [
        ["npm:3.0.1", {
          "packageLocation": "./.yarn/cache/snapdragon-util-npm-3.0.1-36b5a7829d-1.zip/node_modules/snapdragon-util/",
          "packageDependencies": [
            ["snapdragon-util", "npm:3.0.1"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["source-map", [
        ["npm:0.5.7", {
          "packageLocation": "./.yarn/cache/source-map-npm-0.5.7-7c3f035429-1.zip/node_modules/source-map/",
          "packageDependencies": [
            ["source-map", "npm:0.5.7"]
          ],
          "linkType": "HARD"
        }],
        ["npm:0.6.1", {
          "packageLocation": "./.yarn/cache/source-map-npm-0.6.1-1a3621db16-1.zip/node_modules/source-map/",
          "packageDependencies": [
            ["source-map", "npm:0.6.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["source-map-resolve", [
        ["npm:0.5.2", {
          "packageLocation": "./.yarn/cache/source-map-resolve-npm-0.5.2-b85aaef39a-1.zip/node_modules/source-map-resolve/",
          "packageDependencies": [
            ["source-map-resolve", "npm:0.5.2"],
            ["atob", "npm:2.1.2"],
            ["decode-uri-component", "npm:0.2.0"],
            ["resolve-url", "npm:0.2.1"],
            ["source-map-url", "npm:0.4.0"],
            ["urix", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["source-map-support", [
        ["npm:0.5.13", {
          "packageLocation": "./.yarn/cache/source-map-support-npm-0.5.13-377dfd7321-1.zip/node_modules/source-map-support/",
          "packageDependencies": [
            ["source-map-support", "npm:0.5.13"],
            ["buffer-from", "npm:1.1.1"],
            ["source-map", "npm:0.6.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["source-map-url", [
        ["npm:0.4.0", {
          "packageLocation": "./.yarn/cache/source-map-url-npm-0.4.0-011efde48b-1.zip/node_modules/source-map-url/",
          "packageDependencies": [
            ["source-map-url", "npm:0.4.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["split-string", [
        ["npm:3.1.0", {
          "packageLocation": "./.yarn/cache/split-string-npm-3.1.0-df5d83450e-1.zip/node_modules/split-string/",
          "packageDependencies": [
            ["split-string", "npm:3.1.0"],
            ["extend-shallow", "npm:3.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["stack-utils", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/stack-utils-npm-1.0.2-a53fc54747-1.zip/node_modules/stack-utils/",
          "packageDependencies": [
            ["stack-utils", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["state-toggle", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/state-toggle-npm-1.0.2-011fd812d1-1.zip/node_modules/state-toggle/",
          "packageDependencies": [
            ["state-toggle", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["static-extend", [
        ["npm:0.1.2", {
          "packageLocation": "./.yarn/cache/static-extend-npm-0.1.2-2720ee6882-1.zip/node_modules/static-extend/",
          "packageDependencies": [
            ["static-extend", "npm:0.1.2"],
            ["define-property", "npm:0.2.5"],
            ["object-copy", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["stringify-entities", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/stringify-entities-npm-2.0.0-2c982f117f-1.zip/node_modules/stringify-entities/",
          "packageDependencies": [
            ["stringify-entities", "npm:2.0.0"],
            ["character-entities-html4", "npm:1.1.3"],
            ["character-entities-legacy", "npm:1.1.3"],
            ["is-alphanumerical", "npm:1.0.3"],
            ["is-decimal", "npm:1.0.3"],
            ["is-hexadecimal", "npm:1.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["strip-eof", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/strip-eof-npm-1.0.0-d82eaf947c-1.zip/node_modules/strip-eof/",
          "packageDependencies": [
            ["strip-eof", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["supports-color", [
        ["npm:5.5.0", {
          "packageLocation": "./.yarn/cache/supports-color-npm-5.5.0-183ac537bc-1.zip/node_modules/supports-color/",
          "packageDependencies": [
            ["supports-color", "npm:5.5.0"],
            ["has-flag", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["synchronous-promise", [
        ["npm:2.0.9", {
          "packageLocation": "./.yarn/cache/synchronous-promise-npm-2.0.9-6a134066fa-1.zip/node_modules/synchronous-promise/",
          "packageDependencies": [
            ["synchronous-promise", "npm:2.0.9"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["tmp", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/tmp-npm-0.1.0-fa18ef19c4-1.zip/node_modules/tmp/",
          "packageDependencies": [
            ["tmp", "npm:0.1.0"],
            ["rimraf", "npm:2.6.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["to-fast-properties", [
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/to-fast-properties-npm-2.0.0-0dc60cc481-1.zip/node_modules/to-fast-properties/",
          "packageDependencies": [
            ["to-fast-properties", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["to-object-path", [
        ["npm:0.3.0", {
          "packageLocation": "./.yarn/cache/to-object-path-npm-0.3.0-241b5ffa9c-1.zip/node_modules/to-object-path/",
          "packageDependencies": [
            ["to-object-path", "npm:0.3.0"],
            ["kind-of", "npm:3.2.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["to-regex", [
        ["npm:3.0.2", {
          "packageLocation": "./.yarn/cache/to-regex-npm-3.0.2-3af893c972-1.zip/node_modules/to-regex/",
          "packageDependencies": [
            ["to-regex", "npm:3.0.2"],
            ["define-property", "npm:2.0.2"],
            ["extend-shallow", "npm:3.0.2"],
            ["regex-not", "npm:1.0.2"],
            ["safe-regex", "npm:1.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["to-regex-range", [
        ["npm:2.1.1", {
          "packageLocation": "./.yarn/cache/to-regex-range-npm-2.1.1-60af4c593e-1.zip/node_modules/to-regex-range/",
          "packageDependencies": [
            ["to-regex-range", "npm:2.1.1"],
            ["is-number", "npm:3.0.0"],
            ["repeat-string", "npm:1.6.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["toposort", [
        ["npm:2.0.2", {
          "packageLocation": "./.yarn/cache/toposort-npm-2.0.2-d472329c7d-1.zip/node_modules/toposort/",
          "packageDependencies": [
            ["toposort", "npm:2.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["trim", [
        ["npm:0.0.1", {
          "packageLocation": "./.yarn/cache/trim-npm-0.0.1-d138075543-1.zip/node_modules/trim/",
          "packageDependencies": [
            ["trim", "npm:0.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["trim-right", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/trim-right-npm-1.0.1-8ccc457eb4-1.zip/node_modules/trim-right/",
          "packageDependencies": [
            ["trim-right", "npm:1.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["trim-trailing-lines", [
        ["npm:1.1.2", {
          "packageLocation": "./.yarn/cache/trim-trailing-lines-npm-1.1.2-69de7238c4-1.zip/node_modules/trim-trailing-lines/",
          "packageDependencies": [
            ["trim-trailing-lines", "npm:1.1.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["trough", [
        ["npm:1.0.4", {
          "packageLocation": "./.yarn/cache/trough-npm-1.0.4-146509a4be-1.zip/node_modules/trough/",
          "packageDependencies": [
            ["trough", "npm:1.0.4"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["typescript", [
        ["npm:3.5.3", {
          "packageLocation": "./.yarn/cache/typescript-npm-3.5.3-7e285f86b3-1.zip/node_modules/typescript/",
          "packageDependencies": [
            ["typescript", "npm:3.5.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unherit", [
        ["npm:1.1.2", {
          "packageLocation": "./.yarn/cache/unherit-npm-1.1.2-b37f2c6f5e-1.zip/node_modules/unherit/",
          "packageDependencies": [
            ["unherit", "npm:1.1.2"],
            ["inherits", "npm:2.0.4"],
            ["xtend", "npm:4.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unified", [
        ["npm:8.3.2", {
          "packageLocation": "./.yarn/cache/unified-npm-8.3.2-edc4c876f2-1.zip/node_modules/unified/",
          "packageDependencies": [
            ["unified", "npm:8.3.2"],
            ["bail", "npm:1.0.4"],
            ["extend", "npm:3.0.2"],
            ["is-plain-obj", "npm:2.0.0"],
            ["trough", "npm:1.0.4"],
            ["vfile", "npm:4.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["union-value", [
        ["npm:1.0.1", {
          "packageLocation": "./.yarn/cache/union-value-npm-1.0.1-76c6e8a88f-1.zip/node_modules/union-value/",
          "packageDependencies": [
            ["union-value", "npm:1.0.1"],
            ["arr-union", "npm:3.1.0"],
            ["get-value", "npm:2.0.6"],
            ["is-extendable", "npm:0.1.1"],
            ["set-value", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unist-util-is", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/unist-util-is-npm-3.0.0-1816040586-1.zip/node_modules/unist-util-is/",
          "packageDependencies": [
            ["unist-util-is", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:4.0.0", {
          "packageLocation": "./.yarn/cache/unist-util-is-npm-4.0.0-e6228f25f6-1.zip/node_modules/unist-util-is/",
          "packageDependencies": [
            ["unist-util-is", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unist-util-remove-position", [
        ["npm:1.1.3", {
          "packageLocation": "./.yarn/cache/unist-util-remove-position-npm-1.1.3-4f00cc70e1-1.zip/node_modules/unist-util-remove-position/",
          "packageDependencies": [
            ["unist-util-remove-position", "npm:1.1.3"],
            ["unist-util-visit", "npm:1.4.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unist-util-stringify-position", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/unist-util-stringify-position-npm-2.0.1-d3df554a76-1.zip/node_modules/unist-util-stringify-position/",
          "packageDependencies": [
            ["unist-util-stringify-position", "npm:2.0.1"],
            ["@types/unist", "npm:2.0.3"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unist-util-visit", [
        ["npm:1.4.1", {
          "packageLocation": "./.yarn/cache/unist-util-visit-npm-1.4.1-fdb79796c9-1.zip/node_modules/unist-util-visit/",
          "packageDependencies": [
            ["unist-util-visit", "npm:1.4.1"],
            ["unist-util-visit-parents", "npm:2.1.2"]
          ],
          "linkType": "HARD"
        }],
        ["npm:2.0.0", {
          "packageLocation": "./.yarn/cache/unist-util-visit-npm-2.0.0-4bf18f9e2f-1.zip/node_modules/unist-util-visit/",
          "packageDependencies": [
            ["unist-util-visit", "npm:2.0.0"],
            ["@types/unist", "npm:2.0.3"],
            ["unist-util-is", "npm:4.0.0"],
            ["unist-util-visit-parents", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unist-util-visit-parents", [
        ["npm:2.1.2", {
          "packageLocation": "./.yarn/cache/unist-util-visit-parents-npm-2.1.2-154aede9d7-1.zip/node_modules/unist-util-visit-parents/",
          "packageDependencies": [
            ["unist-util-visit-parents", "npm:2.1.2"],
            ["unist-util-is", "npm:3.0.0"]
          ],
          "linkType": "HARD"
        }],
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/unist-util-visit-parents-npm-3.0.0-b22d6d36b9-1.zip/node_modules/unist-util-visit-parents/",
          "packageDependencies": [
            ["unist-util-visit-parents", "npm:3.0.0"],
            ["@types/unist", "npm:2.0.3"],
            ["unist-util-is", "npm:4.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["universal-user-agent", [
        ["npm:3.0.0", {
          "packageLocation": "./.yarn/cache/universal-user-agent-npm-3.0.0-a192a2983a-1.zip/node_modules/universal-user-agent/",
          "packageDependencies": [
            ["universal-user-agent", "npm:3.0.0"],
            ["os-name", "npm:3.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["unset-value", [
        ["npm:1.0.0", {
          "packageLocation": "./.yarn/cache/unset-value-npm-1.0.0-2af803b920-1.zip/node_modules/unset-value/",
          "packageDependencies": [
            ["unset-value", "npm:1.0.0"],
            ["has-value", "npm:0.3.1"],
            ["isobject", "npm:3.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["urix", [
        ["npm:0.1.0", {
          "packageLocation": "./.yarn/cache/urix-npm-0.1.0-bd5e55a13a-1.zip/node_modules/urix/",
          "packageDependencies": [
            ["urix", "npm:0.1.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["url-template", [
        ["npm:2.0.8", {
          "packageLocation": "./.yarn/cache/url-template-npm-2.0.8-5d44a47d46-1.zip/node_modules/url-template/",
          "packageDependencies": [
            ["url-template", "npm:2.0.8"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["use", [
        ["npm:3.1.1", {
          "packageLocation": "./.yarn/cache/use-npm-3.1.1-7ba643714c-1.zip/node_modules/use/",
          "packageDependencies": [
            ["use", "npm:3.1.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["vfile", [
        ["npm:4.0.1", {
          "packageLocation": "./.yarn/cache/vfile-npm-4.0.1-badae93500-1.zip/node_modules/vfile/",
          "packageDependencies": [
            ["vfile", "npm:4.0.1"],
            ["@types/unist", "npm:2.0.3"],
            ["is-buffer", "npm:2.0.3"],
            ["replace-ext", "npm:1.0.0"],
            ["unist-util-stringify-position", "npm:2.0.1"],
            ["vfile-message", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["vfile-location", [
        ["npm:2.0.5", {
          "packageLocation": "./.yarn/cache/vfile-location-npm-2.0.5-918af6bbd8-1.zip/node_modules/vfile-location/",
          "packageDependencies": [
            ["vfile-location", "npm:2.0.5"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["vfile-message", [
        ["npm:2.0.1", {
          "packageLocation": "./.yarn/cache/vfile-message-npm-2.0.1-322e6f6462-1.zip/node_modules/vfile-message/",
          "packageDependencies": [
            ["vfile-message", "npm:2.0.1"],
            ["@types/unist", "npm:2.0.3"],
            ["unist-util-stringify-position", "npm:2.0.1"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["which", [
        ["npm:1.3.1", {
          "packageLocation": "./.yarn/cache/which-npm-1.3.1-f0ebb8bdd8-1.zip/node_modules/which/",
          "packageDependencies": [
            ["which", "npm:1.3.1"],
            ["isexe", "npm:2.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["windows-release", [
        ["npm:3.2.0", {
          "packageLocation": "./.yarn/cache/windows-release-npm-3.2.0-bb84765c45-1.zip/node_modules/windows-release/",
          "packageDependencies": [
            ["windows-release", "npm:3.2.0"],
            ["execa", "npm:1.0.0"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["wrappy", [
        ["npm:1.0.2", {
          "packageLocation": "./.yarn/cache/wrappy-npm-1.0.2-916de4d4b3-1.zip/node_modules/wrappy/",
          "packageDependencies": [
            ["wrappy", "npm:1.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["xtend", [
        ["npm:4.0.2", {
          "packageLocation": "./.yarn/cache/xtend-npm-4.0.2-7f2375736e-1.zip/node_modules/xtend/",
          "packageDependencies": [
            ["xtend", "npm:4.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]],
      ["yup", [
        ["npm:0.27.0", {
          "packageLocation": "./.yarn/cache/yup-npm-0.27.0-bbe02dd0fa-1.zip/node_modules/yup/",
          "packageDependencies": [
            ["yup", "npm:0.27.0"],
            ["@babel/runtime", "npm:7.5.5"],
            ["fn-name", "npm:2.0.1"],
            ["lodash", "npm:4.17.15"],
            ["property-expr", "npm:1.5.1"],
            ["synchronous-promise", "npm:2.0.9"],
            ["toposort", "npm:2.0.2"]
          ],
          "linkType": "HARD"
        }]
      ]]
    ]
  }, {basePath: basePath || __dirname});
  }

(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["pnpHook"] = factory();
	else
		root["pnpHook"] = factory();
})(global, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 31);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

var frozenFs = Object.assign({}, __webpack_require__(2));
var Module=typeof Module!=="undefined"?Module:{};var moduleOverrides={};var key;for(key in Module){if(Module.hasOwnProperty(key)){moduleOverrides[key]=Module[key]}}Module["arguments"]=[];Module["thisProgram"]="./this.program";Module["quit"]=function(status,toThrow){throw toThrow};Module["preRun"]=[];Module["postRun"]=[];var ENVIRONMENT_IS_WORKER=false;var ENVIRONMENT_IS_NODE=true;if(Module["ENVIRONMENT"]){throw new Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)")}var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}else{return scriptDirectory+path}}if(ENVIRONMENT_IS_NODE){if(!(typeof process==="object"&&"function"==="function"))throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");scriptDirectory=__dirname+"/";var nodeFS;var nodePath;Module["read"]=function shell_read(filename,binary){var ret;ret=tryParseAsDataURI(filename);if(!ret){if(!nodeFS)nodeFS=frozenFs;if(!nodePath)nodePath=__webpack_require__(3);filename=nodePath["normalize"](filename);ret=nodeFS["readFileSync"](filename)}return binary?ret:ret.toString()};Module["readBinary"]=function readBinary(filename){var ret=Module["read"](filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}assert(ret.buffer);return ret};if(process["argv"].length>1){Module["thisProgram"]=process["argv"][1].replace(/\\/g,"/")}Module["arguments"]=process["argv"].slice(2);if(true){module["exports"]=Module}(function(){})("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});(function(){})("unhandledRejection",abort);Module["quit"]=function(status){process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"}}else{throw new Error("environment detection error")}var out=Module["print"]||(typeof console!=="undefined"?console.log.bind(console):typeof print!=="undefined"?print:null);var err=Module["printErr"]||(typeof printErr!=="undefined"?printErr:typeof console!=="undefined"&&console.warn.bind(console)||out);for(key in moduleOverrides){if(moduleOverrides.hasOwnProperty(key)){Module[key]=moduleOverrides[key]}}moduleOverrides=undefined;assert(typeof Module["memoryInitializerPrefixURL"]==="undefined","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["pthreadMainPrefixURL"]==="undefined","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["cdInitializerPrefixURL"]==="undefined","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");assert(typeof Module["filePackagePrefixURL"]==="undefined","Module.filePackagePrefixURL option was removed, use Module.locateFile instead");stackSave=stackRestore=stackAlloc=function(){abort("cannot use the stack before compiled code is ready to run, and has provided stack access")};function dynamicAlloc(size){assert(DYNAMICTOP_PTR);var ret=HEAP32[DYNAMICTOP_PTR>>2];var end=ret+size+15&-16;if(end<=_emscripten_get_heap_size()){HEAP32[DYNAMICTOP_PTR>>2]=end}else{var success=_emscripten_resize_heap(end);if(!success)return 0}return ret}function getNativeTypeSize(type){switch(type){case"i1":case"i8":return 1;case"i16":return 2;case"i32":return 4;case"i64":return 8;case"float":return 4;case"double":return 8;default:{if(type[type.length-1]==="*"){return 4}else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0,"getNativeTypeSize invalid bits "+bits+", type "+type);return bits/8}else{return 0}}}}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}var asm2wasmImports={"f64-rem":function(x,y){return x%y},"debugger":function(){debugger}};var functionPointers=new Array(0);var tempRet0=0;var setTempRet0=function(value){tempRet0=value};if(typeof WebAssembly!=="object"){abort("No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.")}function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";if(noSafe){switch(type){case"i1":return HEAP8[ptr>>0];case"i8":return HEAP8[ptr>>0];case"i16":return HEAP16[ptr>>1];case"i32":return HEAP32[ptr>>2];case"i64":return HEAP32[ptr>>2];case"float":return HEAPF32[ptr>>2];case"double":return HEAPF64[ptr>>3];default:abort("invalid type for getValue: "+type)}}else{switch(type){case"i1":return SAFE_HEAP_LOAD(ptr|0,1,0)|0;case"i8":return SAFE_HEAP_LOAD(ptr|0,1,0)|0;case"i16":return SAFE_HEAP_LOAD(ptr|0,2,0)|0;case"i32":return SAFE_HEAP_LOAD(ptr|0,4,0)|0;case"i64":return SAFE_HEAP_LOAD(ptr|0,8,0)|0;case"float":return Math_fround(SAFE_HEAP_LOAD_D(ptr|0,4,0));case"double":return+SAFE_HEAP_LOAD_D(ptr|0,8,0);default:abort("invalid type for getValue: "+type)}}return null}function getSafeHeapType(bytes,isFloat){switch(bytes){case 1:return"i8";case 2:return"i16";case 4:return isFloat?"float":"i32";case 8:return"double";default:assert(0)}}function SAFE_HEAP_STORE(dest,value,bytes,isFloat){if(dest<=0)abort("segmentation fault storing "+bytes+" bytes to address "+dest);if(dest%bytes!==0)abort("alignment error storing to address "+dest+", which was expected to be aligned to a multiple of "+bytes);if(dest+bytes>HEAP32[DYNAMICTOP_PTR>>2])abort("segmentation fault, exceeded the top of the available dynamic heap when storing "+bytes+" bytes to address "+dest+". DYNAMICTOP="+HEAP32[DYNAMICTOP_PTR>>2]);assert(DYNAMICTOP_PTR);assert(HEAP32[DYNAMICTOP_PTR>>2]<=HEAP8.length);setValue(dest,value,getSafeHeapType(bytes,isFloat),1)}function SAFE_HEAP_STORE_D(dest,value,bytes){SAFE_HEAP_STORE(dest,value,bytes,true)}function SAFE_HEAP_LOAD(dest,bytes,unsigned,isFloat){if(dest<=0)abort("segmentation fault loading "+bytes+" bytes from address "+dest);if(dest%bytes!==0)abort("alignment error loading from address "+dest+", which was expected to be aligned to a multiple of "+bytes);if(dest+bytes>HEAP32[DYNAMICTOP_PTR>>2])abort("segmentation fault, exceeded the top of the available dynamic heap when loading "+bytes+" bytes from address "+dest+". DYNAMICTOP="+HEAP32[DYNAMICTOP_PTR>>2]);assert(DYNAMICTOP_PTR);assert(HEAP32[DYNAMICTOP_PTR>>2]<=HEAP8.length);var type=getSafeHeapType(bytes,isFloat);var ret=getValue(dest,type,1);if(unsigned)ret=unSign(ret,parseInt(type.substr(1)),1);return ret}function SAFE_HEAP_LOAD_D(dest,bytes,unsigned){return SAFE_HEAP_LOAD(dest,bytes,unsigned,true)}function segfault(){abort("segmentation fault")}function alignfault(){abort("alignment fault")}var wasmMemory;var wasmTable;var ABORT=false;var EXITSTATUS=0;function assert(condition,text){if(!condition){abort("Assertion failed: "+text)}}function getCFunc(ident){var func=Module["_"+ident];assert(func,"Cannot call unknown function "+ident+", make sure it is exported");return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string")return UTF8ToString(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;assert(returnType!=="array",'Return type should not be "array".');if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);ret=convertReturnValue(ret);if(stack!==0)stackRestore(stack);return ret}function cwrap(ident,returnType,argTypes,opts){return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";if(noSafe){switch(type){case"i1":HEAP8[ptr>>0]=value;break;case"i8":HEAP8[ptr>>0]=value;break;case"i16":HEAP16[ptr>>1]=value;break;case"i32":HEAP32[ptr>>2]=value;break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[ptr>>2]=tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case"float":HEAPF32[ptr>>2]=value;break;case"double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}else{switch(type){case"i1":SAFE_HEAP_STORE(ptr|0,value|0,1);break;case"i8":SAFE_HEAP_STORE(ptr|0,value|0,1);break;case"i16":SAFE_HEAP_STORE(ptr|0,value|0,2);break;case"i32":SAFE_HEAP_STORE(ptr|0,value|0,4);break;case"i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=1?tempDouble>0?(Math_min(+Math_floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],SAFE_HEAP_STORE(ptr|0,tempI64[0]|0,4),SAFE_HEAP_STORE(ptr+4|0,tempI64[1]|0,4);break;case"float":SAFE_HEAP_STORE_D(ptr|0,Math_fround(value),4);break;case"double":SAFE_HEAP_STORE_D(ptr|0,+value,8);break;default:abort("invalid type for setValue: "+type)}}}var ALLOC_NORMAL=0;var ALLOC_NONE=3;function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE){ret=ptr}else{ret=[_malloc,stackAlloc,dynamicAlloc][allocator](Math.max(size,singleType?1:types.length))}if(zeroinit){var stop;ptr=ret;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4){HEAP32[ptr>>2]=0}stop=ret+size;while(ptr<stop){HEAP8[ptr++>>0]=0}return ret}if(singleType==="i8"){if(slab.subarray||slab.slice){HEAPU8.set(slab,ret)}else{HEAPU8.set(new Uint8Array(slab),ret)}return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];type=singleType||types[i];if(type===0){i++;continue}assert(type,"Must know what type to store in allocate!");if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=getNativeTypeSize(type);previousType=type}i+=typeSize}return ret}function getMemory(size){if(!runtimeInitialized)return dynamicAlloc(size);return _malloc(size)}var UTF8Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(u8Array,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(u8Array[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&u8Array.subarray&&UTF8Decoder){return UTF8Decoder.decode(u8Array.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=u8Array[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=u8Array[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=u8Array[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{if((u0&248)!=240)warnOnce("Invalid UTF-8 leading byte 0x"+u0.toString(16)+" encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!");u0=(u0&7)<<18|u1<<12|u2<<6|u8Array[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,outU8Array,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;outU8Array[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;outU8Array[outIdx++]=192|u>>6;outU8Array[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;outU8Array[outIdx++]=224|u>>12;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;if(u>=2097152)warnOnce("Invalid Unicode code point 0x"+u.toString(16)+" encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).");outU8Array[outIdx++]=240|u>>18;outU8Array[outIdx++]=128|u>>12&63;outU8Array[outIdx++]=128|u>>6&63;outU8Array[outIdx++]=128|u&63}}outU8Array[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){assert(typeof maxBytesToWrite=="number","stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!=="undefined"?new TextDecoder("utf-16le"):undefined;function writeArrayToMemory(array,buffer){assert(array.length>=0,"writeArrayToMemory array must have a length (should be an array or typed array)");HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){assert(str.charCodeAt(i)===str.charCodeAt(i)&255);SAFE_HEAP_STORE(buffer++|0,str.charCodeAt(i)|0,1)}if(!dontAddNull)SAFE_HEAP_STORE(buffer|0,0|0,1)}function demangle(func){warnOnce("warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling");return func}function demangleAll(text){var regex=/__Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function jsStackTrace(){var err=new Error;if(!err.stack){try{throw new Error(0)}catch(e){err=e}if(!err.stack){return"(no stack trace available)"}}return err.stack.toString()}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}var WASM_PAGE_SIZE=65536;function alignUp(x,multiple){if(x%multiple>0){x+=multiple-x%multiple}return x}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferViews(){Module["HEAP8"]=HEAP8=new Int8Array(buffer);Module["HEAP16"]=HEAP16=new Int16Array(buffer);Module["HEAP32"]=HEAP32=new Int32Array(buffer);Module["HEAPU8"]=HEAPU8=new Uint8Array(buffer);Module["HEAPU16"]=HEAPU16=new Uint16Array(buffer);Module["HEAPU32"]=HEAPU32=new Uint32Array(buffer);Module["HEAPF32"]=HEAPF32=new Float32Array(buffer);Module["HEAPF64"]=HEAPF64=new Float64Array(buffer)}var STACK_BASE=22720,STACK_MAX=5265600,DYNAMIC_BASE=5265600,DYNAMICTOP_PTR=22464;assert(STACK_BASE%16===0,"stack must start aligned");assert(DYNAMIC_BASE%16===0,"heap must start aligned");var TOTAL_STACK=5242880;if(Module["TOTAL_STACK"])assert(TOTAL_STACK===Module["TOTAL_STACK"],"the stack size can no longer be determined at runtime");var INITIAL_TOTAL_MEMORY=Module["TOTAL_MEMORY"]||16777216;if(INITIAL_TOTAL_MEMORY<TOTAL_STACK)err("TOTAL_MEMORY should be larger than TOTAL_STACK, was "+INITIAL_TOTAL_MEMORY+"! (TOTAL_STACK="+TOTAL_STACK+")");assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&Int32Array.prototype.subarray!==undefined&&Int32Array.prototype.set!==undefined,"JS engine does not provide full typed array support");if(Module["buffer"]){buffer=Module["buffer"];assert(buffer.byteLength===INITIAL_TOTAL_MEMORY,"provided buffer should be "+INITIAL_TOTAL_MEMORY+" bytes, but it is "+buffer.byteLength)}else{if(typeof WebAssembly==="object"&&typeof WebAssembly.Memory==="function"){assert(INITIAL_TOTAL_MEMORY%WASM_PAGE_SIZE===0);wasmMemory=new WebAssembly.Memory({"initial":INITIAL_TOTAL_MEMORY/WASM_PAGE_SIZE});buffer=wasmMemory.buffer}else{buffer=new ArrayBuffer(INITIAL_TOTAL_MEMORY)}assert(buffer.byteLength===INITIAL_TOTAL_MEMORY)}updateGlobalBufferViews();HEAP32[DYNAMICTOP_PTR>>2]=DYNAMIC_BASE;function writeStackCookie(){assert((STACK_MAX&3)==0);HEAPU32[(STACK_MAX>>2)-1]=34821223;HEAPU32[(STACK_MAX>>2)-2]=2310721022}function checkStackCookie(){if(HEAPU32[(STACK_MAX>>2)-1]!=34821223||HEAPU32[(STACK_MAX>>2)-2]!=2310721022){abort("Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x"+HEAPU32[(STACK_MAX>>2)-2].toString(16)+" "+HEAPU32[(STACK_MAX>>2)-1].toString(16))}if(HEAP32[0]!==1668509029)throw"Runtime error: The application has corrupted its heap memory area (address zero)!"}function abortStackOverflow(allocSize){abort("Stack overflow! Attempted to allocate "+allocSize+" bytes on the stack, but stack has only "+(STACK_MAX-stackSave()+allocSize)+" bytes available!")}HEAP32[0]=1668509029;HEAP16[1]=25459;if(HEAPU8[2]!==115||HEAPU8[3]!==99)throw"Runtime error: expected the system to be little-endian!";function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number"){if(callback.arg===undefined){Module["dynCall_v"](func)}else{Module["dynCall_vi"](func,callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;var runtimeExited=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){checkStackCookie();if(runtimeInitialized)return;runtimeInitialized=true;if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();TTY.init();callRuntimeCallbacks(__ATINIT__)}function preMain(){checkStackCookie();FS.ignorePermissions=false;callRuntimeCallbacks(__ATMAIN__)}function postRun(){checkStackCookie();if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}function unSign(value,bits,ignore){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}assert(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");assert(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");var Math_abs=Math.abs;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;var runDependencyTracking={};function getUniqueRunDependency(id){var orig=id;while(1){if(!runDependencyTracking[id])return id;id=orig+Math.random()}return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(id){assert(!runDependencyTracking[id]);runDependencyTracking[id]=1;if(runDependencyWatcher===null&&typeof setInterval!=="undefined"){runDependencyWatcher=setInterval(function(){if(ABORT){clearInterval(runDependencyWatcher);runDependencyWatcher=null;return}var shown=false;for(var dep in runDependencyTracking){if(!shown){shown=true;err("still waiting on run dependencies:")}err("dependency: "+dep)}if(shown){err("(end of list)")}},1e4)}}else{err("warning: run dependency added without ID")}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(id){assert(runDependencyTracking[id]);delete runDependencyTracking[id]}else{err("warning: run dependency removed without ID")}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return String.prototype.startsWith?filename.startsWith(dataURIPrefix):filename.indexOf(dataURIPrefix)===0}var wasmBinaryFile="data:application/octet-stream;base64,AGFzbQEAAAABvwIuYAV/f39/fwF/YAJ/fwF/YAN/fH8AYAF/AGAEf39+fwF+YAV/f39+fwF+YAN/f38Bf2ABfwF/YAN/f34Bf2ACf38AYAAAYAABf2ADf39/AGACf34Bf2ADf39/AX5gAn5/AX9gA39+fwF/YAN/f34BfmAFf39/f38BfmAEf35/fwF/YAR/f39/AX9gBH9/f38BfmAFf35/f38Bf2ADf35/AX5gAn9/AX5gBX9/fn9/AX9gA39+fwBgAX4Bf2AEf39+fwF/YAJ/fABgAn9+AX5gBH9/f34BfmAFf39/fn8AYAV+fn9+fwF+YAF/AX5gB39+f39/fn8Bf2ACf34AYAZ/f39/f38Bf2AEf39/fwBgA35/fwF/YAV/f39/fwBgBn98f39/fwF/YAJ8fwF8YAJ/fwF8YAN/f34AYAN/f3wAAvwCLANlbnYBYgADA2VudgFjAAoDZW52AWQACgNlbnYBZQADA2VudgFmAAEDZW52AWcAAwNlbnYBaAABA2VudgFpAAMDZW52AWoABwNlbnYBawABA2VudgFsAAEDZW52AW0AAQNlbnYBbgABA2VudgFvAAMDZW52AXAAAwNlbnYBcQADA2VudgFyAAMDZW52AXMAAwNlbnYBdAADA2VudgF1AAMDZW52AXYABwNlbnYBdwAHA2VudgF4AAcDZW52AXkABwNlbnYBegAGA2VudgFBAAsDZW52AUIAAQNlbnYBQwADA2VudgFEAAEDZW52AUUAAQNlbnYBRgABA2VudgFHAAEDZW52AUgAAQNlbnYBSQABA2VudgFKAAEDZW52AUsAAQNlbnYBTAADA2VudgFNAAMDZW52AU4AAwNlbnYBTwADA2VudgxfX3RhYmxlX2Jhc2UDfwADZW52AWEDfwADZW52Bm1lbW9yeQIAgAIDZW52BXRhYmxlAXABNzcD9wL1AgEMGAwsAQwBAQEDDAcDBgYDLAMBBw0JDAkoGCYEBgcNBwMQBiQRLAMiAwgDAywYByIYAQcrAQYDAQEGAQMtEw8MEwcHAQEHCRQTBhQsDAUHBwMHBiYDFCIHHQ4GFQ4AHAcTFwADAwEDBwcBAAwMCSUHBhMDEwMgFBwGCQAGGRATExUGAQcAAQYDEgQHBwEMBioBBgwHBgYJDAwMEAMDAw8BAQcQCQcGAQEHCRkNIRQHBgYGAwAeEBwTAxMZARwBDQYBBwYbCxoVAwcYCxEHBhAXFhUHDQcHBwkMCQkMAQEBAQAAAAYBFAEUFAAlJRQGCQIIAAkLCwsKBwMBBgcJAQYDCwcDAwEJAQEGAQEJAQMGBwEpDycMDAcGBgsGBwYJBhEBDCYmBwcDAwkHBgcHBwcHAQEBAwEBDgMHAQYNCAsHBAEHJAgNBg0GAwgHBwcDBiIGARQBFBEJAQUjBwcLAQUABwsFHwUUBwcEERAEBwYNBxMDBwcGFQN/ASMBC38BQcCxAQt/AUHAscECCwePAjABUACfAgFRAMICAVIAnQIBUwCcAgFUAJ4CAVUAkQEBVgAyAVcAeAFYADQBWQBXAVoAgwMBXwCWAgEkAI0BAmFhAIACAmJhAP0BAmNhAPsBAmRhAJUCAmVhAP4BAmZhAJQCAmdhAJMCAmhhAJICAmlhAPYBAmphAJECAmthAJACAmxhAP8BAm1hAI4CAm5hAI0CAm9hAIwCAnBhAOsBAnFhAKEBAnJhAIsCAnNhAIoCAnRhADoCdWEA/QICdmEAiQICd2EAigMCeGEAhQMCeWEA8wECemEA7QECQWEAmwMCQmEAkAMCQ2EA6gECRGEAlQMCRWEAmwICRmEAgwICR2EAnAMCSGEAqwICSWEA5gIJZAEAIwALN3f1AvQC8wLEAnd3d44ByQHeAt0CsAJsjgGOAV73AvAC7gLAAsMCtwLHAr4BwQJeXl5eXl6aAogDmQLyAnaNA4sDhwOBA3Z2drIBlAPoArIBsAH2AvECsAGYApcCxgIKpdIG9QIwAQF/IAAgAWohAiACQQBGIAJBBGojASgCAEtyBEAQAQsgAkEDcQRAEAILIAIoAgALMgEBfyAAIAFqIQMgA0EARiADQQRqIwEoAgBLcgRAEAELIANBA3EEQBACCyADIAI2AgALMAEBfyAAIAFqIQIgAkEARiACQQhqIwEoAgBLcgRAEAELIAJBB3EEQBACCyACKQMACygBAX8gACABaiEDIANBAEYgA0EBaiMBKAIAS3IEQBABCyADIAI6AAALMgEBfyAAIAFqIQMgA0EARiADQQhqIwEoAgBLcgRAEAELIANBB3EEQBACCyADIAI3AwALJgEBfyAAIAFqIQIgAkEARiACQQFqIwEoAgBLcgRAEAELIAIsAAALMgEBfyAAIAFqIQMgA0EARiADQQJqIwEoAgBLcgRAEAELIANBAXEEQBACCyADIAI7AQALJgEBfyAAIAFqIQIgAkEARiACQQFqIwEoAgBLcgRAEAELIAItAAALMAEBfyAAIAFqIQIgAkEARiACQQJqIwEoAgBLcgRAEAELIAJBAXEEQBACCyACLwEACzABAX8gACABaiECIAJBAEYgAkECaiMBKAIAS3IEQBABCyACQQFxBEAQAgsgAi4BAAvGDgEJfyAARQRADwtB9KIBQQAQKCEEIABBeGoiAyAAQXxqQQAQKCICQXhxIgBqIQUgAkEBcQR/IAMFAn8gA0EAECghASACQQNxRQRADwsgAyABayIDIARJBEAPCyAAIAFqIQAgA0H4ogFBABAoRgRAIAMgBUEEECgiAUEDcUEDRw0BGkHsogFBACAAECkgBUEEIAFBfnEQKSADQQQgAEEBchApIAAgA2pBACAAECkPCyABQQN2IQQgAUGAAkkEQCADQQgQKCIBIANBDBAoIgJGBEBB5KIBQQBB5KIBQQAQKEEBIAR0QX9zcRApBSABQQwgAhApIAJBCCABECkLIAMMAQsgA0EYECghByADIANBDBAoIgFGBEACQCADQRBqIgJBBGoiBEEAECgiAQRAIAQhAgUgAkEAECgiAUUEQEEAIQEMAgsLA0ACQCABQRRqIgRBABAoIgZFBEAgAUEQaiIEQQAQKCIGRQ0BCyAEIQIgBiEBDAELCyACQQBBABApCwUgA0EIECgiAkEMIAEQKSABQQggAhApCyAHBH8gAyADQRwQKCICQQJ0QZSlAWoiBEEAEChGBEAgBEEAIAEQKSABRQRAQeiiAUEAQeiiAUEAEChBASACdEF/c3EQKSADDAMLBSAHQRBqIgIgB0EUaiADIAJBABAoRhtBACABECkgAyABRQ0CGgsgAUEYIAcQKSADQRAQKCICBEAgAUEQIAIQKSACQRggARApCyADQRQQKCICBEAgAUEUIAIQKSACQRggARApCyADBSADCwsLIgcgBU8EQA8LIAVBBBAoIghBAXFFBEAPCyAIQQJxBEAgBUEEIAhBfnEQKSADQQQgAEEBchApIAAgB2pBACAAECkgACECBSAFQfyiAUEAEChGBEBB8KIBQQAgAEHwogFBABAoaiIAEClB/KIBQQAgAxApIANBBCAAQQFyEClB+KIBQQAQKCADRwRADwtB+KIBQQBBABApQeyiAUEAQQAQKQ8LQfiiAUEAECggBUYEQEHsogFBACAAQeyiAUEAEChqIgAQKUH4ogFBACAHECkgA0EEIABBAXIQKSAAIAdqQQAgABApDwsgCEEDdiEEIAhBgAJJBEAgBUEIECgiASAFQQwQKCICRgRAQeSiAUEAQeSiAUEAEChBASAEdEF/c3EQKQUgAUEMIAIQKSACQQggARApCwUCQCAFQRgQKCEJIAVBDBAoIgEgBUYEQAJAIAVBEGoiAkEEaiIEQQAQKCIBBEAgBCECBSACQQAQKCIBRQRAQQAhAQwCCwsDQAJAIAFBFGoiBEEAECgiBkUEQCABQRBqIgRBABAoIgZFDQELIAQhAiAGIQEMAQsLIAJBAEEAECkLBSAFQQgQKCICQQwgARApIAFBCCACECkLIAkEQCAFQRwQKCICQQJ0QZSlAWoiBEEAECggBUYEQCAEQQAgARApIAFFBEBB6KIBQQBB6KIBQQAQKEEBIAJ0QX9zcRApDAMLBSAJQRBqIgIgCUEUaiACQQAQKCAFRhtBACABECkgAUUNAgsgAUEYIAkQKSAFQRAQKCICBEAgAUEQIAIQKSACQRggARApCyAFQRQQKCICBEAgAUEUIAIQKSACQRggARApCwsLCyADQQQgACAIQXhxaiICQQFyECkgAiAHakEAIAIQKSADQfiiAUEAEChGBEBB7KIBQQAgAhApDwsLIAJBA3YhASACQYACSQRAIAFBA3RBjKMBaiEAQeSiAUEAECgiAkEBIAF0IgFxBH8gAEEIaiICQQAQKAVB5KIBQQAgASACchApIABBCGohAiAACyEBIAJBACADECkgAUEMIAMQKSADQQggARApIANBDCAAECkPCyACQQh2IgAEfyACQf///wdLBH9BHwUgACAAQYD+P2pBEHZBCHEiAXQiBEGA4B9qQRB2QQRxIQBBDiAAIAFyIAQgAHQiAEGAgA9qQRB2QQJxIgFyayAAIAF0QQ92aiIAQQF0IAIgAEEHanZBAXFyCwVBAAsiAUECdEGUpQFqIQAgA0EcIAEQKSADQRRBABApIANBEEEAEClB6KIBQQAQKCIEQQEgAXQiBnEEQAJAIAIgAEEAECgiAEEEEChBeHFGBEAgACEBBQJAIAJBAEEZIAFBAXZrIAFBH0YbdCEEA0AgAEEQaiAEQR92QQJ0aiIGQQAQKCIBBEAgBEEBdCEEIAIgAUEEEChBeHFGDQIgASEADAELCyAGQQAgAxApIANBGCAAECkgA0EMIAMQKSADQQggAxApDAILCyABQQgQKCIAQQwgAxApIAFBCCADECkgA0EIIAAQKSADQQwgARApIANBGEEAECkLBUHoogFBACAEIAZyECkgAEEAIAMQKSADQRggABApIANBDCADECkgA0EIIAMQKQtBhKMBQQBBhKMBQQAQKEF/aiIAECkgAARADwtBrKYBIQADQCAAQQAQKCIDQQhqIQAgAw0AC0GEowFBAEF/ECkLWwAgAEEATARAEAELIAAgAmojAkEAEChKBEAQAQsgAkEERgRAIABBA3EEQBACCyAAQQAgARApBSACQQFGBEAgAEEAIAEQKwUgAEEBcQRAEAILIABBACABEC4LCwuLOQENfyMDIQojA0EQaiQDIwMjBE4EQEEQEAALIABB9QFJBEBB5KIBQQAQKCIFQRAgAEELakF4cSAAQQtJGyICQQN2IgB2IgFBA3EEQCABQQFxQQFzIABqIgJBA3RBjKMBaiIAQQgQKCIDQQhqIgRBABAoIQEgACABRgRAQeSiAUEAQQEgAnRBf3MgBXEQKQUgAUEMIAAQKSAAQQggARApCyADQQQgAkEDdCIAQQNyECkgACADaiIAQQQgAEEEEChBAXIQKSAKJAMgBA8LIAJB7KIBQQAQKCIHSwR/IAEEQCABIAB0QQIgAHQiAEEAIABrcnEiAEEAIABrcUF/aiIAQQx2QRBxIgEgACABdiIAQQV2QQhxIgFyIAAgAXYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqIgRBA3RBjKMBaiIAQQgQKCIBQQhqIgZBABAoIQMgACADRgRAQeSiAUEAQQEgBHRBf3MgBXEiABApBSADQQwgABApIABBCCADECkgBSEACyABQQQgAkEDchApIAEgAmoiCEEEIARBA3QiAyACayIFQQFyECkgASADakEAIAUQKSAHBEBB+KIBQQAQKCEDIAdBA3YiAkEDdEGMowFqIQFBASACdCICIABxBH8gAUEIaiICQQAQKAVB5KIBQQAgACACchApIAFBCGohAiABCyEAIAJBACADECkgAEEMIAMQKSADQQggABApIANBDCABECkLQeyiAUEAIAUQKUH4ogFBACAIECkgCiQDIAYPC0HoogFBABAoIgsEf0EAIAtrIAtxQX9qIgBBDHZBEHEiASAAIAF2IgBBBXZBCHEiAXIgACABdiIAQQJ2QQRxIgFyIAAgAXYiAEEBdkECcSIBciAAIAF2IgBBAXZBAXEiAXIgACABdmpBAnRBlKUBakEAECgiAyEAIANBBBAoQXhxIAJrIQgDQAJAIABBEBAoIgEEQCABIQAFIABBFBAoIgBFDQELIAAgAyAAQQQQKEF4cSACayIBIAhJIgQbIQMgASAIIAQbIQgMAQsLIAIgA2oiDCADSwR/IANBGBAoIQkgAyADQQwQKCIARgRAAkAgA0EUaiIBQQAQKCIARQRAIANBEGoiAUEAECgiAEUEQEEAIQAMAgsLA0ACQCAAQRRqIgRBABAoIgZFBEAgAEEQaiIEQQAQKCIGRQ0BCyAEIQEgBiEADAELCyABQQBBABApCwUgA0EIECgiAUEMIAAQKSAAQQggARApCyAJBEACQCADIANBHBAoIgFBAnRBlKUBaiIEQQAQKEYEQCAEQQAgABApIABFBEBB6KIBQQBBASABdEF/cyALcRApDAILBSAJQRBqIgEgCUEUaiADIAFBABAoRhtBACAAECkgAEUNAQsgAEEYIAkQKSADQRAQKCIBBEAgAEEQIAEQKSABQRggABApCyADQRQQKCIBBEAgAEEUIAEQKSABQRggABApCwsLIAhBEEkEQCADQQQgAiAIaiIAQQNyECkgACADaiIAQQQgAEEEEChBAXIQKQUgA0EEIAJBA3IQKSAMQQQgCEEBchApIAggDGpBACAIECkgBwRAQfiiAUEAECghBCAHQQN2IgFBA3RBjKMBaiEAQQEgAXQiASAFcQR/IABBCGoiAkEAECgFQeSiAUEAIAEgBXIQKSAAQQhqIQIgAAshASACQQAgBBApIAFBDCAEECkgBEEIIAEQKSAEQQwgABApC0HsogFBACAIEClB+KIBQQAgDBApCyAKJAMgA0EIag8FIAILBSACCwUgAgshAAUgAEG/f0sEQEF/IQAFAkAgAEELaiIBQXhxIQBB6KIBQQAQKCIFBEAgAUEIdiIBBH8gAEH///8HSwR/QR8FIAEgAUGA/j9qQRB2QQhxIgJ0IgNBgOAfakEQdkEEcSEBQQ4gASACciADIAF0IgFBgIAPakEQdkECcSICcmsgASACdEEPdmoiAUEBdCAAIAFBB2p2QQFxcgsFQQALIQdBACAAayEDAkACQCAHQQJ0QZSlAWpBABAoIgEEf0EAIQIgAEEAQRkgB0EBdmsgB0EfRht0IQYDfyABQQQQKEF4cSAAayIIIANJBEAgCAR/IAghAyABBUEAIQMgASECDAQLIQILIAQgAUEUECgiBCAERSAEIAFBEGogBkEfdkECdGpBABAoIgFGchshBCAGQQF0IQYgAQ0AIAILBUEACyEBIAEgBHIEfyAEBSAFQQIgB3QiAUEAIAFrcnEiAkUNBEEAIQEgAkEAIAJrcUF/aiICQQx2QRBxIgQgAiAEdiICQQV2QQhxIgRyIAIgBHYiAkECdkEEcSIEciACIAR2IgJBAXZBAnEiBHIgAiAEdiICQQF2QQFxIgRyIAIgBHZqQQJ0QZSlAWpBABAoCyICDQAgASEEDAELIAEhBCADIQEDfwJ/IAJBBBAoIQ0gAkEQECgiA0UEQCACQRQQKCEDCyANC0F4cSAAayIIIAFJIQYgCCABIAYbIQEgAiAEIAYbIQQgAwR/IAMhAgwBBSABCwshAwsgBARAIANB7KIBQQAQKCAAa0kEQCAAIARqIgcgBEsEQCAEQRgQKCEJIAQgBEEMECgiAUYEQAJAIARBFGoiAkEAECgiAUUEQCAEQRBqIgJBABAoIgFFBEBBACEBDAILCwNAAkAgAUEUaiIGQQAQKCIIRQRAIAFBEGoiBkEAECgiCEUNAQsgBiECIAghAQwBCwsgAkEAQQAQKQsFIARBCBAoIgJBDCABECkgAUEIIAIQKQsgCQRAAkAgBCAEQRwQKCICQQJ0QZSlAWoiBkEAEChGBEAgBkEAIAEQKSABRQRAQeiiAUEAIAVBASACdEF/c3EiARApDAILBSAJQRBqIgIgCUEUaiAEIAJBABAoRhtBACABECkgAUUEQCAFIQEMAgsLIAFBGCAJECkgBEEQECgiAgRAIAFBECACECkgAkEYIAEQKQsgBEEUECgiAgRAIAFBFCACECkgAkEYIAEQKQsgBSEBCwUgBSEBCyADQRBJBEAgBEEEIAAgA2oiAEEDchApIAAgBGoiAEEEIABBBBAoQQFyECkFAkAgBEEEIABBA3IQKSAHQQQgA0EBchApIAMgB2pBACADECkgA0EDdiECIANBgAJJBEAgAkEDdEGMowFqIQBB5KIBQQAQKCIBQQEgAnQiAnEEfyAAQQhqIgJBABAoBUHkogFBACABIAJyECkgAEEIaiECIAALIQEgAkEAIAcQKSABQQwgBxApIAdBCCABECkgB0EMIAAQKQwBCyADQQh2IgAEfyADQf///wdLBH9BHwUgACAAQYD+P2pBEHZBCHEiAnQiBUGA4B9qQRB2QQRxIQBBDiAAIAJyIAUgAHQiAEGAgA9qQRB2QQJxIgJyayAAIAJ0QQ92aiIAQQF0IAMgAEEHanZBAXFyCwVBAAsiAkECdEGUpQFqIQAgB0EcIAIQKSAHQRRBABApIAdBEEEAEClBASACdCIFIAFxRQRAQeiiAUEAIAEgBXIQKSAAQQAgBxApIAdBGCAAECkgB0EMIAcQKSAHQQggBxApDAELIAMgAEEAECgiAEEEEChBeHFGBEAgACEBBQJAIANBAEEZIAJBAXZrIAJBH0YbdCECA0AgAEEQaiACQR92QQJ0aiIFQQAQKCIBBEAgAkEBdCECIAMgAUEEEChBeHFGDQIgASEADAELCyAFQQAgBxApIAdBGCAAECkgB0EMIAcQKSAHQQggBxApDAILCyABQQgQKCIAQQwgBxApIAFBCCAHECkgB0EIIAAQKSAHQQwgARApIAdBGEEAECkLCyAKJAMgBEEIag8LCwsLCwsLAkBB7KIBQQAQKCICIABPBEBB+KIBQQAQKCEBIAIgAGsiA0EPSwRAQfiiAUEAIAAgAWoiBRApQeyiAUEAIAMQKSAFQQQgA0EBchApIAEgAmpBACADECkgAUEEIABBA3IQKQVB7KIBQQBBABApQfiiAUEAQQAQKSABQQQgAkEDchApIAEgAmoiAEEEIABBBBAoQQFyECkLDAELAkBB8KIBQQAQKCICIABLBEBB8KIBQQAgAiAAayICECkMAQsgAEEvaiIEQbymAUEAECgEf0HEpgFBABAoBUHEpgFBAEGAIBApQcCmAUEAQYAgEClByKYBQQBBfxApQcymAUEAQX8QKUHQpgFBAEEAEClBoKYBQQBBABApQbymAUEAIApBcHFB2KrVqgVzEClBgCALIgFqIgZBACABayIIcSIFIABNBEAgCiQDQQAPC0GcpgFBABAoIgEEQCAFQZSmAUEAECgiA2oiByADTSAHIAFLcgRAIAokA0EADwsLIABBMGohBwJAAkBBoKYBQQAQKEEEcQRAQQAhAgUCQAJAAkBB/KIBQQAQKCIDRQ0AQaSmASEBA0ACQCABQQAQKCIJIANNBEAgCSABQQQQKGogA0sNAQsgAUEIECgiAQ0BDAILCyAIIAYgAmtxIgJB/////wdJBEAgAhBXIgMgAUEAECggAUEEEChqRgRAIANBf0cEQCADIQEMBwsFDAMLBUEAIQILDAILQQAQVyIBQX9GBH9BAAVBlKYBQQAQKCIGIAUgAUHApgFBABAoIgJBf2oiA2pBACACa3EgAWtBACABIANxG2oiAmohAyACQf////8HSSACIABLcQR/QZymAUEAECgiCARAIAMgBk0gAyAIS3IEQEEAIQIMBQsLIAEgAhBXIgNGDQUMAgVBAAsLIQIMAQsgAyEBIAFBf0cgAkH/////B0lxIAcgAktxRQRAIAFBf0YEQEEAIQIMAgUMBAsAC0HEpgFBABAoIgMgBCACa2pBACADa3EiA0H/////B08NAkEAIAJrIQQgAxBXQX9GBH8gBBBXGkEABSACIANqIQIMAwshAgtBoKYBQQBBoKYBQQAQKEEEchApCyAFQf////8HSQRAIAUQVyEBQQAQVyIDIAFrIgQgAEEoakshBSAEIAIgBRshAiAFQQFzIAFBf0ZyIAFBf0cgA0F/R3EgASADSXFBAXNyRQ0BCwwBC0GUpgFBACACQZSmAUEAEChqIgMQKSADQZimAUEAEChLBEBBmKYBQQAgAxApC0H8ogFBABAoIgUEQAJAQaSmASEDAkACQANAIAEgA0EAECgiBCADQQQQKCIGakYNASADQQgQKCIDDQALDAELIANBDBAoQQhxRQRAIAQgBU0gASAFS3EEQCADQQQgAiAGahApIAVBACAFQQhqIgFrQQdxQQAgAUEHcRsiA2ohASACQfCiAUEAEChqIgQgA2shAkH8ogFBACABEClB8KIBQQAgAhApIAFBBCACQQFyECkgBCAFakEEQSgQKUGAowFBAEHMpgFBABAoECkMAwsLCyABQfSiAUEAEChJBEBB9KIBQQAgARApCyABIAJqIQRBpKYBIQMCQAJAA0AgBCADQQAQKEYNASADQQgQKCIDDQALDAELIANBDBAoQQhxRQRAIANBACABECkgA0EEIAIgA0EEEChqECkgACABQQAgAUEIaiIBa0EHcUEAIAFB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AEEUECkgAEEEQQAQKQsgBRA1CyAEEFMLIAgkA0F/C5sDAQh/IABBuC1qIghBABAwIANB//8DcSIKIABBvC1qIglBABAoIgN0ciEHIAhBACAHEC4gA0ENSgRAAn8gAEEIaiIDQQAQKCELIABBFGoiBEEAECghBiAEQQAgBkEBahApIAsLIAZqQQAgBxArIAhBABAwQQh2IQcgA0EAECghBiAEQQAgBEEAECgiBUEBahApIAUgBmpBACAHECsgCEEAIApBECAJQQAQKCIFa3YQLiAJQQAgBUFzahApBSAJQQAgA0EDahApIABBFGohBCAAQQhqIQMLIAAQxQEgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACACECsgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACACQQh2IgYQKyADQQAQKCEFIARBACAEQQAQKCIAQQFqECkgACAFakEAIAJB/wFzECsgA0EAECghBSAEQQAgBEEAECgiAEEBahApIAAgBWpBACAGQf8BcxArIANBABAoIARBABAoaiABIAIQNhogBEEAIAIgBEEAEChqECkLogUBCH8gAEG0LWohBSAAQUBrIQYgAEH0ABAoIQEgAEEsECgiBCECA0ACQCAAQTwQKCABayAAQewAECgiA2shASADIAQgAkH6fWpqTwRAIABBOBAoIgIgAiAEaiAEIAFrEDYaIABB8AAgAEHwABAoIARrECkgAEHsACAAQewAECggBGsQKSAAQdwAIABB3AAQKCAEaxApIAAQ3AIgASAEaiEBCyAAQQAQKCICQQQQKEUNACAAQfQAIAIgAEH0ABAoIABBOBAoIABB7AAQKGpqIAEQmQEgAEH0ABAoaiIBECkgASAFQQAQKCICakECSwRAAkAgAEHIACAAQewAECggAmsiAyAAQTgQKCIHakEAEC8iCBApIABByAAgAEHUABAoIAcgA0EBampBABAvIAggAEHYABAodHNxECkDQCACRQ0BIABByAAgAEHUABAoIABBOBAoIANBAmpqQQAQLyAAQcgAECggAEHYABAodHNxIgEQKSAGQQAQKCADIABBNBAocUEBdGpBACAAQcQAECggAUEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACADEC4gBUEAIAVBABAoQX9qIgIQKSACIABB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IAAgASACIABBCGoQhAEL1wECAX8BfiADIAJBAEdyRQRAQQAPCyACIANBAXFqEDQiBUUEQCAEBEAgBEEAQQ4QKSAEQQRBABApC0EADwsgAq0hBiAABEACQCAAIAYQPSIABEAgBSAAIAIQNhoMAQsgBARAIARBAEEOECkgBEEEQQAQKQsgBRAyQQAPCwUgASAFIAYgBBCHAUEASARAIAUQMkEADwsLIANFBEAgBQ8LIAIgBWoiAUEAQQAQKyAFIQADQCAAIAFJBEAgAEEAEC1FBEAgAEEAQSAQKwsgAEEBaiEADAELCyAFC3oBAX4gAkIAUwR/IAMEQCADQQBBFBApIANBBEEAECkLQX8FAn8gACABIAIQTSIEQgBTBEAgAwRAIANBACAAQQwQKBApIANBBCAAQRAQKBApC0F/DAELIAQgAlMEfyADBEAgA0EAQREQKSADQQRBABApC0F/BUEACwsLC0QCAX8BfiAARQRAQQAPC0KFKiECA0AgAEEAEC0iAQRAIABBAWohACABQf8Bca0gAkIhfnxC/////w+DIQIMAQsLIAKnCyIAIAAgASACIAMQZiIABH8gAEEwEChBACACIAMQcAVBAAsLuAEBAn8gAEFAa0EAECggAadBBHRqQQAQKCIDRQRAIAIEQCACQQBBFBApIAJBBEEAECkLQgAPCwJ/IABBABAoIANByAAQKiIBQQAQSkEASCEEIABBABAoIQAgBAsEQCACBEAgAkEAIABBDBAoECkgAkEEIABBEBAoECkLQgAPCyAAIAIQhQIiAEEASARAQgAPCyABIACtfCIBQgBZBEAgAQ8LIAIEQCACQQBBBBApIAJBBEEbECkLQgALfQACQAJAA0ACQCAARQ0CIABBCBAwIAJB//8DcUYEQCADIABBBBAocUGABnENAQsgAEEAECghAAwBCwsMAQsgBARAIARBAEEJECkgBEEEQQAQKQtBAA8LIAEEQCABQQAgAEEKEDEQLgsgAEEKEDFFBEBBvacBDwsgAEEMECgLFwAgABCbASAAQQAQKBBfIABBBBAoEF8L/wECAX8BfiAARQRADwsgAEEAECgiAQRAIAEQWxogAEEAECgQOgsgAEEcECgQMiAAQSAQKBBJIABBJBAoEEkgAEHQABAoEPABIABBQGsiAUEAECgEQANAIAIgAEEwECpUBEAgAUEAECgg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IAcQKQueBgEMfyABQQAQKCEEIAFBCBAoIgJBABAoIQUgAkEMECghCCAAQdAoaiIGQQBBABApIABB1ChqIglBAEG9BBApQX8hAgNAIAMgCEgEQCADQQJ0IARqQQAQMQRAIAZBACAGQQAQKEEBaiICECkgAEHcFmogAkECdGpBACADECkgAyAAQdgoampBAEEAECsgAyECBSADQQJ0IARqQQJBABAuCyADQQFqIQMMAQsLIABBqC1qIQMgBUUhCyAAQawtaiEHIAIhCgNAIAZBABAoIgJBAkgEQCAGQQAgAkEBaiICECkgAEHcFmogAkECdGpBACAKQQFqIgxBACAKQQJIIg0bIgIQKSACQQJ0IARqQQBBARAuIAIgAEHYKGpqQQBBABArIANBACADQQAQKEF/ahApIAtFBEAgB0EAIAdBABAoIAJBAnQgBWpBAhAwaxApCyAMIAogDRshCgwBCwsgAUEEIAoQKSAGQQAQKEECbSECA0AgAkEASgRAIAAgBCACEJUBIAJBf2ohAgwBCwsgAEHgFmohBSAIIQIgBkEAECghAwNAIAVBABAoIQggBkEAIANBf2oQKSAFQQAgAEHcFmogA0ECdGpBABAoECkgACAEQQEQlQEgBUEAECghAyAJQQAgCUEAEChBf2oiBxApIABB3BZqIAdBAnRqQQAgCBApIAlBACAJQQAQKEF/aiIHECkgAEHcFmogB0ECdGpBACADECkgAkECdCAEakEAIAhBAnQgBGpBABAwIANBAnQgBGpBABAwahAuIAIgAEHYKGpqQQAgAyAAQdgoampBABAtIgcgCCAAQdgoampBABAtIgsgC0H/AXEgB0H/AXFIG0H/AXFBAWoQKyADQQJ0IARqQQIgAkH//wNxIgMQLiAIQQJ0IARqQQIgAxAuIAVBACACECkgACAEQQEQlQEgAkEBaiECIAZBABAoIgNBAUoNAAsgBUEAECghAiAJQQAgCUEAEChBf2oiAxApIABB3BZqIANBAnRqQQAgAhApIAAgAUEAECggAUEEECggAUEIECgQywIgBCAKIABBvBZqEMoCC44LARZ/IwMhBiMDQUBrJAMjAyMETgRAQcAAEAALIAZBIGohECAGIQ5BACEGA0AgBkEQRwRAIAZBAXQgEGpBAEEAEC4gBkEBaiEGDAELC0EAIQYDQCACIAZHBEAgBkEB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BSEDDAIFQQAhAwwDCwALCyACQSQQKCEEIAIgACADIARBD3FBEGoRBgAiBCADSQ0CIAAgA2ohACABIANrIQEgAkEUECghBAsLIAQgACABEDYaIAJBFCABIAJBFBAoahApIAEgA2ohBAsgBAuUAQIBfwJ+AkACQCAAvSIDQjSIIgSnQf8PcSICBEAgAkH/D0YEQAwDBQwCCwALIAFBACAARAAAAAAAAAAAYgR/IABEAAAAAAAA8EOiIAEQuAEhACABQQAQKEFAagVBAAsQKQwBCyABQQAgBKdB/w9xQYJ4ahApIANC/////////4eAf4NCgICAgICAgPA/hL8hAAsgAAsRACAABH8gACABELkCBUEACwuEAgEDfyABQf8BcSEEAkACQCACQQBHIgMgAEEDcUEAR3FFDQAgAUH/AXEhBQJAA0AgBSAAQQAQL0YNASACQX9qIgJBAEciAyAAQQFqIgBBA3FBAEdxDQALDAELDAELIAMEQAJAIAFB/wFxIgEgAEEAEC9GBEAgAkUNAQwDCyAEQYGChAhsIQMCQAJAIAJBA00NAANAIAMgAEEAEChzIgRB//37d2ogBEGAgYKEeHFBgIGChHhzcUUEQAEgAEEEaiEAIAJBfGoiAkEDSw0BDAILCwwBCyACRQ0BCwNAIABBABAvIAFB/wFxRg0DIABBAWohACACQX9qIgINAAsLC0EAIQALIAAL/wMDAX8BfgF8IAFBFE0EQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4KAAECAwQFBgcICQoLIAJBABAoQQNqQXxxIgFBABAoIQMgAkEAIAFBBGoQKSAAQQAgAxApDAkLIAJBABAoQQNqQXxxIgFBABAoIQMgAkEAIAFBBGoQKSAAQQAgA6wQLAwICyACQQAQKEEDakF8cSIBQQAQKCEDIAJBACABQQRqECkgAEEAIAOtECwMBwsgAkEAEChBB2pBeHEiAUEAECohBCACQQAgAUEIahApIABBACAEECwMBgsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABBACADQf//A3FBEHRBEHWsECwMBQsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABBACADQf//A3GtECwMBAsgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIABB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akEAIAJB/wFzECsgAEEAECgQOCAGBEAgAEEAEChBDBAoIABBOBAoIABB3AAQKGogAyAGIAYgA0sbIgIQNhogAEEAECgiBkEMIAZBDBAoIAJqECkgAEEAECgiBkEQIAZBEBAoIAJrECkgAEEAECgiBkEUIAZBFBAoIAJqECkgAEHcACAAQdwAECggAmoQKSADIAJrIQMLIAMEQCAAQQAQKCICIAJBDBAoIAMQmQEaIABBABAoIgJBDCADIAJBDBAoahApIABBABAoIgJBECACQRAQKCADaxApIABBABAoIgJBFCADIAJBFBAoahApCyAAQQAQKCECIARFDQELCyANCyACQQQQKGsiAwR/An8gAyAAQSwQKCIESQR/IABBPBAoIABB7AAQKCICayADTQRAIABB7AAgAiAEayICECkgAEE4ECgiBiAEIAZqIAIQNhogAEGwLWoiAkEAECgiBEECSQRAIAJBACAEQQFqECkLCyAAQTgQKCAAQewAEChqIABBABAoQQAQKCADayADEDYaIABB7AAgAyAAQewAEChqIgIQKSAAQSwQKAUgAEGwLWpBAEECECkgAEE4ECggAkEAECggBGsgBBA2GiAAQewAIABBLBAoIgIQKSACCyEOIABB3AAgAhApIA4LIABBtC1qIgZBABAoIgdrIQQgBkEAIAcgBCADIAMgBEsbahApIAIFIABB7AAQKAshAyAAQcAtaiIEQQAQKCADSQRAIARBACADECkLIAUEQEEDDwsCQAJAIAEOBQEAAAABAAsgAEEAEChBBBAoRQRAIAMgAEHcABAoRgRAQQEPCwsLIABBABAoIgFBBBAoIgUgAEE8ECggA2tBf2oiAksEQCAAQdwAECgiByAAQSwQKCIGTgRAIABB3AAgByAGaxApIABB7AAgAyAGayIBECkgAEE4ECgiBSAFIAZqIAEQNhogAEGwLWoiAUEAECgiBUECSQRAIAFBACAFQQFqECkLIAIgAEEsEChqIQIgAEEAECgiAUEEECghBQsLIAUgAiACIAVLGyICBEAgASAAQTgQKCAAQewAEChqIAIQmQEaIABB7AAgAEHsABAoIAJqIgEQKQUgAEHsABAoIQELIARBABAoIAFJBEAgBEEAIAEQKQsCQAJAIAEgAEHcABAoIgNrIgEgAEEsECgiBSAAQQwQKCAJQQAQKEEqakEDdWsiAkH//wMgAkH//wNJGyICIAIgBUsbTw0AAkAgAQRAIAoNAQUgCEUNAQsgAEEAEChBBBAoQQBHIAEgAktyRQ0BCwwBCyAIBH8gAEEAEChBBBAoBH9BAAUgASACTQsFQQALIQUgACADIABBOBAoaiACIAEgASACSxsiASAFEHwgAEHcACAAQdwAECggAWoQKSAAQQAQKBA4IAUEQEECDwsLQQALoAIBBX8gABCYAQRAQX4PCyAAQRwQKCIBQQQQKCEEIAFBCBAoIgIEQCAAQSQQKCEBIABBKBAoIAIgAUEBcUE1ahEJACAAQRwQKCEBCyABQcQAECgiAgRAIABBJBAoIQEgAEEoECggAiABQQFxQTVqEQkAIABBHBAoIQELIAFBQGtBABAoIgIEQCAAQSQQKCEBIABBKBAoIAIgAUEBcUE1ahEJACAAQRwQKCEBCyABQTgQKCIFBEAgAEEkaiIDQQAQKCEBIABBKGoiAkEAECggBSABQQFxQTVqEQkAIABBHBAoIQEFIABBKGohAiAAQSRqIQMLIANBABAoIQMgAkEAECggASADQQFxQTVqEQkAIABBHEEAEClBfUEAIARB8QBGGwsuACABQgBTBH8gAgRAIAJBAEEEECkgAkEEQcsAECkLQX8FIAAgAUEAIAIQmgELCxcAIABCARA9IgBFBEAPCyAAQQAgARArCxcAIABCARA9IgBFBEBBAA8LIABBABAtC1oBAX9ByAAQNCIDRQRAQQAPCyADQQAgAhApIANBBCAAQQFxECsgA0EIQQkgASABQX9qQQhLGxApIANBDEEAECsgA0EwQQAQKSADQTRBABApIANBOEEAECkgAwscACABRQRAQQAPCyAAIAFBABAoIAFBBBAwrRBSC0IBAX8gAEUgAUVyBH8gACABRgUgAEEEEDEiAiABQQQQMUYEfyAAQQAQKCABQQAQKCACQf//A3EQS0UFQQALC0EBcQsnAQF/QQBBAEEAEDchASAARQRAIAEPCyABIABBABAoIABBBBAwEDcLoAIBAX4gAUEAECoiAkICg0IAUgRAIABBECABQRAQKhAsIAFBABAqIQILIAJCBINCAFIEQCAAQRggAUEYECoQLCABQQAQKiECCyACQgiDQgBSBEAgAEEgIAFBIBAqECwgAUEAECohAgsgAkIQg0IAUgRAIABBKCABQSgQKBApIAFBABAqIQILIAJCIINCAFIEQCAAQSwgAUEsECgQKSABQQAQKiECCyACQsAAg0IAUgRAIABBMCABQTAQMRAuIAFBABAqIQILIAJCgAGDQgBSBEAgAEEyIAFBMhAxEC4gAUEAECohAgsgAkKAAoNCAFEEQCAAQQAgAEEAECogAoQQLA8LIABBNCABQTQQKBApIABBACAAQQAQKiABQQAQKoQQLAuHBQEIfyMDIQUjA0FAayQDIwMjBE4EQEHAABAACwJAIABFDQAgAQRAIAFBMBAqIAJWBEAgA0EIcUUEQAJAIAFBQGtBABAoIgYgAqciB0EEdGpBCBAoRQRAIAdBBHQgBmpBDBAtQQFxRQ0BCyAAQQhqIgAEQCAAQQBBDxApIABBBEEAECkLDAQLCyABIAIgA0EIciAFEJwBQQBIBEAgAEEIaiIARQ0DIABBAEEUECkgAEEEQQAQKQwDCyADQSBxRSAFQTIQMUEAR3EhCCAFQTAQMSEJAn8CfwJAIAMgA0EDdkEEcXIiA0EEcUUiBw0AIAVBMBAxRQ0AQQAMAQtBAQshDCAIIARFcQRAIABBHBAoIgRFBEAgAEEIaiIARQ0FIABBAEEaECkgAEEEQQAQKQwFCwsgBUEgECpCAFEEQAJ/IABBAEIAQQAQoAEhCyAFJAMgCwsPCyABIAIgAyAAQQhqIgYQZiIDRQ0DIAFBABAoIAVBIBAqIAUgA0EMEDBBAXZBA3EgASACIAYQggMiA0UNAyADQSwgARApIAEgAxCAA0EASARAIAMQOgwECyAIBEBBAEEBIAVBMhAxIgZB//8DcUEBRxsiAQRAAkAgACADIAZBACAEIAFBAXFBIGoRAAAhASADEDogAQ0ADAYLBSAAQQhqIgBFDQUgAEEAQRgQKSAAQQRBABApDAULBSADIQELIAcgCUEAR3EEQCAAIAEgBUEwEDAQ2gEhAyABEDogA0UNBCADIQELIAwLBEAgACABQQEQ2QEhACABEDogAEUNAwUgASEACyAFJAMgAA8LCyAAQQhqIgAEQCAAQQBBEhApIABBBEEAECkLIAUkA0EADwsgBSQDQQALbgECfyMDIQIjA0EQaiQDIwMjBE4EQEEQEAALIABBJBAoQQFGBH8gAkEAIAEQLCACQQhBABApIAAgAkIQQQwQREI/h6chAyACJAMgAwUgAEEMaiIABEAgAEEAQRIQKSAAQQRBABApCyACJANBfwsLrQEAIANCEFQEfiAEBEAgBEEAQRIQKSAEQQRBABApC0J/BSACBH4CfgJAAkACQAJAAkAgAkEIECgOAwIAAQMLIAAgAkEAECp8IQAMAwsgASACQQAQKnwhAAwCCyACQQAQKiEADAELIAQEQCAEQQBBEhApIARBBEEAECkLQn8MAQsgAEIAUyAAIAFWcgR+IAQEQCAEQQBBEhApIARBBEEAECkLQn8FIAALCwVCfwsLC18BAX4gAxDXASIDBH8gAEEwIABBMBAoQQFqECkgA0EAIAAQKSADQQQgARApIANBCCACECkgA0EYQj8gACACQQBCAEEOIAFBB3FBJGoRBQAiBCAEQgBTGxAsIAMFQQALC48BAQF/QTgQNCIBBH8gAUEAQQAQKSABQQRBABApIAFBCEEAECkgAUEgQQAQKSABQSRBABApIAFBKEEAECsgAUEsQQAQKSABQTBBARApIAFBDEEAECkgAUEQQQAQKSABQRRBABApIAFBNEEAECsgAUE1QQAQKyABBSAABEAgAEEAQQ4QKSAAQQRBABApC0EACwtGAQF+IAIQ1wEiAgR/IAJBBCAAECkgAkEIIAEQKSACQRhCPyABQQBCAEEOIABBA3FBLGoRBAAiAyADQgBTGxAsIAIFQQALC54BAQF/IAFFBEAgAEEIaiIABEAgAEEAQRIQKSAAQQRBABApC0EADwtBOBA0IgMEfyADQQhBABApIANBDEEAECkgA0EQQQAQKSADQQAgAhApIANBBEEAECkgA0EoQgAQLCADQTBBAEEAQQAQNxApIANBGEIAECwgACABQQIgAxCfAQUgAEEIaiIABEAgAEEAQQ4QKSAAQQRBABApC0EACwsPACAAIAEgAkEAQQAQ3AELOgEBfyAARQRADwsgAEGowABqQQAQKEEEECghASAAQazAAGpBABAoIAFBA3FBMGoRAwAgABBUIAAQMguwAQEBfyABRQRAIABBCGoiAARAIABBAEESECkgAEEEQQAQKQtBAA8LQbCKAUHQigEgAxtBACACQf//A3FBCEYgAkF9S3IbIgVFBEAgAEEIaiIABEAgAEEAQRAQKSAAQQRBABApC0EADwsgAiADIAQgBRCOAyICRQRAIABBCGoiAARAIABBAEEOECkgAEEEQQAQKQtBAA8L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pwELBgBBpKcBCwgAQbSnARAkC6QBAQR/IwMhAiMDQRBqJAMjAyMETgRAQRAQAAsCQAJAIAAQRiIBQQZJDQAgACABakF6aiIEQYiaAUEGEEsNAEHkACEBAkADQCAEEKECIAJBAEGAAxApIAAgAhCzAiIDQX9KDQFBlKcBQQAQKEERRiABQX9qIgFBAEdxDQALIARBiJoBQQYQNhpBfyEDCwwBC0GUpwFBAEEWEClBfyEDCyACJAMgAwttAQN/IwMhASMDQRBqJAMjAyMETgRAQRAQAAtBACABECMaIAFBBHYgAGogAUEEEChBgYAEbHMhAgNAIAAgA2pBACACQQ9xQcEAaiACQQF0QSBxchArIAJBBXYhAiADQQFqIgNBBkcNAAsgASQDC1EBAX8jAyECIwNBEGokAyMDIwROBEBBEBAACyACQQAgABApIAJBBCABEClBJiACEB0iAEGAYEsEQEGUpwFBAEEAIABrEClBfyEACyACJAMgAAu+AQECfyACQcwAECgaIAJBygAgAkHKABAtIgQgBEH/AWpyECsgAkEIECggAkEEECgiBGsiA0EASgR/IAAgBCADIAEgAyABSRsiAxA2GiACQQQgAyACQQQQKGoQKSAAIANqIQAgASADawUgAQsiBARAAkADQAJAIAIQvwINACACQSAQKCEDIAIgACAEIANBD3FBEGoRBgAiA0EBakECSQ0AIAAgA2ohACAEIANrIgQNAQwCCwsgASAEayEBCwsgAQtnAQF/IABBKBAoIQEgAEEAIABBABAoQYABcQR/QQJBASAAQRQQKCAAQRwQKEsbBUEBCyABQQ9xQRBqEQYAIgFBAE4EQCAAQRQQKCAAQQQQKCABIABBCBAoa2pqIABBHBAoayEBCyABC0sBAX8jAyECIwNBEGokAyMDIwROBEBBEBAACyACQQAgABApIAJBBCABEClBDyACEB8iAEGAYEsEQEGUpwFBAEEAIABrECkLIAIkAwsuAQF/IAEEQAJAA38gACABQX9qIgFqIgJBABAtQS9GDQEgAQ0AQQALIQILCyACC7QBAQF/IAJBAUYEQCAAQQQQKCABIABBCBAoa2ohAQsCfwJAIABBFBAoIABBHBAoTQ0AIABBJBAoIQMgAEEAQQAgA0EPcUEQahEGABogAEEUECgNAEF/DAELIABBEEEAECkgAEEcQQAQ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EAALIAJBACABECkgAkEAEChBA2pBfHEiAUEAECghAyACQQAgAUEEahApIAJBEGoiAUEAIAAQKSABQQRBwoECECkgAUEIIAMQKUEFIAEQCiIAQYBgSwRAQZSnAUEAQQAgAGsQKUF/IQALIAIkAyAAC7cBAQN/IABBAEH1mQFBABBWEFUgAEEIQf2ZAUEAEIcCEIECIABBDEGBmgFBABCIAhCEAiAAQQ5Bg5oBQQAQLRArIAEEQCABIQJBDiEDA0AgAkEKbiEEIANBAWohAyACQQpPBEAgBCECDAELCyAAIANqQQBBABArA0AgACADQX9qIgNqQQAgASABQQpuIgJBdmxqQTByECsgAUEKTwRAIAIhAQwBCwsFIABBDkEwECsgAEEPQQAQKwsLzQEBBH8jAyECIwNBMGokAyMDIwROBEBBMBAACyACQShqIQQgAkEgaiIDQQAgABApIANBBCABEClBxQEgAxAeIgNBd0YEfyACQQAgABApIAJBBEEBEClB3QEgAhAEQQBIBH9BlKcBQQBBCRApQX8FIAIgABC0AiAEQQAgAhApIARBBCABEClBwwEgBBALIgBBgGBLBH9BlKcBQQBBACAAaxApQX8FIAALCwUgA0GAYEsEf0GUpwFBAEEAIANrEClBfwUgAwsLIQUgAiQDIAULTQEBfyMDIQEjA0EQaiQDIwMjBE4EQEEQEAALIAFBACAAEClBAEEGIAEQBiIAIABBfEYbIgBBgGBLBEBBlKcBQQBBACAAaxApCyABJAMLOQECfyACIABBEBAoIABBFBAoIgRrIgMgAyACSxshAyAEIAEgAxA2GiAAQRQgAEEUECggA2oQKSACC24BAX8gAEHKACAAQcoAEC0iASABQf8BanIQKyAAQQAQKCIBQQhxBH8gAEEAIAFBIHIQKUF/BSAAQQhBABApIABBBEEAECkgAEEcIABBLBAoIgEQKSAAQRQgARApIABBECABIABBMBAoahApQQALC7QCACAABH8CfyABQYABSQRAIABBACABECtBAQwBC0HkjgFBABAoQQAQKEUEQCABQYB/cUGAvwNGBEAgAEEAIAEQK0EBDAIFQZSnAUEAQdQAEClBfwwCCwALIAFBgBBJBEAgAEEAIAFBBnZBwAFyECsgAEEBIAFBP3FBgAFyECtBAgwBCyABQYBAcUGAwANGIAFBgLAD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QRBqEQYAGiAAQSwgBxApIABBMEEAECkgAEEQQQAQKSAAQRxBABApIABBFEEAECkLCyAAQQAgAEEAECggBkEgcXIQKQsgAyQDC/sCAQJ/IwMhAyMDQYABaiQDIwMjBE4EQEGAARAACyADQQBBrIwBQQAQQhA5IANBCEG0jAFBABBCEDkgA0EQQbyMAUEAEEIQOSADQRhBxIwBQQAQQhA5IANBIEHMjAFBABBCEDkgA0EoQdSMAUEAEEIQOSADQTBB3IwBQQAQQhA5IANBOEHkjAFBABBCEDkgA0FAa0EAQeyMAUEAEEIQOSADQcgAQfSMAUEAEEIQOSADQdAAQfyMAUEAEEIQOSADQdgAQYSNAUEAEEIQOSADQeAAQYyNAUEAEEIQOSADQegAQZSNAUEAEEIQOSADQfAAQZyNAUEAEEIQOSADQfgAQaSNAUEAECgQKSADQTBBfiAAayIEQf////8HIARB/////wdJGyIEECkgA0EUIAAQKSADQSwgABApIANBECAAIARqIgAQKSADQRwgABApIAMgASACEL0CIAQEQCADQRQQKCIAIAAgA0EQEChGQR90QR91akEAQQAQKwsgAyQDC54BAQJ/IABBygAgAEHKABAtIgEgAUH/AWpyECsgAEEUECggAEEcEChLBEAgAEEkECghASAAQQBBACABQQ9xQRBqEQYAGgsgAEEQQQAQKSAAQRxBABApIABBFEEAECkgAEEAECgiAUEEcQR/IABBACABQSByEClBfwUgAEEIIABBLBAoIABBMBAoaiICECkgAEEEIAIQKSABQRt0QR91Cwt5AQN/IwMhAyMDQSBqJAMjAyMETgRAQSAQAAsgA0EQaiEEIABBJEEIECkgAEEAEChBwABxRQRAIANBACAAQTwQKBApIANBBEGTqAEQKSADQQggBBApQTYgAxAJBEAgAEHLAEF/ECsLCyAAIAEgAhC+ASEFIAMkAyAFC4oCAQR/IwMhBCMDQSBqJAMjAyMETgRAQSAQAAsgBEEAIAEQKSAEQQQgAiAAQTAQKCIDQQBHaxApIARBCCAAQSwQKBApIARBDCADECkgBEEQaiIDQQAgAEE8ECgQKSADQQQgBBApIANBCEECEClBkQEgAxAgIgNBgGBLBEBBlKcBQQBBACADaxApQX8hAwsgA0EBSARAIABBACAAQQAQKCADQTBx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IABByAAgAEHUABAoIABBOBAoIApBA2pqQQAQLyAAQcgAECggAEHYABAodHNxIgIQKSALQQAQKCADIABBNBAocUEBdGpBACAAQcQAECggAkEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACAAQewAECgQLiAAQfgAECghAgsgAEH4ACACQX9qIgIQKSACDQALIABB6ABBABApIABB4ABBAhApIABB7AAgAEHsABAoQQFqIgUQKSARC0YEQCAAIABB3AAQKCICQX9KBH8gAiAAQTgQKGoFQQALIAUgAmtBABBDIABB3AAgAEHsABAoECkgAEEAECgQOCAAQQAQKEEQEChFDQQLCwwBCwsgAEHoABAoBEAgAEE4ECggAEHsABAoQX9qakEAEC0hAiAGQQAQKCAEQQAQKEEBdGpBAEEAEC4CfyAHQQAQKCESIARBACAEQQAQKCIHQQFqECkgEgsgB2pBACACECsgAEGUAWogAkH/AXFBAnRqIgJBACACQQAQMUEBahAuIABB6ABBABApCyAAQbQtakEAIABB7AAQKCICQQIgAkECSRsQKSABQQRGBEAgAEHcABAoIgFBf0wEQCAAQQAgAiABa0EBEEMMAwsgACABIABBOBAoaiACIAFrQQEQQwwCCyAEQQAQKARAIAAgAEHcABAoIgFBf0oEfyABIABBOBAoagVBAAsgAiABa0EAEEMgAEHcACAAQewAECgQKSAAQQAQKBA4IABBABAoQRAQKEUEQEEADwsLQQEPC0EADwsgAEHcACAAQewAECgQKSAAQQAQKBA4QQNBAiAAQQAQKEEQECgbC9cKAQ1/IAFBAEchCyAAQUBrIQcgAEGkLWohCCAAQaAtaiEEIABBmC1qIQkgAEGcLWohCgJAAkADQAJAAkACQCAAQfQAEChBhgJJBEAgABB9IABB9AAQKCICQYUCSyALckUNBSACRQ0DIAJBAk0NAQsgAEHIACAAQdQAECggAEE4ECggAEHsABAoIgJBAmpqQQAQLyAAQcgAECggAEHYABAodHNxIgMQKSAHQQAQKCACIABBNBAocUEBdGpBACAAQcQAECggA0EBdGpBABAxIgIQLiAAQcQAECggAEHIABAoQQF0akEAIABB7AAQKBAuIAJFDQAgAEHsABAoIAJB//8DcSICayAAQSwQKEH6fWpLDQAgAEHgACAAIAIQyAEiAhApDAELIABB4AAQKCECCwJAAkAgAkECSwRAAkAgCEEAECggBEEAEChBAXRqQQAgAEHsABAoIABB8AAQKGtB//8DcSIDEC4CfyAJQQAQKCEMIARBACAEQQAQKCIGQQFqECkgDAsgBmpBACACQf0BaiICECsgAkH/AXFBsOYAakEAEC9BgAJyQQJ0IABqQZgBaiICQQAgAkEAEDFBAWoQLiADQX9qQRB0QRB1IgNB//8DcSECIABBiBNqIANB//8DcUGAAkgEfyACQbDiAGpBABAvBSACQQd2QbDkAGpBABAvC0ECdGoiAkEAIAJBABAxQQFqEC4gBEEAECggCkEAEChBf2pGIQMgAEH0ACAAQfQAECggAEHgABAoIgJrIgUQKSACIABBgAEQKE0gBUECS3FFBEAgAEHsACACIABB7AAQKGoiAhApIABB4ABBABApIABByAAgAiAAQTgQKCIFakEAEC8iBhApIABByAAgAEHUABAoIAUgAkEBampBABAvIAYgAEHYABAodHNxECkgA0UNAQwDCyAAQeAAIAJBf2oQKQNAIABB7AAgAEHsABAoIgJBAWoiBRApIABByAAgAEHUABAoIABBOBAoIAJBA2pqQQAQLyAAQcgAECggAEHYABAodHNxIgIQKSAHQQAQKCAFIABBNBAocUEBdGpBACAAQcQAECggAkEBdGpBABAxEC4gAEHEABAoIABByAAQKEEBdGpBACAAQewAECgQLiAAQeAAIABB4AAQKEF/aiICECkgAg0ACyAAQewAIABB7AAQKEEBaiICECkgAw0CCwUgAEE4ECggAEHsABAoakEAEC0hAiAIQQAQKCAEQQAQKEEBdGpBAEEAEC4CfyAJQQAQKCENIARBACAEQQAQKCIFQQFqECkgDQsgBWpBACACECsgAEGUAWogAkH/AXFBAnRqIgJBACACQQAQMUEBahAuAn8gBEEAECggCkEAEChBf2pGIQ4gAEH0ACAAQfQAEChBf2oQKSAAQewAIABB7AAQKEEBaiICECkgDgsNAQsMAQsgACAAQdwAECgiA0F/SgR/IAMgAEE4EChqBUEACyACIANrQQAQQyAAQdwAIABB7AAQKBApIABBABAoEDggAEEAEChBEBAoRQ0DCwwBCwsgAEG0LWpBACAAQewAECgiAkECIAJBAkkbECkg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KSAABH8gAUEAQQAQKSABQQRBABApIAFBCEEAECkgAUEMQQAQKSABQRBBABApIAFB1ABBABApIAFBFEIAEDkgAUEcQgAQOSABQSRBABApIAFBKEEAECsgAUEwQgAQLCABQThCABAsIAFBwABCABAsIAFByABCABAsIAEFIAEQMkEACwuaAQECfyAAQTAQKiABWARAIABBCGoiAARAIABBAEESECkgAEEEQQAQKQsPCyAAQQhqIQIgAEEYEChBAnEEQCACBEAgAkEAQRkQKSACQQRBABApCw8LIAAgAUEAIAIQiQEiA0UEQA8LIABB0AAQKCADIAIQpAFFBEAPCyAAIAEQ5AIEQA8LIABBQGtBABAoIAGnQQR0akEMQQEQKwsxACAAQQAQKBBYQgBTBEBBfw8LIAAgASACEMgCQgBTBH9BfwUgAEEAECgQWEI/h6cLC0QBAn4gAEEAEC1BAXEEQCABIABBEBAqIgJ8IgMgAVoEQCADIABBCBAqWARAIABBBBAoIAKnag8LCwsgAEEAQQAQK0EACwsAQQAgASACEM4BC50BAwN/AX4BfCMDIQIjA0GAQGskAyMDIwROBEBBgMAAEAALIAG6IQYgAEEIaiEDA38Cf0EAIAFCAFENABpBfyAAQQAQKCACIAFCgMAAIAFCgMAAVBtC/////w+DIgUgAxCHAUEASA0AGiAAIAIgBRBSQQBIBH9BfwUgAEHUABAoIAYgASAFfSIBuqEgBqMQgQEMAgsLCyEEIAIkAyAEC7cBAQF+IABBICACQQAQKiIDQv////8PIANC/////w9UGxB0IABBHCABECkgAEEQaiEBIABBBBAtQQFxBH8gASAAQQwQLUECdEEEcRDbAgUgARDUAgshASACQQAgAkEAECogAEEgECitfRAsAkACQAJAAkAgAUF7aw4HAQMDAwMCAAMLQQEPCyAAQRQQKEUEQEEDDwsMAQtBAA8LIABBABAoIgAEQCAAQQBBDRApIABBBCABECkLQQILCgAgAEEMQQEQKwtIACACQv////8PWARAIABBFBAoRQRAIABBFCACEHQgAEEQIAEQKUEBDwsLIABBABAoIgAEQCAAQQBBEhApIABBBEEAECkLQQALSAEBfyAAQRBqIQEgAEEEEC1BAXEEfyABEMoBBSABENICCyIBRQRAQQEPCyAAQQAQKCIABEAg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BQsgBEEAQQEQKSAEQQRBAhApIARBCEEDECkgBEEMQQQQKSAEQRBBBRApIARBFEEGECkgBEEYQQcQKSAEQRxBCBApIARBIEERECkgBEEkQQkQKSAEQShBDxApIARBLEEKECkgBEEwQQwQKSAEQTRBDRApIARBOEELECkgBEE8QX8QKUEAIAQQWQwECyAAQRAQKEE4ECoiAkIAUwR+IAAEQCAAQQBBHhApIABBBEHLABApC0J/BSACCwwDCyAAQRQQKEE4ECoiAkIAUwR+IAAEQCAAQQBBHhApIABBBEHLABApC0J/BSACCwwCCyACQgBTBH4gAARAIABBAEESECkgAEEEQQAQKQtCfwUgAEEUECggASACIAAQkQMLDAELIAAEQCAAQQBBHBApIABBBEEAECkLQn8LIQUgBCQDIAULCQAgAEEYECqnC6oBACAARQRAIAIEQCACQQBBEhApIAJBBEEAECkLQQAPCyAAQgEgASACEHEiAUUEQEEADwtBGBA0IgBFBEAgAgRAIAJBAEEOECkgAkEEQQAQKQsgARBRQQAPCyAAQRAgARApIABBFEEAECkgAEEMQQAQCBApIABBAEEAECkgAEEEQQAQKSAAQQhBABApQQEgACACENgBIgEEQCABDwsgAEEQECgQUSAAEDJBAAtIACAAQSQQKEEBRgRAIABBDGoiAARAIABBAEESECkgAEEEQQAQKQtBfw8LIABBACABQREQREIAUwRAQX8PCyAAQSRBARApQQALSAAgAEEkEChBAUYEQCAAQQxqIgAEQCAAQQBBEhApIABBBEEAECkLQX8PCyAAQQBCAEEIEERCAFMEQEF/DwsgAEEkQQEQKUEAC7EFAgZ/AX4gAEEwECogAVgEQCAAQQhqIgAEQCAAQQBBEhApIABBBEEAECkLQX8PCyAAQRgQKEECcQRAIABBCGoiAARAIABBAEEZECkgAEEEQQAQKQtBfw8LIAIEfyACQQAQLQR/IAIgAhBGQf//A3EgAyAAQQhqEH4iBEUEQEF/DwsgA0GAMHFFBEAgBEEAEGNBA0YEQCAEQQhBAhApCwsgBAVBAAsFQQALIQMgACACQQBBABCEASIKQn9VBEAgAxBJIAEgClEEQEEADwsgAEEIaiIABEAgAEEAQQoQKSAAQQRBABApC0F/DwsCQAJAAkAgAEFAa0EAECgiBiAB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dXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAAAAAAD/////////////////////AQAAAAEAAAABAAAAAgAAAAMAAAABAAAAAgAAAAIAAAADAAAAAQAAAAEAAAACAAAAAwAAAAEAAAACAAAAAgAAAIA1AAAAOgAAAQEAAB4BAAAPAAAAgDQAAAA1AAAAAAAAHgAAAA8AAAAAAAAAMDQAAAAAAAATAAAABwAAAAUAQbiLAQsBBABB0IsBCw4EAAAABQAAABhNAAAABABB6IsBCwEBAEH3iwELBQr/////AEGojAELAqxFAEHQjAELAQYAQfeMAQsF//////8AQeSOAQsCfFMAQZyPAQvyCkFFAFBLAwQAUEsBAgBVbmtub3duIGVycm9yICVkADogACVzJXMlcwBQSwcIAFBLBQYAUEsGBwBQSwYGAE5vIGVycm9yAE11bHRpLWRpc2sgemlwIGFyY2hpdmVzIG5vdCBzdXBwb3J0ZWQAUmVuYW1pbmcgdGVtcG9yYXJ5IGZpbGUgZmFpbGVkAENsb3NpbmcgemlwIGFyY2hpdmUgZmFpbGVkAFNlZWsgZXJyb3IAUmVhZCBlcnJvcgBXcml0ZSBlcnJvcgBDUkMgZXJyb3IAQ29udGFpbmluZyB6aXAgYXJjaGl2ZSB3YXMgY2xvc2VkAE5vIHN1Y2ggZmlsZQBGaWxlIGFscmVhZHkgZXhpc3RzAENhbid0IG9wZW4gZmlsZQBGYWlsdXJlIHRvIGNyZWF0ZSB0ZW1wb3JhcnkgZmlsZQBabGliIGVycm9yAE1hbGxvYyBmYWlsdXJlAEVudHJ5IGhhcyBiZWVuIGNoYW5nZWQAQ29tcHJlc3Npb24gbWV0aG9kIG5vdCBzdXBwb3J0ZWQAUHJlbWF0dXJlIGVuZCBvZiBmaWxlAEludmFsaWQgYXJndW1lbnQATm90IGEgemlwIGFyY2hpdmUASW50ZXJuYWwgZXJyb3IAWmlwIGFyY2hpdmUgaW5jb25zaXN0ZW50AENhbid0IHJlbW92ZSBmaWxlAEVudHJ5IGhhcyBiZWVuIGRlbGV0ZWQARW5jcnlwdGlvbiBtZXRob2Qgbm90IHN1cHBvcnRlZABSZWFkLW9ubHkgYXJjaGl2ZQBObyBwYXNzd29yZCBwcm92aWRlZABXcm9uZyBwYXNzd29yZCBwcm92aWRlZABPcGVyYXRpb24gbm90IHN1cHBvcnRlZABSZXNvdXJjZSBzdGlsbCBpbiB1c2UAVGVsbCBlcnJvcgBDb21wcmVzc2VkIGRhdGEgaW52YWxpZAByYgAlcy5YWFhYWFgAcitiAGluY29ycmVjdCBoZWFkZXIgY2hlY2sAdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QAaW52YWxpZCB3aW5kb3cgc2l6ZQB1bmtub3duIGhlYWRlciBmbGFncyBzZXQAaGVhZGVyIGNyYyBtaXNtYXRjaABpbnZhbGlkIGJsb2NrIHR5cGUAaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocwB0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scwBpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQAaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdABpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2sAaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0AGludmFsaWQgZGlzdGFuY2VzIHNldABpbmNvcnJlY3QgZGF0YSBjaGVjawBpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrAGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrAGludmFsaWQgZGlzdGFuY2UgY29kZQBpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUAbmVlZCBkaWN0aW9uYXJ5AHN0cmVhbSBlbmQAZmlsZSBlcnJvcgBzdHJlYW0gZXJyb3IAZGF0YSBlcnJvcgBpbnN1ZmZpY2llbnQgbWVtb3J5AGJ1ZmZlciBlcnJvcgBpbmNvbXBhdGlibGUgdmVyc2lvbgAtKyAgIDBYMHgAKG51bGwpAC0wWCswWCAwWC0weCsweCAweABpbmYASU5GAG5hbgBOQU4ALgAvcHJvYy9zZWxmL2ZkLwByd2EAWFhYWFhY";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(){try{if(Module["wasmBinary"]){return new Uint8Array(Module["wasmBinary"])}var binary=tryParseAsDataURI(wasmBinaryFile);if(binary){return binary}if(Module["readBinary"]){return Module["readBinary"](wasmBinaryFile)}else{throw"sync fetching of the wasm failed: you can preload it to Module['wasmBinary'] manually, or emcc.py will do that for you when generating HTML (but not JS)"}}catch(err){abort(err)}}function createWasm(env){var info={"env":env,"global":{"NaN":NaN,Infinity:Infinity},"global.Math":Math,"asm2wasm":asm2wasmImports};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");if(Module["instantiateWasm"]){try{return Module["instantiateWasm"](info,receiveInstance)}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}var instance;var module;try{module=new WebAssembly.Module(getBinary());instance=new WebAssembly.Instance(module,info)}catch(e){err("failed to compile wasm module: "+e);if(e.toString().indexOf("imported Memory with incompatible size")>=0){err("Memory size incompatibility issues may be due to changing TOTAL_MEMORY at runtime to something too large. Use ALLOW_MEMORY_GROWTH to allow any size memory (and also make sure not to set TOTAL_MEMORY at runtime to something smaller than it was at compile time).")}return false}receiveInstance(instance,module);return Module["asm"]}Module["asm"]=function(global,env,providedBuffer){env["memory"]=wasmMemory;env["table"]=wasmTable=new WebAssembly.Table({"initial":55,"maximum":55,"element":"anyfunc"});env["__memory_base"]=1024;env["__table_base"]=0;var exports=createWasm(env);assert(exports,"binaryen setup failed (no wasm support?)");return exports};__ATINIT__.push({func:function(){___emscripten_environ_constructor()}});var tempDoublePtr=22704;assert(tempDoublePtr%8==0);var ENV={};function ___buildEnvironment(environ){var MAX_ENV_VALUES=64;var TOTAL_ENV_SIZE=1024;var poolPtr;var envPtr;if(!___buildEnvironment.called){___buildEnvironment.called=true;ENV["USER"]=ENV["LOGNAME"]="web_user";ENV["PATH"]="/";ENV["PWD"]="/";ENV["HOME"]="/home/web_user";ENV["LANG"]="C.UTF-8";ENV["_"]=Module["thisProgram"];poolPtr=getMemory(TOTAL_ENV_SIZE);envPtr=getMemory(MAX_ENV_VALUES*4);SAFE_HEAP_STORE(envPtr|0,poolPtr|0,4);SAFE_HEAP_STORE(environ|0,envPtr|0,4)}else{envPtr=SAFE_HEAP_LOAD(environ|0,4,0)|0;poolPtr=SAFE_HEAP_LOAD(envPtr|0,4,0)|0}var strings=[];var totalSize=0;for(var key in ENV){if(typeof ENV[key]==="string"){var line=key+"="+ENV[key];strings.push(line);totalSize+=line.length}}if(totalSize>TOTAL_ENV_SIZE){throw new Error("Environment size exceeded TOTAL_ENV_SIZE!")}var ptrSize=4;for(var i=0;i<strings.length;i++){var line=strings[i];writeAsciiToMemory(line,poolPtr);SAFE_HEAP_STORE(envPtr+i*ptrSize|0,poolPtr|0,4);poolPtr+=line.length+1}SAFE_HEAP_STORE(envPtr+strings.length*ptrSize|0,0|0,4)}function _emscripten_get_now(){abort()}function _emscripten_get_now_is_monotonic(){return  false||ENVIRONMENT_IS_NODE}function ___setErrNo(value){if(Module["___errno_location"])SAFE_HEAP_STORE(Module["___errno_location"]()|0,value|0,4);else err("failed to set errno from JS");return value}function _clock_gettime(clk_id,tp){var now;if(clk_id===0){now=Date.now()}else if(clk_id===1&&_emscripten_get_now_is_monotonic()){now=_emscripten_get_now()}else{___setErrNo(22);return-1}SAFE_HEAP_STORE(tp|0,now/1e3|0|0,4);SAFE_HEAP_STORE(tp+4|0,now%1e3*1e3*1e3|0|0,4);return 0}function ___clock_gettime(a0,a1){return _clock_gettime(a0,a1)}function ___lock(){}var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift("..")}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)},resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return!!p}),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}stream.tty=tty;stream.seekable=false},close:function(stream){stream.tty.ops.flush(stream.tty)},flush:function(stream){stream.tty.ops.flush(stream.tty)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(ERRNO_CODES.EAGAIN)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(ERRNO_CODES.ENXIO)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=new Buffer(BUFSIZE);var bytesRead=0;var isPosixPlatform=process.platform!="win32";var fd=process.stdin.fd;if(isPosixPlatform){var usingDevice=false;try{fd=fs.openSync("/dev/stdin","r");usingDevice=true}catch(e){}}try{bytesRead=fs.readSync(fd,buf,0,BUFSIZE,null)}catch(e){if(e.toString().indexOf("EOF")!=-1)bytesRead=0;else throw e}if(usingDevice){fs.closeSync(fd)}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(ERRNO_CODES.EPERM)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node}return node},getFileDataAsRegularArray:function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array;if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup:function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}}}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=new_dir},unlink:function(parent,name){delete parent.contents[name]},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY)}delete parent.contents[name]},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write:function(stream,buffer,offset,length,position,canOwn){if(canOwn){warnOnce("file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)")}canOwn=false;if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){assert(position===0,"canOwn must imply no weird position inside the file");node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=_malloc(length);if(!ptr){throw new FS.ErrnoError(ERRNO_CODES.ENOMEM)}buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};var NODEFS={isWindows:false,staticInit:function(){NODEFS.isWindows=!!process.platform.match(/^win/);var flags=process["binding"]("constants");if(flags["fs"]){flags=flags["fs"]}NODEFS.flagsForNodeMap={1024:flags["O_APPEND"],64:flags["O_CREAT"],128:flags["O_EXCL"],0:flags["O_RDONLY"],2:flags["O_RDWR"],4096:flags["O_SYNC"],512:flags["O_TRUNC"],1:flags["O_WRONLY"]}},bufferFrom:function(arrayBuffer){return Buffer.alloc?Buffer.from(arrayBuffer):new Buffer(arrayBuffer)},mount:function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)},createNode:function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode)){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node},getMode:function(path){var stat;try{stat=fs.lstatSync(path);if(NODEFS.isWindows){stat.mode=stat.mode|(stat.mode&292)>>2}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return stat.mode},realPath:function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)},flagsForNode:function(flags){flags&=~2097152;flags&=~2048;flags&=~32768;flags&=~524288;var newFlags=0;for(var k in NODEFS.flagsForNodeMap){if(flags&k){newFlags|=NODEFS.flagsForNodeMap[k];flags^=k}}if(!flags){return newFlags}else{throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}},node_ops:{getattr:function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}if(NODEFS.isWindows&&!stat.blksize){stat.blksize=4096}if(NODEFS.isWindows&&!stat.blocks){stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0}return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}},setattr:function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,date,date)}if(attr.size!==undefined){fs.truncateSync(path,attr.size)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},lookup:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)},mknod:function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode)){fs.mkdirSync(path,node.mode)}else{fs.writeFileSync(path,"",{mode:node.mode})}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}return node},rename:function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},unlink:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},rmdir:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},readdir:function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},symlink:function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},readlink:function(node){var path=NODEFS.realPath(node);try{path=fs.readlinkSync(path);path=NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root),path);return path}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}},stream_ops:{open:function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode)){stream.nfd=fs.openSync(path,NODEFS.flagsForNode(stream.flags))}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},close:function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd){fs.closeSync(stream.nfd)}}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}},read:function(stream,buffer,offset,length,position){if(length===0)return 0;try{return fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}},write:function(stream,buffer,offset,length,position){try{return fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code])}}}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}return position}}};var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};var NODERAWFS={lookupPath:function(path){return{path:path,node:{mode:NODEFS.getMode(path)}}},createStandardStreams:function(){FS.streams[0]={fd:0,nfd:0,position:0,path:"",flags:0,tty:true,seekable:false};for(var i=1;i<3;i++){FS.streams[i]={fd:i,nfd:i,position:0,path:"",flags:577,tty:true,seekable:false}}},cwd:function(){return process.cwd()},chdir:function(){process.chdir.apply(void 0,arguments)},mknod:function(path,mode){if(FS.isDir(path)){fs.mkdirSync(path,mode)}else{fs.writeFileSync(path,"",{mode:mode})}},mkdir:function(){fs.mkdirSync.apply(void 0,arguments)},symlink:function(){fs.symlinkSync.apply(void 0,arguments)},rename:function(){fs.renameSync.apply(void 0,arguments)},rmdir:function(){fs.rmdirSync.apply(void 0,arguments)},readdir:function(){fs.readdirSync.apply(void 0,arguments)},unlink:function(){fs.unlinkSync.apply(void 0,arguments)},readlink:function(){return fs.readlinkSync.apply(void 0,arguments)},stat:function(){return fs.statSync.apply(void 0,arguments)},lstat:function(){return fs.lstatSync.apply(void 0,arguments)},chmod:function(){fs.chmodSync.apply(void 0,arguments)},fchmod:function(){fs.fchmodSync.apply(void 0,arguments)},chown:function(){fs.chownSync.apply(void 0,arguments)},fchown:function(){fs.fchownSync.apply(void 0,arguments)},truncate:function(){fs.truncateSync.apply(void 0,arguments)},ftruncate:function(){fs.ftruncateSync.apply(void 0,arguments)},utime:function(){fs.utimesSync.apply(void 0,arguments)},open:function(path,flags,mode,suggestFD){if(typeof flags==="string"){flags=VFS.modeStringToFlags(flags)}var nfd=fs.openSync(path,NODEFS.flagsForNode(flags),mode);var fd=suggestFD!=null?suggestFD:FS.nextfd(nfd);var stream={fd:fd,nfd:nfd,position:0,path:path,flags:flags,seekable:true};FS.streams[fd]=stream;return stream},close:function(stream){if(!stream.stream_ops){fs.closeSync(stream.nfd)}FS.closeStream(stream.fd)},llseek:function(stream,offset,whence){if(stream.stream_ops){return VFS.llseek(stream,offset,whence)}var position=offset;if(whence===1){position+=stream.position}else if(whence===2){position+=fs.fstatSync(stream.nfd).size}else if(whence!==0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}if(position<0){throw new FS.ErrnoError(ERRNO_CODES.EINVAL)}stream.position=position;return position},read:function(stream,buffer,offset,length,position){if(stream.stream_ops){return VFS.read(stream,buffer,offset,length,position)}var seeking=typeof position!=="undefined";if(!seeking&&stream.seekable)position=stream.position;var bytesRead=fs.readSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position){if(stream.stream_ops){return VFS.write(stream,buffer,offset,length,position)}if(stream.flags&+"1024"){FS.llseek(stream,0,+"2")}var seeking=typeof position!=="undefined";if(!seeking&&stream.seekable)position=stream.position;var bytesWritten=fs.writeSync(stream.nfd,NODEFS.bufferFrom(buffer.buffer),offset,length,position);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:function(){throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP)},mmap:function(){throw new FS.ErrnoError(ERRNO_CODES.ENODEV)},msync:function(){return 0},munmap:function(){return 0},ioctl:function(){throw new FS.ErrnoError(ERRNO_CODES.ENOTTY)}};var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)},lookupPath:function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults){if(opts[key]===undefined){opts[key]=defaults[key]}}if(opts.recurse_count>8){throw new FS.ErrnoError(40)}var parts=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40){throw new FS.ErrnoError(40)}}}}return{path:current_path,node:current}},getPath:function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}},hashName:function(parentid,name){var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:function(parent,name){var err=FS.mayLookup(parent);if(err){throw new FS.ErrnoError(err,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:function(node){FS.hashRemoveNode(node)},isRoot:function(node){return node===node.parent},isMountpoint:function(node){return!!node.mounted},isFile:function(mode){return(mode&61440)===32768},isDir:function(mode){return(mode&61440)===16384},isLink:function(mode){return(mode&61440)===40960},isChrdev:function(mode){return(mode&61440)===8192},isBlkdev:function(mode){return(mode&61440)===24576},isFIFO:function(mode){return(mode&61440)===4096},isSocket:function(mode){return(mode&49152)===49152},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str){var flags=FS.flagModes[str];if(typeof flags==="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:function(flag){var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms},nodePermissions:function(node,perms){if(FS.ignorePermissions){return 0}if(perms.indexOf("r")!==-1&&!(node.mode&292)){return 13}else if(perms.indexOf("w")!==-1&&!(node.mode&146)){return 13}else if(perms.indexOf("x")!==-1&&!(node.mode&73)){return 13}return 0},mayLookup:function(dir){var err=FS.nodePermissions(dir,"x");if(err)return err;if(!dir.node_ops.lookup)return 13;return 0},mayCreate:function(dir,name){try{var node=FS.lookupNode(dir,name);return 17}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err){return err}if(isdir){if(!FS.isDir(node.mode)){return 20}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 16}}else{if(FS.isDir(node.mode)){return 21}}return 0},mayOpen:function(node,flags){if(!node){return 2}if(FS.isLink(node.mode)){return 40}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 21}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(24)},getStream:function(fd){return FS.streams[fd]},createStream:function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}})}var newStream=new FS.FSStream;for(var p in stream){newStream[p]=stream[p]}stream=newStream;var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:function(fd){FS.streams[fd]=null},chrdev_stream_ops:{open:function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}},llseek:function(){throw new FS.ErrnoError(29)}},major:function(dev){return dev>>8},minor:function(dev){return dev&255},makedev:function(ma,mi){return ma<<8|mi},registerDevice:function(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:function(dev){return FS.devices[dev]},getMounts:function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){console.log("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(err){assert(FS.syncFSRequests>0);FS.syncFSRequests--;return callback(err)}function done(err){if(err){if(!done.errored){done.errored=true;return doCallback(err)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(function(mount){if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount:function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(16)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount:function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(22)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)},lookup:function(parent,name){return parent.node_ops.lookup(parent,name)},mknod:function(path,mode,dev){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(22)}var err=FS.mayCreate(parent,name);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(1)}return parent.node_ops.mknod(parent,name,mode,dev)},create:function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:function(path,mode){var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=17)throw e}}},mkdev:function(path,mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:function(oldpath,newpath){if(!PATH.resolve(oldpath)){throw new FS.ErrnoError(2)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(2)}var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(1)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:function(old_path,new_path){var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(16)}if(!old_dir||!new_dir)throw new FS.ErrnoError(2);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(18)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(22)}relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(39)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err){throw new FS.ErrnoError(err)}err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err){throw new FS.ErrnoError(err)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(1)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(16)}if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err){throw new FS.ErrnoError(err)}}try{if(FS.trackingDelegate["willMovePath"]){FS.trackingDelegate["willMovePath"](old_path,new_path)}}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}},rmdir:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},readdir:function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(20)}return node.node_ops.readdir(node)},unlink:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){throw new FS.ErrnoError(err)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(1)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(16)}try{if(FS.trackingDelegate["willDeletePath"]){FS.trackingDelegate["willDeletePath"](path)}}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},readlink:function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(2)}if(!link.node_ops.readlink){throw new FS.ErrnoError(22)}return PATH.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(2)}if(!node.node_ops.getattr){throw new FS.ErrnoError(1)}return node.node_ops.getattr(node)},lstat:function(path){return FS.stat(path,true)},chmod:function(path,mode,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:function(path,mode){FS.chmod(path,mode,true)},fchmod:function(fd,mode){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chmod(stream.node,mode)},chown:function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:function(path,uid,gid){FS.chown(path,uid,gid,true)},fchown:function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}FS.chown(stream.node,uid,gid)},truncate:function(path,len){if(len<0){throw new FS.ErrnoError(22)}var node;if(typeof path==="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(1)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(21)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(22)}var err=FS.nodePermissions(node,"w");if(err){throw new FS.ErrnoError(err)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:function(fd,len){var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(22)}FS.truncate(stream.node,len)},utime:function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:function(path,flags,mode,fd_start,fd_end){if(path===""){throw new FS.ErrnoError(2)}flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path==="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(17)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(2)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(20)}if(!created){var err=FS.mayOpen(node,flags);if(err){throw new FS.ErrnoError(err)}}if(flags&512){FS.truncate(node,0)}flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;console.log("FS.trackingDelegate error on read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1){trackingFlags|=FS.tracking.openFlags.READ}if((flags&2097155)!==0){trackingFlags|=FS.tracking.openFlags.WRITE}FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream},close:function(stream){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed:function(stream){return stream.fd===null},llseek:function(stream,offset,whence){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(29)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(22)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:function(stream,buffer,offset,length,position){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.read){throw new FS.ErrnoError(22)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0){throw new FS.ErrnoError(22)}if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(21)}if(!stream.stream_ops.write){throw new FS.ErrnoError(22)}if(stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!=="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(29)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: "+e.message)}return bytesWritten},allocate:function(stream,offset,length){if(FS.isClosed(stream)){throw new FS.ErrnoError(9)}if(offset<0||length<=0){throw new FS.ErrnoError(22)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(9)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(19)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(95)}stream.stream_ops.allocate(stream,offset,length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1){throw new FS.ErrnoError(13)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(19)}return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)},msync:function(stream,buffer,offset,length,mmapFlags){if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:function(stream){return 0},ioctl:function(stream,cmd,arg){if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(25)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret},writeFile:function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";var stream=FS.open(path,opts.flags,opts.mode);if(typeof data==="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error("Unsupported data type")}FS.close(stream)},cwd:function(){return FS.currentPath},chdir:function(path){var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(2)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(20)}var err=FS.nodePermissions(lookup.node,"x");if(err){throw new FS.ErrnoError(err)}FS.currentPath=lookup.path},createDefaultDirectories:function(){FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")},createDefaultDevices:function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:function(){return 0},write:function(stream,buffer,offset,length,pos){return length}});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device;if(typeof crypto==="object"&&typeof crypto["getRandomValues"]==="function"){var randomBuffer=new Uint8Array(1);random_device=function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=__webpack_require__(10);random_device=function(){return crypto_module["randomBytes"](1)[0]}}catch(e){}}else{}if(!random_device){random_device=function(){abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };")}}FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createSpecialDirectories:function(){FS.mkdir("/proc");FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:function(){var node=FS.createNode("/proc/self","fd",16384|511,73);node.node_ops={lookup:function(parent,name){var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(9);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return stream.path}}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd")},createStandardStreams:function(){if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin","r");var stdout=FS.open("/dev/stdout","w");var stderr=FS.open("/dev/stderr","w");assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")},ensureErrnoError:function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno;for(var key in ERRNO_CODES){if(ERRNO_CODES[key]===errno){this.code=key;break}}};this.setErrno(errno);this.message=ERRNO_MESSAGES[errno];if(this.stack)Object.defineProperty(this,"stack",{value:(new Error).stack,writable:true});if(this.stack)this.stack=demangleAll(this.stack)};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[2].forEach(function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"NODEFS":NODEFS}},init:function(input,output,error){assert(!FS.init.initialized,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:function(){FS.init.initialized=false;var fflush=Module["_fflush"];if(fflush)fflush(0);for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},getMode:function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},joinPath:function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path},absolutePath:function(relative,base){return PATH.resolve(base,relative)},standardizePath:function(path){return PATH.normalize(path)},findObject:function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{___setErrNo(ret.error);return null}},analyzePath:function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createFolder:function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)},createPath:function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:function(stream){stream.seekable=false},close:function(stream){if(output&&output.buffer&&output.buffer.length){output(10)}},read:function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(5)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(11)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(5)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},createLink:function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)},forceLoadFile:function(obj){if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(Module["read"]){try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}if(!success)___setErrNo(5);return success},createLazyFile:function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]==="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;console.log("LazyFiles on gzip forces download of the whole file when length is accessed")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}return fn.apply(null,arguments)}});stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node)){throw new FS.ErrnoError(5)}var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size};node.stream_ops=stream_ops;return node},createPreloadedFile:function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,function(){if(onerror)onerror();removeRunDependency(dep)});handled=true}});if(!handled)finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){Browser.asyncLoad(url,function(byteArray){processData(byteArray)},onerror)}else{processData(url)}},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=function getRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function(dirfd,path){if(path[0]!=="/"){var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);dir=dirstream.path}path=PATH.join2(dir,path)}return path},doStat:function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-ERRNO_CODES.ENOTDIR}throw e}SAFE_HEAP_STORE(buf|0,stat.dev|0,4);SAFE_HEAP_STORE(buf+4|0,0|0,4);SAFE_HEAP_STORE(buf+8|0,stat.ino|0,4);SAFE_HEAP_STORE(buf+12|0,stat.mode|0,4);SAFE_HEAP_STORE(buf+16|0,stat.nlink|0,4);SAFE_HEAP_STORE(buf+20|0,stat.uid|0,4);SAFE_HEAP_STORE(buf+24|0,stat.gid|0,4);SAFE_HEAP_STORE(buf+28|0,stat.rdev|0,4);SAFE_HEAP_STORE(buf+32|0,0|0,4);SAFE_HEAP_STORE(buf+36|0,stat.size|0,4);SAFE_HEAP_STORE(buf+40|0,4096|0,4);SAFE_HEAP_STORE(buf+44|0,stat.blocks|0,4);SAFE_HEAP_STORE(buf+48|0,stat.atime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+52|0,0|0,4);SAFE_HEAP_STORE(buf+56|0,stat.mtime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+60|0,0|0,4);SAFE_HEAP_STORE(buf+64|0,stat.ctime.getTime()/1e3|0|0,4);SAFE_HEAP_STORE(buf+68|0,0|0,4);SAFE_HEAP_STORE(buf+72|0,stat.ino|0,4);return 0},doMsync:function(addr,stream,len,flags){var buffer=new Uint8Array(HEAPU8.subarray(addr,addr+len));FS.msync(stream,buffer,0,len,flags)},doMkdir:function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0},doMknod:function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-ERRNO_CODES.EINVAL}FS.mknod(path,mode,dev);return 0},doReadlink:function(path,buf,bufsize){if(bufsize<=0)return-ERRNO_CODES.EINVAL;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len},doAccess:function(path,amode){if(amode&~7){return-ERRNO_CODES.EINVAL}var node;var lookup=FS.lookupPath(path,{follow:true});node=lookup.node;var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return-ERRNO_CODES.EACCES}return 0},doDup:function(path,flags,suggestFD){var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(path,flags,0,suggestFD,suggestFD).fd},doReadv:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=SAFE_HEAP_LOAD(iov+i*8|0,4,0)|0;var len=SAFE_HEAP_LOAD(iov+(i*8+4)|0,4,0)|0;var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret},doWritev:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=SAFE_HEAP_LOAD(iov+i*8|0,4,0)|0;var len=SAFE_HEAP_LOAD(iov+(i*8+4)|0,4,0)|0;var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret},varargs:0,get:function(varargs){SYSCALLS.varargs+=4;var ret=SAFE_HEAP_LOAD(SYSCALLS.varargs-4|0,4,0)|0;return ret},getStr:function(){var ret=UTF8ToString(SYSCALLS.get());return ret},getStreamFromFD:function(){var stream=FS.getStream(SYSCALLS.get());if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return stream},getSocketFromFD:function(){var socket=SOCKFS.getSocket(SYSCALLS.get());if(!socket)throw new FS.ErrnoError(ERRNO_CODES.EBADF);return socket},getSocketAddress:function(allowNull){var addrp=SYSCALLS.get(),addrlen=SYSCALLS.get();if(allowNull&&addrp===0)return null;var info=__read_sockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info},get64:function(){var low=SYSCALLS.get(),high=SYSCALLS.get();if(low>=0)assert(high===0);else assert(high===-1);return low},getZero:function(){assert(SYSCALLS.get()===0)}};function ___syscall10(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.unlink(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall140(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),offset_high=SYSCALLS.get(),offset_low=SYSCALLS.get(),result=SYSCALLS.get(),whence=SYSCALLS.get();var offset=offset_low;FS.llseek(stream,offset,whence);SAFE_HEAP_STORE(result|0,stream.position|0,4);if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall145(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doReadv(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall146(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),iov=SYSCALLS.get(),iovcnt=SYSCALLS.get();return SYSCALLS.doWritev(stream,iov,iovcnt)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall15(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr(),mode=SYSCALLS.get();FS.chmod(path,mode);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall195(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr(),buf=SYSCALLS.get();return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall197(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),buf=SYSCALLS.get();return SYSCALLS.doStat(FS.stat,stream.path,buf)}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall221(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),cmd=SYSCALLS.get();switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-ERRNO_CODES.EINVAL}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 12:{var arg=SYSCALLS.get();var offset=0;SAFE_HEAP_STORE(arg+offset|0,2|0,2);return 0}case 13:case 14:return 0;case 16:case 8:return-ERRNO_CODES.EINVAL;case 9:___setErrNo(ERRNO_CODES.EINVAL);return-1;default:{return-ERRNO_CODES.EINVAL}}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall38(which,varargs){SYSCALLS.varargs=varargs;try{var old_path=SYSCALLS.getStr(),new_path=SYSCALLS.getStr();FS.rename(old_path,new_path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall40(which,varargs){SYSCALLS.varargs=varargs;try{var path=SYSCALLS.getStr();FS.rmdir(path);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall5(which,varargs){SYSCALLS.varargs=varargs;try{var pathname=SYSCALLS.getStr(),flags=SYSCALLS.get(),mode=SYSCALLS.get();var stream=FS.open(pathname,flags,mode);return stream.fd}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall54(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(),op=SYSCALLS.get();switch(op){case 21509:case 21505:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21519:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;var argp=SYSCALLS.get();SAFE_HEAP_STORE(argp|0,0|0,4);return 0}case 21520:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return-ERRNO_CODES.EINVAL}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}case 21524:{if(!stream.tty)return-ERRNO_CODES.ENOTTY;return 0}default:abort("bad ioctl syscall "+op)}}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall6(which,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD();FS.close(stream);return 0}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___syscall60(which,varargs){SYSCALLS.varargs=varargs;try{var mask=SYSCALLS.get();var old=SYSCALLS.umask;SYSCALLS.umask=mask;return old}catch(e){if(typeof FS==="undefined"||!(e instanceof FS.ErrnoError))abort(e);return-e.errno}}function ___unlock(){}function _emscripten_get_heap_size(){return HEAP8.length}function abortOnCannotGrowMemory(requestedSize){abort("Cannot enlarge memory arrays to size "+requestedSize+" bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value "+HEAP8.length+", (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ")}function emscripten_realloc_buffer(size){var PAGE_MULTIPLE=65536;size=alignUp(size,PAGE_MULTIPLE);var oldSize=buffer.byteLength;try{var result=wasmMemory.grow((size-oldSize)/65536);if(result!==(-1|0)){return buffer=wasmMemory.buffer}else{return null}}catch(e){console.error("emscripten_realloc_buffer: Attempted to grow from "+oldSize+" bytes to "+size+" bytes, but got error: "+e);return null}}function _emscripten_resize_heap(requestedSize){var oldSize=_emscripten_get_heap_size();assert(requestedSize>oldSize);var PAGE_MULTIPLE=65536;var LIMIT=2147483648-PAGE_MULTIPLE;if(requestedSize>LIMIT){err("Cannot enlarge memory, asked to go up to "+requestedSize+" bytes, but the limit is "+LIMIT+" bytes!");return false}var MIN_TOTAL_MEMORY=16777216;var newSize=Math.max(oldSize,MIN_TOTAL_MEMORY);while(newSize<requestedSize){if(newSize<=536870912){newSize=alignUp(2*newSize,PAGE_MULTIPLE)}else{newSize=Math.min(alignUp((3*newSize+2147483648)/4,PAGE_MULTIPLE),LIMIT);if(newSize===oldSize){warnOnce("Cannot ask for more memory since we reached the practical limit in browsers (which is just below 2GB), so the request would have failed. Requesting only "+HEAP8.length)}}}var start=Date.now();var replacement=emscripten_realloc_buffer(newSize);if(!replacement||replacement.byteLength!=newSize){err("Failed to grow the heap from "+oldSize+" bytes to "+newSize+" bytes, not enough memory!");if(replacement){err("Expected to get back a buffer of size "+newSize+" bytes, but instead got back a buffer of size "+replacement.byteLength)}return false}updateGlobalBufferViews();return true}var ___tm_current=22560;var ___tm_timezone=(stringToUTF8("GMT",22608,4),22608);function _gmtime_r(time,tmPtr){var date=new Date((SAFE_HEAP_LOAD(time|0,4,0)|0)*1e3);SAFE_HEAP_STORE(tmPtr|0,date.getUTCSeconds()|0,4);SAFE_HEAP_STORE(tmPtr+4|0,date.getUTCMinutes()|0,4);SAFE_HEAP_STORE(tmPtr+8|0,date.getUTCHours()|0,4);SAFE_HEAP_STORE(tmPtr+12|0,date.getUTCDate()|0,4);SAFE_HEAP_STORE(tmPtr+16|0,date.getUTCMonth()|0,4);SAFE_HEAP_STORE(tmPtr+20|0,date.getUTCFullYear()-1900|0,4);SAFE_HEAP_STORE(tmPtr+24|0,date.getUTCDay()|0,4);SAFE_HEAP_STORE(tmPtr+36|0,0|0,4);SAFE_HEAP_STORE(tmPtr+32|0,0|0,4);var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;SAFE_HEAP_STORE(tmPtr+28|0,yday|0,4);SAFE_HEAP_STORE(tmPtr+40|0,___tm_timezone|0,4);return tmPtr}function _gmtime(time){return _gmtime_r(time,___tm_current)}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest)}function _tzset(){if(_tzset.called)return;_tzset.called=true;SAFE_HEAP_STORE(__get_timezone()|0,(new Date).getTimezoneOffset()*60|0,4);var winter=new Date(2e3,0,1);var summer=new Date(2e3,6,1);SAFE_HEAP_STORE(__get_daylight()|0,Number(winter.getTimezoneOffset()!=summer.getTimezoneOffset())|0,4);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocate(intArrayFromString(winterName),"i8",ALLOC_NORMAL);var summerNamePtr=allocate(intArrayFromString(summerName),"i8",ALLOC_NORMAL);if(summer.getTimezoneOffset()<winter.getTimezoneOffset()){SAFE_HEAP_STORE(__get_tzname()|0,winterNamePtr|0,4);SAFE_HEAP_STORE(__get_tzname()+4|0,summerNamePtr|0,4)}else{SAFE_HEAP_STORE(__get_tzname()|0,summerNamePtr|0,4);SAFE_HEAP_STORE(__get_tzname()+4|0,winterNamePtr|0,4)}}function _mktime(tmPtr){_tzset();var date=new Date((SAFE_HEAP_LOAD(tmPtr+20|0,4,0)|0)+1900,SAFE_HEAP_LOAD(tmPtr+16|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+12|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+8|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr+4|0,4,0)|0,SAFE_HEAP_LOAD(tmPtr|0,4,0)|0,0);var dst=SAFE_HEAP_LOAD(tmPtr+32|0,4,0)|0;var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(2e3,6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){SAFE_HEAP_STORE(tmPtr+32|0,Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)|0,4)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}SAFE_HEAP_STORE(tmPtr+24|0,date.getDay()|0,4);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;SAFE_HEAP_STORE(tmPtr+28|0,yday|0,4);return date.getTime()/1e3|0}function _time(ptr){var ret=Date.now()/1e3|0;if(ptr){SAFE_HEAP_STORE(ptr|0,ret|0,4)}return ret}if(ENVIRONMENT_IS_NODE){_emscripten_get_now=function _emscripten_get_now_actual(){var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(typeof dateNow!=="undefined"){_emscripten_get_now=dateNow}else if(typeof performance==="object"&&performance&&typeof performance["now"]==="function"){_emscripten_get_now=function(){return performance["now"]()}}else{_emscripten_get_now=Date.now}FS.staticInit();if(ENVIRONMENT_IS_NODE){var fs=frozenFs;var NODEJS_PATH=__webpack_require__(3);NODEFS.staticInit()}if(ENVIRONMENT_IS_NODE){var _wrapNodeError=function(func){return function(){try{return func.apply(this,arguments)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code])}}};var VFS=Object.assign({},FS);for(var _key in NODERAWFS)FS[_key]=_wrapNodeError(NODERAWFS[_key])}else{throw new Error("NODERAWFS is currently only supported on Node.js environment.")}function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var decodeBase64=typeof atob==="function"?atob:function(input){var keyStr="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";var output="";var chr1,chr2,chr3;var enc1,enc2,enc3,enc4;var i=0;input=input.replace(/[^A-Za-z0-9\+\/\=]/g,"");do{enc1=keyStr.indexOf(input.charAt(i++));enc2=keyStr.indexOf(input.charAt(i++));enc3=keyStr.indexOf(input.charAt(i++));enc4=keyStr.indexOf(input.charAt(i++));chr1=enc1<<2|enc2>>4;chr2=(enc2&15)<<4|enc3>>2;chr3=(enc3&3)<<6|enc4;output=output+String.fromCharCode(chr1);if(enc3!==64){output=output+String.fromCharCode(chr2)}if(enc4!==64){output=output+String.fromCharCode(chr3)}}while(i<input.length);return output};function intArrayFromBase64(s){if(typeof ENVIRONMENT_IS_NODE==="boolean"&&ENVIRONMENT_IS_NODE){var buf;try{buf=Buffer.from(s,"base64")}catch(_){buf=new Buffer(s,"base64")}return new Uint8Array(buf.buffer,buf.byteOffset,buf.byteLength)}try{var decoded=decodeBase64(s);var bytes=new Uint8Array(decoded.length);for(var i=0;i<decoded.length;++i){bytes[i]=decoded.charCodeAt(i)}return bytes}catch(_){throw new Error("Converting base64 string to bytes failed.")}}function tryParseAsDataURI(filename){if(!isDataURI(filename)){return}return intArrayFromBase64(filename.slice(dataURIPrefix.length))}function nullFunc_ii(x){err("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iii(x){err("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiii(x){err("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiiiii(x){err("Invalid function pointer called with signature 'iiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_iiij(x){err("Invalid function pointer called with signature 'iiij'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_jiiiji(x){err("Invalid function pointer called with signature 'jiiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_jiiji(x){err("Invalid function pointer called with signature 'jiiji'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vi(x){err("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vidi(x){err("Invalid function pointer called with signature 'vidi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}function nullFunc_vii(x){err("Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");err("Build with ASSERTIONS=2 for more info.");abort(x)}var asmGlobalArg={};var asmLibraryArg={"e":setTempRet0,"b":abortStackOverflow,"c":segfault,"d":alignfault,"C":nullFunc_ii,"u":nullFunc_iii,"t":nullFunc_iiii,"s":nullFunc_iiiiii,"r":nullFunc_iiij,"q":nullFunc_jiiiji,"p":nullFunc_jiiji,"O":nullFunc_vi,"N":nullFunc_vidi,"M":nullFunc_vii,"L":___buildEnvironment,"K":___clock_gettime,"i":___lock,"o":___setErrNo,"J":___syscall10,"I":___syscall140,"H":___syscall145,"n":___syscall146,"G":___syscall15,"m":___syscall195,"F":___syscall197,"f":___syscall221,"E":___syscall38,"D":___syscall40,"l":___syscall5,"k":___syscall54,"h":___syscall6,"B":___syscall60,"g":___unlock,"A":_emscripten_get_heap_size,"z":_emscripten_memcpy_big,"y":_emscripten_resize_heap,"x":_gmtime,"w":_mktime,"j":_time,"v":abortOnCannotGrowMemory,"a":DYNAMICTOP_PTR};var asm=Module["asm"](asmGlobalArg,asmLibraryArg,buffer);var real____emscripten_environ_constructor=asm["P"];asm["P"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real____emscripten_environ_constructor.apply(null,arguments)};var real____errno_location=asm["Q"];asm["Q"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real____errno_location.apply(null,arguments)};var real___get_daylight=asm["R"];asm["R"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_daylight.apply(null,arguments)};var real___get_timezone=asm["S"];asm["S"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_timezone.apply(null,arguments)};var real___get_tzname=asm["T"];asm["T"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real___get_tzname.apply(null,arguments)};var real__fflush=asm["U"];asm["U"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__fflush.apply(null,arguments)};var real__free=asm["V"];asm["V"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__free.apply(null,arguments)};var real__llvm_bswap_i32=asm["W"];asm["W"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__llvm_bswap_i32.apply(null,arguments)};var real__malloc=asm["X"];asm["X"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__malloc.apply(null,arguments)};var real__sbrk=asm["Y"];asm["Y"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__sbrk.apply(null,arguments)};var real__zip_close=asm["Z"];asm["Z"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_close.apply(null,arguments)};var real__zip_dir_add=asm["_"];asm["_"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_dir_add.apply(null,arguments)};var real__zip_discard=asm["$"];asm["$"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_discard.apply(null,arguments)};var real__zip_error_init_with_code=asm["aa"];asm["aa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_error_init_with_code.apply(null,arguments)};var real__zip_error_strerror=asm["ba"];asm["ba"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_error_strerror.apply(null,arguments)};var real__zip_fclose=asm["ca"];asm["ca"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fclose.apply(null,arguments)};var real__zip_file_add=asm["da"];asm["da"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_add.apply(null,arguments)};var real__zip_file_get_error=asm["ea"];asm["ea"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_get_error.apply(null,arguments)};var real__zip_file_get_external_attributes=asm["fa"];asm["fa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_get_external_attributes.apply(null,arguments)};var real__zip_file_set_external_attributes=asm["ga"];asm["ga"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_set_external_attributes.apply(null,arguments)};var real__zip_file_set_mtime=asm["ha"];asm["ha"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_file_set_mtime.apply(null,arguments)};var real__zip_fopen=asm["ia"];asm["ia"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fopen.apply(null,arguments)};var real__zip_fopen_index=asm["ja"];asm["ja"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fopen_index.apply(null,arguments)};var real__zip_fread=asm["ka"];asm["ka"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_fread.apply(null,arguments)};var real__zip_get_error=asm["la"];asm["la"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_error.apply(null,arguments)};var real__zip_get_name=asm["ma"];asm["ma"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_name.apply(null,arguments)};var real__zip_get_num_entries=asm["na"];asm["na"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_get_num_entries.apply(null,arguments)};var real__zip_name_locate=asm["oa"];asm["oa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_name_locate.apply(null,arguments)};var real__zip_open=asm["pa"];asm["pa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_open.apply(null,arguments)};var real__zip_open_from_source=asm["qa"];asm["qa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_open_from_source.apply(null,arguments)};var real__zip_source_buffer=asm["ra"];asm["ra"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_buffer.apply(null,arguments)};var real__zip_source_buffer_create=asm["sa"];asm["sa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_buffer_create.apply(null,arguments)};var real__zip_source_free=asm["ta"];asm["ta"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_source_free.apply(null,arguments)};var real__zip_stat=asm["ua"];asm["ua"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_stat.apply(null,arguments)};var real__zip_stat_index=asm["va"];asm["va"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zip_stat_index.apply(null,arguments)};var real__zipstruct_error=asm["wa"];asm["wa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_error.apply(null,arguments)};var real__zipstruct_errorS=asm["xa"];asm["xa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_errorS.apply(null,arguments)};var real__zipstruct_stat=asm["ya"];asm["ya"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat.apply(null,arguments)};var real__zipstruct_statS=asm["za"];asm["za"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_statS.apply(null,arguments)};var real__zipstruct_stat_index=asm["Aa"];asm["Aa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_index.apply(null,arguments)};var real__zipstruct_stat_mtime=asm["Ba"];asm["Ba"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_mtime.apply(null,arguments)};var real__zipstruct_stat_name=asm["Ca"];asm["Ca"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_name.apply(null,arguments)};var real__zipstruct_stat_size=asm["Da"];asm["Da"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real__zipstruct_stat_size.apply(null,arguments)};var real_establishStackSpace=asm["Fa"];asm["Fa"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_establishStackSpace.apply(null,arguments)};var real_stackAlloc=asm["Ga"];asm["Ga"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackAlloc.apply(null,arguments)};var real_stackRestore=asm["Ha"];asm["Ha"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackRestore.apply(null,arguments)};var real_stackSave=asm["Ia"];asm["Ia"]=function(){assert(runtimeInitialized,"you need to wait for the runtime to be ready (e.g. wait for main() to be called)");assert(!runtimeExited,"the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)");return real_stackSave.apply(null,arguments)};var ___emscripten_environ_constructor=Module["___emscripten_environ_constructor"]=asm["P"];var ___errno_location=Module["___errno_location"]=asm["Q"];var __get_daylight=Module["__get_daylight"]=asm["R"];var __get_timezone=Module["__get_timezone"]=asm["S"];var __get_tzname=Module["__get_tzname"]=asm["T"];var _fflush=Module["_fflush"]=asm["U"];var _free=Module["_free"]=asm["V"];var _llvm_bswap_i32=Module["_llvm_bswap_i32"]=asm["W"];var _malloc=Module["_malloc"]=asm["X"];var _sbrk=Module["_sbrk"]=asm["Y"];var _zip_close=Module["_zip_close"]=asm["Z"];var _zip_dir_add=Module["_zip_dir_add"]=asm["_"];var _zip_discard=Module["_zip_discard"]=asm["$"];var _zip_error_init_with_code=Module["_zip_error_init_with_code"]=asm["aa"];var _zip_error_strerror=Module["_zip_error_strerror"]=asm["ba"];var _zip_fclose=Module["_zip_fclose"]=asm["ca"];var _zip_file_add=Module["_zip_file_add"]=asm["da"];var _zip_file_get_error=Module["_zip_file_get_error"]=asm["ea"];var _zip_file_get_external_attributes=Module["_zip_file_get_external_attributes"]=asm["fa"];var _zip_file_set_external_attributes=Module["_zip_file_set_external_attributes"]=asm["ga"];var _zip_file_set_mtime=Module["_zip_file_set_mtime"]=asm["ha"];var _zip_fopen=Module["_zip_fopen"]=asm["ia"];var _zip_fopen_index=Module["_zip_fopen_index"]=asm["ja"];var _zip_fread=Module["_zip_fread"]=asm["ka"];var _zip_get_error=Module["_zip_get_error"]=asm["la"];var _zip_get_name=Module["_zip_get_name"]=asm["ma"];var _zip_get_num_entries=Module["_zip_get_num_entries"]=asm["na"];var _zip_name_locate=Module["_zip_name_locate"]=asm["oa"];var _zip_open=Module["_zip_open"]=asm["pa"];var _zip_open_from_source=Module["_zip_open_from_source"]=asm["qa"];var _zip_source_buffer=Module["_zip_source_buffer"]=asm["ra"];var _zip_source_buffer_create=Module["_zip_source_buffer_create"]=asm["sa"];var _zip_source_free=Module["_zip_source_free"]=asm["ta"];var _zip_stat=Module["_zip_stat"]=asm["ua"];var _zip_stat_index=Module["_zip_stat_index"]=asm["va"];var _zipstruct_error=Module["_zipstruct_error"]=asm["wa"];var _zipstruct_errorS=Module["_zipstruct_errorS"]=asm["xa"];var _zipstruct_stat=Module["_zipstruct_stat"]=asm["ya"];var _zipstruct_statS=Module["_zipstruct_statS"]=asm["za"];var _zipstruct_stat_index=Module["_zipstruct_stat_index"]=asm["Aa"];var _zipstruct_stat_mtime=Module["_zipstruct_stat_mtime"]=asm["Ba"];var _zipstruct_stat_name=Module["_zipstruct_stat_name"]=asm["Ca"];var _zipstruct_stat_size=Module["_zipstruct_stat_size"]=asm["Da"];var establishStackSpace=Module["establishStackSpace"]=asm["Fa"];var stackAlloc=Module["stackAlloc"]=asm["Ga"];var stackRestore=Module["stackRestore"]=asm["Ha"];var stackSave=Module["stackSave"]=asm["Ia"];var dynCall_vi=Module["dynCall_vi"]=asm["Ea"];Module["asm"]=asm;if(!Module["intArrayFromString"])Module["intArrayFromString"]=function(){abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["intArrayToString"])Module["intArrayToString"]=function(){abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["ccall"])Module["ccall"]=function(){abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};Module["cwrap"]=cwrap;if(!Module["setValue"])Module["setValue"]=function(){abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};Module["getValue"]=getValue;if(!Module["allocate"])Module["allocate"]=function(){abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getMemory"])Module["getMemory"]=function(){abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["AsciiToString"])Module["AsciiToString"]=function(){abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToAscii"])Module["stringToAscii"]=function(){abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF8ArrayToString"])Module["UTF8ArrayToString"]=function(){abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF8ToString"])Module["UTF8ToString"]=function(){abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF8Array"])Module["stringToUTF8Array"]=function(){abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF8"])Module["stringToUTF8"]=function(){abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF8"])Module["lengthBytesUTF8"]=function(){abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF16ToString"])Module["UTF16ToString"]=function(){abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF16"])Module["stringToUTF16"]=function(){abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF16"])Module["lengthBytesUTF16"]=function(){abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["UTF32ToString"])Module["UTF32ToString"]=function(){abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stringToUTF32"])Module["stringToUTF32"]=function(){abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["lengthBytesUTF32"])Module["lengthBytesUTF32"]=function(){abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["allocateUTF8"])Module["allocateUTF8"]=function(){abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackTrace"])Module["stackTrace"]=function(){abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPreRun"])Module["addOnPreRun"]=function(){abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnInit"])Module["addOnInit"]=function(){abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPreMain"])Module["addOnPreMain"]=function(){abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnExit"])Module["addOnExit"]=function(){abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addOnPostRun"])Module["addOnPostRun"]=function(){abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeStringToMemory"])Module["writeStringToMemory"]=function(){abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeArrayToMemory"])Module["writeArrayToMemory"]=function(){abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["writeAsciiToMemory"])Module["writeAsciiToMemory"]=function(){abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addRunDependency"])Module["addRunDependency"]=function(){abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["removeRunDependency"])Module["removeRunDependency"]=function(){abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["ENV"])Module["ENV"]=function(){abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["FS"])Module["FS"]=function(){abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["FS_createFolder"])Module["FS_createFolder"]=function(){abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createPath"])Module["FS_createPath"]=function(){abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createDataFile"])Module["FS_createDataFile"]=function(){abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createPreloadedFile"])Module["FS_createPreloadedFile"]=function(){abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createLazyFile"])Module["FS_createLazyFile"]=function(){abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createLink"])Module["FS_createLink"]=function(){abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_createDevice"])Module["FS_createDevice"]=function(){abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["FS_unlink"])Module["FS_unlink"]=function(){abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you")};if(!Module["GL"])Module["GL"]=function(){abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["dynamicAlloc"])Module["dynamicAlloc"]=function(){abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["warnOnce"])Module["warnOnce"]=function(){abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["loadDynamicLibrary"])Module["loadDynamicLibrary"]=function(){abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["loadWebAssemblyModule"])Module["loadWebAssemblyModule"]=function(){abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getLEB"])Module["getLEB"]=function(){abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getFunctionTables"])Module["getFunctionTables"]=function(){abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["alignFunctionTables"])Module["alignFunctionTables"]=function(){abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["registerFunctions"])Module["registerFunctions"]=function(){abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["addFunction"])Module["addFunction"]=function(){abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["removeFunction"])Module["removeFunction"]=function(){abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getFuncWrapper"])Module["getFuncWrapper"]=function(){abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["prettyPrint"])Module["prettyPrint"]=function(){abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["makeBigInt"])Module["makeBigInt"]=function(){abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["dynCall"])Module["dynCall"]=function(){abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getCompilerSetting"])Module["getCompilerSetting"]=function(){abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackSave"])Module["stackSave"]=function(){abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackRestore"])Module["stackRestore"]=function(){abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["stackAlloc"])Module["stackAlloc"]=function(){abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["establishStackSpace"])Module["establishStackSpace"]=function(){abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["print"])Module["print"]=function(){abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["printErr"])Module["printErr"]=function(){abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["getTempRet0"])Module["getTempRet0"]=function(){abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["setTempRet0"])Module["setTempRet0"]=function(){abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["Pointer_stringify"])Module["Pointer_stringify"]=function(){abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["intArrayFromBase64"])Module["intArrayFromBase64"]=function(){abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["tryParseAsDataURI"])Module["tryParseAsDataURI"]=function(){abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")};if(!Module["ALLOC_NORMAL"])Object.defineProperty(Module,"ALLOC_NORMAL",{get:function(){abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_STACK"])Object.defineProperty(Module,"ALLOC_STACK",{get:function(){abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_DYNAMIC"])Object.defineProperty(Module,"ALLOC_DYNAMIC",{get:function(){abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});if(!Module["ALLOC_NONE"])Object.defineProperty(Module,"ALLOC_NONE",{get:function(){abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)")}});function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"])run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};function run(args){args=args||Module["arguments"];if(runDependencies>0){return}writeStackCookie();preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;if(ABORT)return;ensureInitRuntime();preMain();if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();assert(!Module["_main"],'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}checkStackCookie()}Module["run"]=run;var abortDecorators=[];function abort(what){if(Module["onAbort"]){Module["onAbort"](what)}if(what!==undefined){out(what);err(what);what=JSON.stringify(what)}else{what=""}ABORT=true;EXITSTATUS=1;var extra="";var output="abort("+what+") at "+stackTrace()+extra;if(abortDecorators){abortDecorators.forEach(function(decorator){output=decorator(output,what)})}throw output}Module["abort"]=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}Module["noExitRuntime"]=true;run();


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("module");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("assert");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = __webpack_require__(3)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(24)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = require("stream");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */

/*
 * Module dependencies.
 */
const fs = __webpack_require__(2);
const os = __webpack_require__(21);
const path = __webpack_require__(3);
const crypto = __webpack_require__(10);
const _c = fs.constants && os.constants ?
  { fs: fs.constants, os: os.constants } :
  process.binding('constants');
const rimraf = __webpack_require__(22);

/*
 * The working inner variables.
 */
const
  // the random characters to choose from
  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',

  TEMPLATE_PATTERN = /XXXXXX/,

  DEFAULT_TRIES = 3,

  CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR),

  EBADF = _c.EBADF || _c.os.errno.EBADF,
  ENOENT = _c.ENOENT || _c.os.errno.ENOENT,

  DIR_MODE = 448 /* 0o700 */,
  FILE_MODE = 384 /* 0o600 */,

  EXIT = 'exit',

  SIGINT = 'SIGINT',

  // this will hold the objects need to be removed on exit
  _removeObjects = [];

var
  _gracefulCleanup = false;

/**
 * Random name generator based on crypto.
 * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript
 *
 * @param {number} howMany
 * @returns {string} the generated random name
 * @private
 */
function _randomChars(howMany) {
  var
    value = [],
    rnd = null;

  // make sure that we do not fail because we ran out of entropy
  try {
    rnd = crypto.randomBytes(howMany);
  } catch (e) {
    rnd = crypto.pseudoRandomBytes(howMany);
  }

  for (var i = 0; i < howMany; i++) {
    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
  }

  return value.join('');
}

/**
 * Checks whether the `obj` parameter is defined or not.
 *
 * @param {Object} obj
 * @returns {boolean} true if the object is undefined
 * @private
 */
function _isUndefined(obj) {
  return typeof obj === 'undefined';
}

/**
 * Parses the function arguments.
 *
 * This function helps to have optional arguments.
 *
 * @param {(Options|Function)} options
 * @param {Function} callback
 * @returns {Array} parsed arguments
 * @private
 */
function _parseArguments(options, callback) {
  /* istanbul ignore else */
  if (typeof options === 'function') {
    return [{}, options];
  }

  /* istanbul ignore else */
  if (_isUndefined(options)) {
    return [{}, callback];
  }

  return [options, callback];
}

/**
 * Generates a new temporary name.
 *
 * @param {Object} opts
 * @returns {string} the new random name according to opts
 * @private
 */
function _generateTmpName(opts) {

  const tmpDir = _getTmpDir();

  // fail early on missing tmp dir
  if (isBlank(opts.dir) && isBlank(tmpDir)) {
    throw new Error('No tmp dir specified');
  }

  /* istanbul ignore else */
  if (!isBlank(opts.name)) {
    return path.join(opts.dir || tmpDir, opts.name);
  }

  // mkstemps like template
  // opts.template has already been guarded in tmpName() below
  /* istanbul ignore else */
  if (opts.template) {
    var template = opts.template;
    // make sure that we prepend the tmp path if none was given
    /* istanbul ignore else */
    if (path.basename(template) === template)
      template = path.join(opts.dir || tmpDir, template);
    return template.replace(TEMPLATE_PATTERN, _randomChars(6));
  }

  // prefix and postfix
  const name = [
    (isBlank(opts.prefix) ? 'tmp-' : opts.prefix),
    process.pid,
    _randomChars(12),
    (opts.postfix ? opts.postfix : '')
  ].join('');

  return path.join(opts.dir || tmpDir, name);
}

/**
 * Gets a temporary file name.
 *
 * @param {(Options|tmpNameCallback)} options options or callback
 * @param {?tmpNameCallback} callback the callback function
 */
function tmpName(options, callback) {
  var
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1],
    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;

  /* istanbul ignore else */
  if (isNaN(tries) || tries < 0)
    return cb(new Error('Invalid tries'));

  /* istanbul ignore else */
  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
    return cb(new Error('Invalid template provided'));

  (function _getUniqueName() {
    try {
      const name = _generateTmpName(opts);

      // check whether the path exists then retry if needed
      fs.stat(name, function (err) {
        /* istanbul ignore else */
        if (!err) {
          /* istanbul ignore else */
          if (tries-- > 0) return _getUniqueName();

          return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));
        }

        cb(null, name);
      });
    } catch (err) {
      cb(err);
    }
  }());
}

/**
 * Synchronous version of tmpName.
 *
 * @param {Object} options
 * @returns {string} the generated random name
 * @throws {Error} if the options are invalid or could not generate a filename
 */
function tmpNameSync(options) {
  var
    args = _parseArguments(options),
    opts = args[0],
    tries = !isBlank(opts.name) ? 1 : opts.tries || DEFAULT_TRIES;

  /* istanbul ignore else */
  if (isNaN(tries) || tries < 0)
    throw new Error('Invalid tries');

  /* istanbul ignore else */
  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))
    throw new Error('Invalid template provided');

  do {
    const name = _generateTmpName(opts);
    try {
      fs.statSync(name);
    } catch (e) {
      return name;
    }
  } while (tries-- > 0);

  throw new Error('Could not get a unique tmp filename, max tries reached');
}

/**
 * Creates and opens a temporary file.
 *
 * @param {(Options|fileCallback)} options the config options or the callback function
 * @param {?fileCallback} callback
 */
function file(options, callback) {
  var
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create and open the file
    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {
      /* istanbul ignore else */
      if (err) return cb(err);

      if (opts.discardDescriptor) {
        return fs.close(fd, function _discardCallback(err) {
          /* istanbul ignore else */
          if (err) {
            // Low probability, and the file exists, so this could be
            // ignored.  If it isn't we certainly need to unlink the
            // file, and if that fails too its error is more
            // important.
            try {
              fs.unlinkSync(name);
            } catch (e) {
              if (!isENOENT(e)) {
                err = e;
              }
            }
            return cb(err);
          }
          cb(null, name, undefined, _prepareTmpFileRemoveCallback(name, -1, opts));
        });
      }
      /* istanbul ignore else */
      if (opts.detachDescriptor) {
        return cb(null, name, fd, _prepareTmpFileRemoveCallback(name, -1, opts));
      }
      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));
    });
  });
}

/**
 * Synchronous version of file.
 *
 * @param {Options} options
 * @returns {FileSyncObject} object consists of name, fd and removeCallback
 * @throws {Error} if cannot create a file
 */
function fileSync(options) {
  var
    args = _parseArguments(options),
    opts = args[0];

  const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
  const name = tmpNameSync(opts);
  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
  /* istanbul ignore else */
  if (opts.discardDescriptor) {
    fs.closeSync(fd);
    fd = undefined;
  }

  return {
    name: name,
    fd: fd,
    removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts)
  };
}

/**
 * Creates a temporary directory.
 *
 * @param {(Options|dirCallback)} options the options or the callback function
 * @param {?dirCallback} callback
 */
function dir(options, callback) {
  var
    args = _parseArguments(options, callback),
    opts = args[0],
    cb = args[1];

  // gets a temporary filename
  tmpName(opts, function _tmpNameCreated(err, name) {
    /* istanbul ignore else */
    if (err) return cb(err);

    // create the directory
    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {
      /* istanbul ignore else */
      if (err) return cb(err);

      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));
    });
  });
}

/**
 * Synchronous version of dir.
 *
 * @param {Options} options
 * @returns {DirSyncObject} object consists of name and removeCallback
 * @throws {Error} if it cannot create a directory
 */
function dirSync(options) {
  var
    args = _parseArguments(options),
    opts = args[0];

  const name = tmpNameSync(opts);
  fs.mkdirSync(name, opts.mode || DIR_MODE);

  return {
    name: name,
    removeCallback: _prepareTmpDirRemoveCallback(name, opts)
  };
}

/**
 * Removes files asynchronously.
 *
 * @param {Object} fdPath
 * @param {Function} next
 * @private
 */
function _removeFileAsync(fdPath, next) {
  const _handler = function (err) {
    if (err && !isENOENT(err)) {
      // reraise any unanticipated error
      return next(err);
    }
    next();
  }

  if (0 <= fdPath[0])
    fs.close(fdPath[0], function (err) {
      fs.unlink(fdPath[1], _handler);
    });
  else fs.unlink(fdPath[1], _handler);
}

/**
 * Removes files synchronously.
 *
 * @param {Object} fdPath
 * @private
 */
function _removeFileSync(fdPath) {
  try {
    if (0 <= fdPath[0]) fs.closeSync(fdPath[0]);
  } catch (e) {
    // reraise any unanticipated error
    if (!isEBADF(e) && !isENOENT(e)) throw e;
  } finally {
    try {
      fs.unlinkSync(fdPath[1]);
    }
    catch (e) {
      // reraise any unanticipated error
      if (!isENOENT(e)) throw e;
    }
  }
}

/**
 * Prepares the callback for removal of the temporary file.
 *
 * @param {string} name the path of the file
 * @param {number} fd file descriptor
 * @param {Object} opts
 * @returns {fileCallback}
 * @private
 */
function _prepareTmpFileRemoveCallback(name, fd, opts) {
  const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name]);
  const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], removeCallbackSync);

  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return removeCallback;
}

/**
 * Simple wrapper for rimraf.
 *
 * @param {string} dirPath
 * @param {Function} next
 * @private
 */
function _rimrafRemoveDirWrapper(dirPath, next) {
  rimraf(dirPath, next);
}

/**
 * Simple wrapper for rimraf.sync.
 *
 * @param {string} dirPath
 * @private
 */
function _rimrafRemoveDirSyncWrapper(dirPath, next) {
  try {
    return next(null, rimraf.sync(dirPath));
  } catch (err) {
    return next(err);
  }
}

/**
 * Prepares the callback for removal of the temporary directory.
 *
 * @param {string} name
 * @param {Object} opts
 * @returns {Function} the callback
 * @private
 */
function _prepareTmpDirRemoveCallback(name, opts) {
  const removeFunction = opts.unsafeCleanup ? _rimrafRemoveDirWrapper : fs.rmdir.bind(fs);
  const removeFunctionSync = opts.unsafeCleanup ? _rimrafRemoveDirSyncWrapper : fs.rmdirSync.bind(fs);
  const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name);
  const removeCallback = _prepareRemoveCallback(removeFunction, name, removeCallbackSync);
  if (!opts.keep) _removeObjects.unshift(removeCallbackSync);

  return removeCallback;
}

/**
 * Creates a guarded function wrapping the removeFunction call.
 *
 * @param {Function} removeFunction
 * @param {Object} arg
 * @returns {Function}
 * @private
 */
function _prepareRemoveCallback(removeFunction, arg, cleanupCallbackSync) {
  var called = false;

  return function _cleanupCallback(next) {
    next = next || function () {};
    if (!called) {
      const toRemove = cleanupCallbackSync || _cleanupCallback;
      const index = _removeObjects.indexOf(toRemove);
      /* istanbul ignore else */
      if (index >= 0) _removeObjects.splice(index, 1);

      called = true;
      // sync?
      if (removeFunction.length === 1) {
        try {
          removeFunction(arg);
          return next(null);
        }
        catch (err) {
          // if no next is provided and since we are
          // in silent cleanup mode on process exit,
          // we will ignore the error
          return next(err);
        }
      } else return removeFunction(arg, next);
    } else return next(new Error('cleanup callback has already been called'));
  };
}

/**
 * The garbage collector.
 *
 * @private
 */
function _garbageCollector() {
  /* istanbul ignore else */
  if (!_gracefulCleanup) return;

  // the function being called removes itself from _removeObjects,
  // loop until _removeObjects is empty
  while (_removeObjects.length) {
    try {
      _removeObjects[0]();
    } catch (e) {
      // already removed?
    }
  }
}

/**
 * Helper for testing against EBADF to compensate changes made to Node 7.x under Windows.
 */
function isEBADF(error) {
  return isExpectedError(error, -EBADF, 'EBADF');
}

/**
 * Helper for testing against ENOENT to compensate changes made to Node 7.x under Windows.
 */
function isENOENT(error) {
  return isExpectedError(error, -ENOENT, 'ENOENT');
}

/**
 * Helper to determine whether the expected error code matches the actual code and errno,
 * which will differ between the supported node versions.
 *
 * - Node >= 7.0:
 *   error.code {string}
 *   error.errno {string|number} any numerical value will be negated
 *
 * - Node >= 6.0 < 7.0:
 *   error.code {string}
 *   error.errno {number} negated
 *
 * - Node >= 4.0 < 6.0: introduces SystemError
 *   error.code {string}
 *   error.errno {number} negated
 *
 * - Node >= 0.10 < 4.0:
 *   error.code {number} negated
 *   error.errno n/a
 */
function isExpectedError(error, code, errno) {
  return error.code === code || error.code === errno;
}

/**
 * Helper which determines whether a string s is blank, that is undefined, or empty or null.
 *
 * @private
 * @param {string} s
 * @returns {Boolean} true whether the string s is blank, false otherwise
 */
function isBlank(s) {
  return s === null || s === undefined || !s.trim();
}

/**
 * Sets the graceful cleanup.
 */
function setGracefulCleanup() {
  _gracefulCleanup = true;
}

/**
 * Returns the currently configured tmp dir from os.tmpdir().
 *
 * @private
 * @returns {string} the currently configured tmp dir
 */
function _getTmpDir() {
  return os.tmpdir();
}

/**
 * If there are multiple different versions of tmp in place, make sure that
 * we recognize the old listeners.
 *
 * @param {Function} listener
 * @private
 * @returns {Boolean} true whether listener is a legacy listener
 */
function _is_legacy_listener(listener) {
  return (listener.name === '_exit' || listener.name === '_uncaughtExceptionThrown')
    && listener.toString().indexOf('_garbageCollector();') > -1;
}

/**
 * Safely install SIGINT listener.
 *
 * NOTE: this will only work on OSX and Linux.
 *
 * @private
 */
function _safely_install_sigint_listener() {

  const listeners = process.listeners(SIGINT);
  const existingListeners = [];
  for (let i = 0, length = listeners.length; i < length; i++) {
    const lstnr = listeners[i];
    /* istanbul ignore else */
    if (lstnr.name === '_tmp$sigint_listener') {
      existingListeners.push(lstnr);
      process.removeListener(SIGINT, lstnr);
    }
  }
  process.on(SIGINT, function _tmp$sigint_listener(doExit) {
    for (let i = 0, length = existingListeners.length; i < length; i++) {
      // let the existing listener do the garbage collection (e.g. jest sandbox)
      try {
        existingListeners[i](false);
      } catch (err) {
        // ignore
      }
    }
    try {
      // force the garbage collector even it is called again in the exit listener
      _garbageCollector();
    } finally {
      if (!!doExit) {
        process.exit(0);
      }
    }
  });
}

/**
 * Safely install process exit listener.
 *
 * @private
 */
function _safely_install_exit_listener() {
  const listeners = process.listeners(EXIT);

  // collect any existing listeners
  const existingListeners = [];
  for (let i = 0, length = listeners.length; i < length; i++) {
    const lstnr = listeners[i];
    /* istanbul ignore else */
    // TODO: remove support for legacy listeners once release 1.0.0 is out
    if (lstnr.name === '_tmp$safe_listener' || _is_legacy_listener(lstnr)) {
      // we must forget about the uncaughtException listener, hopefully it is ours
      if (lstnr.name !== '_uncaughtExceptionThrown') {
        existingListeners.push(lstnr);
      }
      process.removeListener(EXIT, lstnr);
    }
  }
  // TODO: what was the data parameter good for?
  process.addListener(EXIT, function _tmp$safe_listener(data) {
    for (let i = 0, length = existingListeners.length; i < length; i++) {
      // let the existing listener do the garbage collection (e.g. jest sandbox)
      try {
        existingListeners[i](data);
      } catch (err) {
        // ignore
      }
    }
    _garbageCollector();
  });
}

_safely_install_exit_listener();
_safely_install_sigint_listener();

/**
 * Configuration options.
 *
 * @typedef {Object} Options
 * @property {?number} tries the number of tries before give up the name generation
 * @property {?string} template the "mkstemp" like filename template
 * @property {?string} name fix name
 * @property {?string} dir the tmp directory to use
 * @property {?string} prefix prefix for the generated name
 * @property {?string} postfix postfix for the generated name
 * @property {?boolean} unsafeCleanup recursively removes the created temporary directory, even when it's not empty
 */

/**
 * @typedef {Object} FileSyncObject
 * @property {string} name the name of the file
 * @property {string} fd the file descriptor
 * @property {fileCallback} removeCallback the callback function to remove the file
 */

/**
 * @typedef {Object} DirSyncObject
 * @property {string} name the name of the directory
 * @property {fileCallback} removeCallback the callback function to remove the directory
 */

/**
 * @callback tmpNameCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 */

/**
 * @callback fileCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {number} fd the file descriptor
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * @callback dirCallback
 * @param {?Error} err the error object if anything goes wrong
 * @param {string} name the temporary file name
 * @param {cleanupCallback} fn the cleanup callback function
 */

/**
 * Removes the temporary created file or directory.
 *
 * @callback cleanupCallback
 * @param {simpleCallback} [next] function to call after entry was removed
 */

/**
 * Callback function for function composition.
 * @see {@link https://github.com/raszi/node-tmp/issues/57|raszi/node-tmp#57}
 *
 * @callback simpleCallback
 */

// exporting all the needed methods

// evaluate os.tmpdir() lazily, mainly for simplifying testing but it also will
// allow users to reconfigure the temporary directory
Object.defineProperty(module.exports, 'tmpdir', {
  enumerable: true,
  configurable: false,
  get: function () {
    return _getTmpDir();
  }
});

module.exports.dir = dir;
module.exports.dirSync = dirSync;

module.exports.file = file;
module.exports.fileSync = fileSync;

module.exports.tmpName = tmpName;
module.exports.tmpNameSync = tmpNameSync;

module.exports.setGracefulCleanup = setGracefulCleanup;


/***/ }),
/* 10 */
/***/ (function(module, exports) {

module.exports = require("crypto");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var fs = __webpack_require__(2)
var rp = __webpack_require__(12)
var minimatch = __webpack_require__(6)
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(27)
var EE = __webpack_require__(28).EventEmitter
var path = __webpack_require__(3)
var assert = __webpack_require__(5)
var isAbsolute = __webpack_require__(7)
var globSync = __webpack_require__(29)
var common = __webpack_require__(13)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(30)
var util = __webpack_require__(4)
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(15)

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(2)
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(23)

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

exports.alphasort = alphasort
exports.alphasorti = alphasorti
exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path = __webpack_require__(3)
var minimatch = __webpack_require__(6)
var isAbsolute = __webpack_require__(7)
var Minimatch = minimatch.Minimatch

function alphasorti (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti : alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(14)
module.exports = wrappy(once)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = require("string_decoder");

/***/ }),
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */
/***/ (function(module, exports) {

module.exports = require("os");

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = rimraf
rimraf.sync = rimrafSync

var assert = __webpack_require__(5)
var path = __webpack_require__(3)
var fs = __webpack_require__(2)
var glob = __webpack_require__(11)
var _0666 = parseInt('666', 8)

var defaultGlobOpts = {
  nosort: true,
  silent: true
}

// for EMFILE handling
var timeout = 0

var isWindows = (process.platform === "win32")

function defaults (options) {
  var methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(function(m) {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
  options.emfileWait = options.emfileWait || 1000
  if (options.glob === false) {
    options.disableGlob = true
  }
  options.disableGlob = options.disableGlob || false
  options.glob = options.glob || defaultGlobOpts
}

function rimraf (p, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert.equal(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  var busyTries = 0
  var errState = null
  var n = 0

  if (options.disableGlob || !glob.hasMagic(p))
    return afterGlob(null, [p])

  options.lstat(p, function (er, stat) {
    if (!er)
      return afterGlob(null, [p])

    glob(p, options.glob, afterGlob)
  })

  function next (er) {
    errState = errState || er
    if (--n === 0)
      cb(errState)
  }

  function afterGlob (er, results) {
    if (er)
      return cb(er)

    n = results.length
    if (n === 0)
      return cb()

    results.forEach(function (p) {
      rimraf_(p, options, function CB (er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") &&
              busyTries < options.maxBusyTries) {
            busyTries ++
            var time = busyTries * 100
            // try again, with the same exact callback as this one.
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, time)
          }

          // this one won't happen if graceful-fs is used.
          if (er.code === "EMFILE" && timeout < options.emfileWait) {
            return setTimeout(function () {
              rimraf_(p, options, CB)
            }, timeout ++)
          }

          // already gone
          if (er.code === "ENOENT") er = null
        }

        timeout = 0
        next(er)
      })
    })
  }
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, function (er, st) {
    if (er && er.code === "ENOENT")
      return cb(null)

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === "EPERM" && isWindows)
      fixWinEPERM(p, options, er, cb)

    if (st && st.isDirectory())
      return rmdir(p, options, er, cb)

    options.unlink(p, function (er) {
      if (er) {
        if (er.code === "ENOENT")
          return cb(null)
        if (er.code === "EPERM")
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        if (er.code === "EISDIR")
          return rmdir(p, options, er, cb)
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')
  if (er)
    assert(er instanceof Error)

  options.chmod(p, _0666, function (er2) {
    if (er2)
      cb(er2.code === "ENOENT" ? null : er)
    else
      options.stat(p, function(er3, stats) {
        if (er3)
          cb(er3.code === "ENOENT" ? null : er)
        else if (stats.isDirectory())
          rmdir(p, options, er, cb)
        else
          options.unlink(p, cb)
      })
  })
}

function fixWinEPERMSync (p, options, er) {
  assert(p)
  assert(options)
  if (er)
    assert(er instanceof Error)

  try {
    options.chmodSync(p, _0666)
  } catch (er2) {
    if (er2.code === "ENOENT")
      return
    else
      throw er
  }

  try {
    var stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === "ENOENT")
      return
    else
      throw er
  }

  if (stats.isDirectory())
    rmdirSync(p, options, er)
  else
    options.unlinkSync(p)
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, function (er) {
    if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
      rmkids(p, options, cb)
    else if (er && er.code === "ENOTDIR")
      cb(originalEr)
    else
      cb(er)
  })
}

function rmkids(p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, function (er, files) {
    if (er)
      return cb(er)
    var n = files.length
    if (n === 0)
      return options.rmdir(p, cb)
    var errState
    files.forEach(function (f) {
      rimraf(path.join(p, f), options, function (er) {
        if (errState)
          return
        if (er)
          return cb(errState = er)
        if (--n === 0)
          options.rmdir(p, cb)
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.equal(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.equal(typeof options, 'object', 'rimraf: options should be object')

  var results

  if (options.disableGlob || !glob.hasMagic(p)) {
    results = [p]
  } else {
    try {
      options.lstatSync(p)
      results = [p]
    } catch (er) {
      results = glob.sync(p, options.glob)
    }
  }

  if (!results.length)
    return

  for (var i = 0; i < results.length; i++) {
    var p = results[i]

    try {
      var st = options.lstatSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return

      // Windows can EPERM on stat.  Life is suffering.
      if (er.code === "EPERM" && isWindows)
        fixWinEPERMSync(p, options, er)
    }

    try {
      // sunos lets the root user unlink directories, which is... weird.
      if (st && st.isDirectory())
        rmdirSync(p, options, null)
      else
        options.unlinkSync(p)
    } catch (er) {
      if (er.code === "ENOENT")
        return
      if (er.code === "EPERM")
        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
      if (er.code !== "EISDIR")
        throw er

      rmdirSync(p, options, er)
    }
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)
  if (originalEr)
    assert(originalEr instanceof Error)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === "ENOENT")
      return
    if (er.code === "ENOTDIR")
      throw originalEr
    if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
      rmkidsSync(p, options)
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(function (f) {
    rimrafSync(path.join(p, f), options)
  })

  // We only end up here once we got ENOTEMPTY at least once, and
  // at this point, we are guaranteed to have removed all the kids.
  // So, we know that it won't be ENOENT or ENOTDIR or anything else.
  // try really hard to delete stuff on windows, because it has a
  // PROFOUNDLY annoying habit of not closing handles promptly when
  // files are deleted, resulting in spurious ENOTEMPTY errors.
  var retries = isWindows ? 100 : 1
  var i = 0
  do {
    var threw = true
    try {
      var ret = options.rmdirSync(p, options)
      threw = false
      return ret
    } finally {
      if (++i < retries && threw)
        continue
    }
  } while (true)
}


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(3);
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(2);

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

var concatMap = __webpack_require__(25);
var balanced = __webpack_require__(26);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 27 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = require("events");

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = globSync
globSync.GlobSync = GlobSync

var fs = __webpack_require__(2)
var rp = __webpack_require__(12)
var minimatch = __webpack_require__(6)
var Minimatch = minimatch.Minimatch
var Glob = __webpack_require__(11).Glob
var util = __webpack_require__(4)
var path = __webpack_require__(3)
var assert = __webpack_require__(5)
var isAbsolute = __webpack_require__(7)
var common = __webpack_require__(13)
var alphasort = common.alphasort
var alphasorti = common.alphasorti
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var wrappy = __webpack_require__(14)
var reqs = Object.create(null)
var once = __webpack_require__(15)

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(2);
var external_fs_default = /*#__PURE__*/__webpack_require__.n(external_fs_);

// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(3);
var external_path_default = /*#__PURE__*/__webpack_require__.n(external_path_);

// CONCATENATED MODULE: ../yarnpkg-fslib/sources/path.ts

const PortablePath = {
  root: `/`,
  dot: `.`
};
const npath = Object.create(external_path_default.a);
const ppath = Object.create(external_path_default.a.posix);

const contains = function (pathUtils, from, to) {
  from = pathUtils.normalize(from);
  to = pathUtils.normalize(to);
  if (from === to) return `.`;
  if (!from.endsWith(pathUtils.sep)) from = from + pathUtils.sep;

  if (to.startsWith(from)) {
    return to.slice(from.length);
  } else {
    return null;
  }
};

npath.fromPortablePath = fromPortablePath;
npath.toPortablePath = toPortablePath;

npath.contains = (from, to) => contains(npath, from, to);

ppath.contains = (from, to) => contains(ppath, from, to);

const WINDOWS_PATH_REGEXP = /^[a-zA-Z]:.*$/;
const PORTABLE_PATH_REGEXP = /^\/[a-zA-Z]:.*$/; // Path should look like "/N:/berry/scripts/plugin-pack.js"
// And transform to "N:\berry\scripts\plugin-pack.js"

function fromPortablePath(p) {
  if (process.platform !== 'win32') return p;
  return p.match(PORTABLE_PATH_REGEXP) ? p.substring(1).replace(/\//g, `\\`) : p;
} // Path should look like "N:/berry/scripts/plugin-pack.js"
// And transform to "/N:/berry/scripts/plugin-pack.js"


function toPortablePath(p) {
  if (process.platform !== 'win32') return p;
  return (p.match(WINDOWS_PATH_REGEXP) ? `/${p}` : p).replace(/\\/g, `/`);
}

function convertPath(targetPathUtils, sourcePath) {
  return targetPathUtils === npath ? fromPortablePath(sourcePath) : toPortablePath(sourcePath);
}
function toFilename(filename) {
  if (npath.parse(filename).dir !== '' || ppath.parse(filename).dir !== '') throw new Error(`Invalid filename: "${filename}"`);
  return filename;
}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/FakeFS.ts


class FakeFS_FakeFS {
  constructor(pathUtils) {
    this.pathUtils = pathUtils;
  }

  async removePromise(p) {
    let stat;

    try {
      stat = await this.lstatPromise(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      for (const entry of await this.readdirPromise(p)) await this.removePromise(this.pathUtils.resolve(p, entry)); // 5 gives 1s worth of retries at worst


      for (let t = 0; t < 5; ++t) {
        try {
          await this.rmdirPromise(p);
          break;
        } catch (error) {
          if (error.code === `EBUSY` || error.code === `ENOTEMPTY`) {
            await new Promise(resolve => setTimeout(resolve, t * 100));
            continue;
          } else {
            throw error;
          }
        }
      }
    } else {
      await this.unlinkPromise(p);
    }
  }

  removeSync(p) {
    let stat;

    try {
      stat = this.lstatSync(p);
    } catch (error) {
      if (error.code === `ENOENT`) {
        return;
      } else {
        throw error;
      }
    }

    if (stat.isDirectory()) {
      for (const entry of this.readdirSync(p)) this.removeSync(this.pathUtils.resolve(p, entry));

      this.rmdirSync(p);
    } else {
      this.unlinkSync(p);
    }
  }

  async mkdirpPromise(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          await this.mkdirPromise(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) await this.chmodPromise(subPath, chmod);

        if (utimes != null) {
          await this.utimesPromise(subPath, utimes[0], utimes[1]);
        }
      }
    }
  }

  mkdirpSync(p, {
    chmod,
    utimes
  } = {}) {
    p = this.resolve(p);
    if (p === this.pathUtils.dirname(p)) return;
    const parts = p.split(this.pathUtils.sep);

    for (let u = 2; u <= parts.length; ++u) {
      const subPath = parts.slice(0, u).join(this.pathUtils.sep);

      if (!this.existsSync(subPath)) {
        try {
          this.mkdirSync(subPath);
        } catch (error) {
          if (error.code === `EEXIST`) {
            continue;
          } else {
            throw error;
          }
        }

        if (chmod != null) this.chmodSync(subPath, chmod);

        if (utimes != null) {
          this.utimesSync(subPath, utimes[0], utimes[1]);
        }
      }
    }
  }

  async copyPromise(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = await baseFs.lstatPromise(source);
    const exists = await this.existsSync(destination);

    if (stat.isDirectory()) {
      await this.mkdirpPromise(destination);
      const directoryListing = await baseFs.readdirPromise(source);
      await Promise.all(directoryListing.map(entry => {
        return this.copyPromise(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }));
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) await this.removePromise(destination);
        const content = await baseFs.readFilePromise(source);
        await this.writeFilePromise(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) await this.removePromise(destination);
        const target = await baseFs.readlinkPromise(source);
        await this.symlinkPromise(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    await this.chmodPromise(destination, mode);
  }

  copySync(destination, source, {
    baseFs = this,
    overwrite = true
  } = {}) {
    const stat = baseFs.lstatSync(source);
    const exists = this.existsSync(destination);

    if (stat.isDirectory()) {
      this.mkdirpSync(destination);
      const directoryListing = baseFs.readdirSync(source);

      for (const entry of directoryListing) {
        this.copySync(this.pathUtils.join(destination, entry), baseFs.pathUtils.join(source, entry), {
          baseFs,
          overwrite
        });
      }
    } else if (stat.isFile()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const content = baseFs.readFileSync(source);
        this.writeFileSync(destination, content);
      }
    } else if (stat.isSymbolicLink()) {
      if (!exists || overwrite) {
        if (exists) this.removeSync(destination);
        const target = baseFs.readlinkSync(source);
        this.symlinkSync(convertPath(this.pathUtils, target), destination);
      }
    } else {
      throw new Error(`Unsupported file type (file: ${source}, mode: 0o${stat.mode.toString(8).padStart(6, `0`)})`);
    }

    const mode = stat.mode & 0o777;
    this.chmodSync(destination, mode);
  }

  async changeFilePromise(p, content) {
    try {
      const current = await this.readFilePromise(p, `utf8`);

      if (current === content) {
        return;
      }
    } catch (error) {// ignore errors, no big deal
    }

    await this.writeFilePromise(p, content);
  }

  changeFileSync(p, content) {
    try {
      const current = this.readFileSync(p, `utf8`);

      if (current === content) {
        return;
      }
    } catch (error) {// ignore errors, no big deal
    }

    this.writeFileSync(p, content);
  }

  async movePromise(fromP, toP) {
    try {
      await this.renamePromise(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        await this.copyPromise(toP, fromP);
        await this.removePromise(fromP);
      } else {
        throw error;
      }
    }
  }

  moveSync(fromP, toP) {
    try {
      this.renameSync(fromP, toP);
    } catch (error) {
      if (error.code === `EXDEV`) {
        this.copySync(toP, fromP);
        this.removeSync(fromP);
      } else {
        throw error;
      }
    }
  }

  async lockPromise(affectedPath, callback) {
    const lockPath = `${affectedPath}.flock`;
    const interval = 1000 / 60;
    const startTime = Date.now();
    let fd = null; // Even when we detect that a lock file exists, we still look inside to see
    // whether the pid that created it is still alive. It's not foolproof
    // (there are false positive), but there are no false negative and that's
    // all that matters in 99% of the cases.

    const isAlive = async () => {
      let pid;

      try {
        [pid] = await this.readJsonPromise(lockPath);
      } catch (error) {
        // If we can't read the file repeatedly, we assume the process was
        // aborted before even writing finishing writing the payload.
        return Date.now() - startTime < 500;
      }

      try {
        // "As a special case, a signal of 0 can be used to test for the
        // existence of a process" - so we check whether it's alive.
        process.kill(pid, 0);
        return true;
      } catch (error) {
        return false;
      }
    };

    while (fd === null) {
      try {
        fd = await this.openPromise(lockPath, `wx`);
      } catch (error) {
        if (error.code === `EEXIST`) {
          if (!(await isAlive())) {
            try {
              await this.unlinkPromise(lockPath);
              continue;
            } catch (error) {// No big deal if we can't remove it. Just fallback to wait for
              // it to be eventually released by its owner.
            }
          }

          if (Date.now() - startTime < 60 * 1000) {
            await new Promise(resolve => setTimeout(resolve, interval));
          } else {
            throw new Error(`Couldn't acquire a lock in a reasonable time (via ${lockPath})`);
          }
        } else {
          throw error;
        }
      }
    }

    await this.writePromise(fd, JSON.stringify([process.pid]));

    try {
      return await callback();
    } finally {
      await this.closePromise(fd);
      await this.unlinkPromise(lockPath);
    }
  }

  async readJsonPromise(p) {
    const content = await this.readFilePromise(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async readJsonSync(p) {
    const content = this.readFileSync(p, `utf8`);

    try {
      return JSON.parse(content);
    } catch (error) {
      error.message += ` (in ${p})`;
      throw error;
    }
  }

  async writeJsonPromise(p, data) {
    return await this.writeFilePromise(p, `${JSON.stringify(data, null, 2)}\n`);
  }

  writeJsonSync(p, data) {
    return this.writeFileSync(p, `${JSON.stringify(data, null, 2)}\n`);
  }

}
;
class FakeFS_BasePortableFakeFS extends FakeFS_FakeFS {
  constructor() {
    super(ppath);
  }

  resolve(p) {
    return this.pathUtils.resolve(PortablePath.root, p);
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/NodeFS.ts



class NodeFS_NodeFS extends FakeFS_BasePortableFakeFS {
  constructor(realFs = external_fs_default.a) {
    super();
    this.realFs = realFs;
  }

  getRealPath() {
    return PortablePath.root;
  }

  async openPromise(p, flags, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.open(npath.fromPortablePath(p), flags, mode, this.makeCallback(resolve, reject));
    });
  }

  openSync(p, flags, mode) {
    return this.realFs.openSync(npath.fromPortablePath(p), flags, mode);
  }

  async readPromise(fd, buffer, offset = 0, length = 0, position = -1) {
    return await new Promise((resolve, reject) => {
      this.realFs.read(fd, buffer, offset, length, position, (error, bytesRead) => {
        if (error) {
          reject(error);
        } else {
          resolve(bytesRead);
        }
      });
    });
  }

  readSync(fd, buffer, offset, length, position) {
    return this.realFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    return await new Promise((resolve, reject) => {
      if (typeof buffer === `string`) {
        return this.realFs.write(fd, buffer, offset, this.makeCallback(resolve, reject));
      } else {
        return this.realFs.write(fd, buffer, offset, length, position, this.makeCallback(resolve, reject));
      }
    });
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.realFs.writeSync(fd, buffer, offset);
    } else {
      return this.realFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    await new Promise((resolve, reject) => {
      this.realFs.close(fd, this.makeCallback(resolve, reject));
    });
  }

  closeSync(fd) {
    this.realFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createReadStream(realPath, opts);
  }

  createWriteStream(p, opts) {
    const realPath = p !== null ? npath.fromPortablePath(p) : p;
    return this.realFs.createWriteStream(realPath, opts);
  }

  async realpathPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.realpath(npath.fromPortablePath(p), {}, this.makeCallback(resolve, reject));
    }).then(path => {
      return npath.toPortablePath(path);
    });
  }

  realpathSync(p) {
    return npath.toPortablePath(this.realFs.realpathSync(npath.fromPortablePath(p), {}));
  }

  async existsPromise(p) {
    return await new Promise(resolve => {
      this.realFs.exists(npath.fromPortablePath(p), resolve);
    });
  }

  accessSync(p, mode) {
    return this.realFs.accessSync(npath.fromPortablePath(p), mode);
  }

  async accessPromise(p, mode) {
    return await new Promise((resolve, reject) => {
      this.realFs.access(npath.fromPortablePath(p), mode, this.makeCallback(resolve, reject));
    });
  }

  existsSync(p) {
    return this.realFs.existsSync(npath.fromPortablePath(p));
  }

  async statPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.stat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  statSync(p) {
    return this.realFs.statSync(npath.fromPortablePath(p));
  }

  async lstatPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.lstat(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  lstatSync(p) {
    return this.realFs.lstatSync(npath.fromPortablePath(p));
  }

  async chmodPromise(p, mask) {
    return await new Promise((resolve, reject) => {
      this.realFs.chmod(npath.fromPortablePath(p), mask, this.makeCallback(resolve, reject));
    });
  }

  chmodSync(p, mask) {
    return this.realFs.chmodSync(npath.fromPortablePath(p), mask);
  }

  async renamePromise(oldP, newP) {
    return await new Promise((resolve, reject) => {
      this.realFs.rename(npath.fromPortablePath(oldP), npath.fromPortablePath(newP), this.makeCallback(resolve, reject));
    });
  }

  renameSync(oldP, newP) {
    return this.realFs.renameSync(npath.fromPortablePath(oldP), npath.fromPortablePath(newP));
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    return await new Promise((resolve, reject) => {
      this.realFs.copyFile(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags, this.makeCallback(resolve, reject));
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.realFs.copyFileSync(npath.fromPortablePath(sourceP), npath.fromPortablePath(destP), flags);
  }

  async appendFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.appendFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.appendFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  appendFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.appendFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.appendFileSync(fsNativePath, content);
    }
  }

  async writeFilePromise(p, content, opts) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

      if (opts) {
        this.realFs.writeFile(fsNativePath, content, opts, this.makeCallback(resolve, reject));
      } else {
        this.realFs.writeFile(fsNativePath, content, this.makeCallback(resolve, reject));
      }
    });
  }

  writeFileSync(p, content, opts) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;

    if (opts) {
      this.realFs.writeFileSync(fsNativePath, content, opts);
    } else {
      this.realFs.writeFileSync(fsNativePath, content);
    }
  }

  async unlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.unlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  unlinkSync(p) {
    return this.realFs.unlinkSync(npath.fromPortablePath(p));
  }

  async utimesPromise(p, atime, mtime) {
    return await new Promise((resolve, reject) => {
      this.realFs.utimes(npath.fromPortablePath(p), atime, mtime, this.makeCallback(resolve, reject));
    });
  }

  utimesSync(p, atime, mtime) {
    this.realFs.utimesSync(npath.fromPortablePath(p), atime, mtime);
  }

  async mkdirPromise(p, opts) {
    return await new Promise((resolve, reject) => {
      this.realFs.mkdir(npath.fromPortablePath(p), opts, this.makeCallback(resolve, reject));
    });
  }

  mkdirSync(p, opts) {
    return this.realFs.mkdirSync(npath.fromPortablePath(p), opts);
  }

  async rmdirPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.rmdir(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    });
  }

  rmdirSync(p) {
    return this.realFs.rmdirSync(npath.fromPortablePath(p));
  }

  async symlinkPromise(target, p) {
    const type = target.endsWith(`/`) ? `dir` : `file`;
    return await new Promise((resolve, reject) => {
      this.realFs.symlink(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type, this.makeCallback(resolve, reject));
    });
  }

  symlinkSync(target, p) {
    const type = target.endsWith(`/`) ? `dir` : `file`;
    return this.realFs.symlinkSync(npath.fromPortablePath(target.replace(/\/+$/, ``)), npath.fromPortablePath(p), type);
  }

  async readFilePromise(p, encoding) {
    return await new Promise((resolve, reject) => {
      const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
      this.realFs.readFile(fsNativePath, encoding, this.makeCallback(resolve, reject));
    });
  }

  readFileSync(p, encoding) {
    const fsNativePath = typeof p === `string` ? npath.fromPortablePath(p) : p;
    return this.realFs.readFileSync(fsNativePath, encoding);
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await new Promise((resolve, reject) => {
      if (withFileTypes) {
        this.realFs.readdir(npath.fromPortablePath(p), {
          withFileTypes: true
        }, this.makeCallback(resolve, reject));
      } else {
        this.realFs.readdir(npath.fromPortablePath(p), this.makeCallback(value => resolve(value), reject));
      }
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    if (withFileTypes) {
      return this.realFs.readdirSync(npath.fromPortablePath(p), {
        withFileTypes: true
      });
    } else {
      return this.realFs.readdirSync(npath.fromPortablePath(p));
    }
  }

  async readlinkPromise(p) {
    return await new Promise((resolve, reject) => {
      this.realFs.readlink(npath.fromPortablePath(p), this.makeCallback(resolve, reject));
    }).then(path => {
      return npath.toPortablePath(path);
    });
  }

  readlinkSync(p) {
    return npath.toPortablePath(this.realFs.readlinkSync(npath.fromPortablePath(p)));
  }

  watch(p, a, b) {
    return this.realFs.watch(npath.fromPortablePath(p), // @ts-ignore
    a, b);
  }

  makeCallback(resolve, reject) {
    return (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    };
  }

}
// EXTERNAL MODULE: ../yarnpkg-libzip/sources/libzip.js
var libzip = __webpack_require__(0);
var libzip_default = /*#__PURE__*/__webpack_require__.n(libzip);

// CONCATENATED MODULE: ../yarnpkg-libzip/sources/index.ts

const number64 = [`number`, `number`]; // eslint-disable-next-line arca/no-default-export

/* harmony default export */ var sources = ({
  // Those are getters because they can change after memory growth
  get HEAP8() {
    return libzip_default.a.HEAP8;
  },

  get HEAPU8() {
    return libzip_default.a.HEAPU8;
  },

  ZIP_CHECKCONS: 4,
  ZIP_CREATE: 1,
  ZIP_EXCL: 2,
  ZIP_TRUNCATE: 8,
  ZIP_RDONLY: 16,
  ZIP_FL_OVERWRITE: 8192,
  ZIP_OPSYS_DOS: 0x00,
  ZIP_OPSYS_AMIGA: 0x01,
  ZIP_OPSYS_OPENVMS: 0x02,
  ZIP_OPSYS_UNIX: 0x03,
  ZIP_OPSYS_VM_CMS: 0x04,
  ZIP_OPSYS_ATARI_ST: 0x05,
  ZIP_OPSYS_OS_2: 0x06,
  ZIP_OPSYS_MACINTOSH: 0x07,
  ZIP_OPSYS_Z_SYSTEM: 0x08,
  ZIP_OPSYS_CPM: 0x09,
  ZIP_OPSYS_WINDOWS_NTFS: 0x0a,
  ZIP_OPSYS_MVS: 0x0b,
  ZIP_OPSYS_VSE: 0x0c,
  ZIP_OPSYS_ACORN_RISC: 0x0d,
  ZIP_OPSYS_VFAT: 0x0e,
  ZIP_OPSYS_ALTERNATE_MVS: 0x0f,
  ZIP_OPSYS_BEOS: 0x10,
  ZIP_OPSYS_TANDEM: 0x11,
  ZIP_OPSYS_OS_400: 0x12,
  ZIP_OPSYS_OS_X: 0x13,
  uint08S: libzip_default.a._malloc(1),
  uint16S: libzip_default.a._malloc(2),
  uint32S: libzip_default.a._malloc(4),
  uint64S: libzip_default.a._malloc(8),
  malloc: libzip_default.a._malloc,
  free: libzip_default.a._free,
  getValue: libzip_default.a.getValue,
  open: libzip_default.a.cwrap(`zip_open`, `number`, [`string`, `number`, `number`]),
  openFromSource: libzip_default.a.cwrap(`zip_open_from_source`, `number`, [`number`, `number`, `number`]),
  close: libzip_default.a.cwrap(`zip_close`, `number`, [`number`]),
  discard: libzip_default.a.cwrap(`zip_discard`, null, [`number`]),
  getError: libzip_default.a.cwrap(`zip_get_error`, `number`, [`number`]),
  getName: libzip_default.a.cwrap(`zip_get_name`, `string`, [`number`, `number`, `number`]),
  getNumEntries: libzip_default.a.cwrap(`zip_get_num_entries`, `number`, [`number`, `number`]),
  stat: libzip_default.a.cwrap(`zip_stat`, `number`, [`number`, `string`, `number`, `number`]),
  statIndex: libzip_default.a.cwrap(`zip_stat_index`, `number`, [`number`, ...number64, `number`, `number`]),
  fopen: libzip_default.a.cwrap(`zip_fopen`, `number`, [`number`, `string`, `number`]),
  fopenIndex: libzip_default.a.cwrap(`zip_fopen_index`, `number`, [`number`, ...number64, `number`]),
  fread: libzip_default.a.cwrap(`zip_fread`, `number`, [`number`, `number`, `number`, `number`]),
  fclose: libzip_default.a.cwrap(`zip_fclose`, `number`, [`number`]),
  dir: {
    add: libzip_default.a.cwrap(`zip_dir_add`, `number`, [`number`, `string`])
  },
  file: {
    add: libzip_default.a.cwrap(`zip_file_add`, `number`, [`number`, `string`, `number`, `number`]),
    getError: libzip_default.a.cwrap(`zip_file_get_error`, `number`, [`number`]),
    getExternalAttributes: libzip_default.a.cwrap(`zip_file_get_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setExternalAttributes: libzip_default.a.cwrap(`zip_file_set_external_attributes`, `number`, [`number`, ...number64, `number`, `number`, `number`]),
    setMtime: libzip_default.a.cwrap(`zip_file_set_mtime`, `number`, [`number`, ...number64, `number`, `number`])
  },
  error: {
    initWithCode: libzip_default.a.cwrap(`zip_error_init_with_code`, null, [`number`, `number`]),
    strerror: libzip_default.a.cwrap(`zip_error_strerror`, `string`, [`number`])
  },
  name: {
    locate: libzip_default.a.cwrap(`zip_name_locate`, `number`, [`number`, `string`, `number`])
  },
  source: {
    fromUnattachedBuffer: libzip_default.a.cwrap(`zip_source_buffer_create`, `number`, [`number`, `number`, `number`, `number`]),
    fromBuffer: libzip_default.a.cwrap(`zip_source_buffer`, `number`, [`number`, `number`, ...number64, `number`]),
    free: libzip_default.a.cwrap(`zip_source_free`, null, [`number`])
  },
  struct: {
    stat: libzip_default.a.cwrap(`zipstruct_stat`, `number`, []),
    statS: libzip_default.a.cwrap(`zipstruct_statS`, `number`, []),
    statName: libzip_default.a.cwrap(`zipstruct_stat_name`, `string`, [`number`]),
    statIndex: libzip_default.a.cwrap(`zipstruct_stat_index`, `number`, [`number`]),
    statSize: libzip_default.a.cwrap(`zipstruct_stat_size`, `number`, [`number`]),
    statMtime: libzip_default.a.cwrap(`zipstruct_stat_mtime`, `number`, [`number`]),
    error: libzip_default.a.cwrap(`zipstruct_error`, `number`, []),
    errorS: libzip_default.a.cwrap(`zipstruct_errorS`, `number`, [])
  }
});
// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(8);

// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(4);

// CONCATENATED MODULE: ../yarnpkg-fslib/sources/errors.ts
function makeError(code, message) {
  return Object.assign(new Error(`${code}: ${message}`), {
    code
  });
}

function EBUSY(message) {
  return makeError(`EBUSY`, message);
}
function ENOSYS(message, reason) {
  return makeError(`ENOSYS`, `${message}, ${reason}`);
}
function EINVAL(reason) {
  return makeError(`EINVAL`, `invalid argument, ${reason}`);
}
function EBADF(reason) {
  return makeError(`EBADF`, `bad file descriptor, ${reason}`);
}
function ENOENT(reason) {
  return makeError(`ENOENT`, `no such file or directory, ${reason}`);
}
function ENOTDIR(reason) {
  return makeError(`ENOTDIR`, `not a directory, ${reason}`);
}
function EISDIR(reason) {
  return makeError(`EISDIR`, `illegal operation on a directory, ${reason}`);
}
function EEXIST(reason) {
  return makeError(`EEXIST`, `file already exists, ${reason}`);
}
function EROFS(reason) {
  return makeError(`EROFS`, `read-only filesystem, ${reason}`);
}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/ZipFS.ts








const S_IFMT = 0o170000;
const S_IFDIR = 0o040000;
const S_IFREG = 0o100000;
const S_IFLNK = 0o120000;

class DirEntry {
  constructor() {
    this.name = ``;
    this.mode = 0;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }

}

class StatEntry {
  constructor() {
    this.dev = 0;
    this.ino = 0;
    this.mode = 0;
    this.nlink = 1;
    this.rdev = 0;
    this.blocks = 1;
  }

  isBlockDevice() {
    return false;
  }

  isCharacterDevice() {
    return false;
  }

  isDirectory() {
    return (this.mode & S_IFMT) === S_IFDIR;
  }

  isFIFO() {
    return false;
  }

  isFile() {
    return (this.mode & S_IFMT) === S_IFREG;
  }

  isSocket() {
    return false;
  }

  isSymbolicLink() {
    return (this.mode & S_IFMT) === S_IFLNK;
  }

}

function makeDefaultStats() {
  return Object.assign(new StatEntry(), {
    uid: 0,
    gid: 0,
    size: 0,
    blksize: 0,
    atimeMs: 0,
    mtimeMs: 0,
    ctimeMs: 0,
    birthtimeMs: 0,
    atime: new Date(0),
    mtime: new Date(0),
    ctime: new Date(0),
    birthtime: new Date(0),
    mode: S_IFREG | 0o644
  });
}

function toUnixTimestamp(time) {
  if (typeof time === 'string' && String(+time) === time) return +time; // @ts-ignore

  if (Number.isFinite(time)) {
    if (time < 0) {
      return Date.now() / 1000;
    } else {
      return time;
    }
  } // convert to 123.456 UNIX timestamp


  if (Object(external_util_["isDate"])(time)) return time.getTime() / 1000;
  throw new Error(`Invalid time`);
}

class ZipFS_ZipFS extends FakeFS_BasePortableFakeFS {
  constructor(source, opts = {}) {
    super();
    this.listings = new Map();
    this.entries = new Map();
    this.fds = new Map();
    this.nextFd = 0;
    this.ready = false;
    this.readOnly = false;
    const pathOptions = opts;

    if (typeof source === `string`) {
      const {
        baseFs = new NodeFS_NodeFS()
      } = pathOptions;
      this.baseFs = baseFs;
      this.path = source;
    } else {
      this.path = null;
      this.baseFs = null;
    }

    if (opts.stats) {
      this.stats = opts.stats;
    } else {
      if (typeof source === `string`) {
        try {
          this.stats = this.baseFs.statSync(source);
        } catch (error) {
          if (error.code === `ENOENT` && pathOptions.create) {
            this.stats = makeDefaultStats();
          } else {
            throw error;
          }
        }
      } else {
        this.stats = makeDefaultStats();
      }
    }

    const errPtr = sources.malloc(4);

    try {
      let flags = 0;
      if (typeof source === `string` && pathOptions.create) flags |= sources.ZIP_CREATE | sources.ZIP_TRUNCATE;

      if (opts.readOnly) {
        flags |= sources.ZIP_RDONLY;
        this.readOnly = true;
      }

      if (typeof source === `string`) {
        this.zip = sources.open(npath.fromPortablePath(source), flags, errPtr);
      } else {
        const lzSource = this.allocateUnattachedSource(source);

        try {
          this.zip = sources.openFromSource(lzSource, flags, errPtr);
        } catch (error) {
          sources.source.free(lzSource);
          throw error;
        }
      }

      if (this.zip === 0) {
        const error = sources.struct.errorS();
        sources.error.initWithCode(error, sources.getValue(errPtr, `i32`));
        throw new Error(sources.error.strerror(error));
      }
    } finally {
      sources.free(errPtr);
    }

    this.listings.set(PortablePath.root, new Set());
    const entryCount = sources.getNumEntries(this.zip, 0);

    for (let t = 0; t < entryCount; ++t) {
      const raw = sources.getName(this.zip, t, 0);
      if (ppath.isAbsolute(raw)) continue;
      const p = ppath.resolve(PortablePath.root, raw);
      this.registerEntry(p, t); // If the raw path is a directory, register it
      // to prevent empty folder being skipped

      if (raw.endsWith('/')) {
        this.registerListing(p);
      }
    }

    this.ready = true;
  }

  getAllFiles() {
    return Array.from(this.entries.keys());
  }

  getRealPath() {
    if (!this.path) throw new Error(`ZipFS don't have real paths when loaded from a buffer`);
    return this.path;
  }

  saveAndClose() {
    if (!this.path || !this.baseFs) throw new Error(`ZipFS cannot be saved and must be discarded when loaded from a buffer`);
    if (!this.ready) throw EBUSY(`archive closed, close`);
    if (this.readOnly) return this.discardAndClose();
    const previousMod = this.baseFs.existsSync(this.path) ? this.baseFs.statSync(this.path).mode & 0o777 : null;
    const rc = sources.close(this.zip);
    if (rc === -1) throw new Error(sources.error.strerror(sources.getError(this.zip))); // Libzip overrides the chmod when writing the archive, which is a weird
    // behavior I don't totally understand (plus the umask seems bogus in some
    // weird cases - maybe related to emscripten?)
    //
    // See also https://github.com/nih-at/libzip/issues/77

    if (previousMod !== null && previousMod !== (this.baseFs.statSync(this.path).mode & 0o777)) this.baseFs.chmodSync(this.path, previousMod);
    this.ready = false;
  }

  discardAndClose() {
    if (!this.ready) throw EBUSY(`archive closed, close`);
    sources.discard(this.zip);
    this.ready = false;
  }

  async openPromise(p, flags, mode) {
    return this.openSync(p, flags, mode);
  }

  openSync(p, flags, mode) {
    const fd = this.nextFd++;
    this.fds.set(fd, {
      cursor: 0,
      p
    });
    return fd;
  }

  async readPromise(fd, buffer, offset, length, position) {
    return this.readSync(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset = 0, length = 0, position = -1) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw EBADF(`read`);
    let realPosition;
    if (position === -1 || position === null) realPosition = entry.cursor;else realPosition = position;
    const source = this.readFileSync(entry.p);
    source.copy(buffer, offset, realPosition, realPosition + length);
    const bytesRead = Math.max(0, Math.min(source.length - realPosition, length));
    if (position === -1) entry.cursor += bytesRead;
    return bytesRead;
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.writeSync(fd, buffer, position);
    } else {
      return this.writeSync(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw EBADF(`read`);
    throw new Error(`Unimplemented`);
  }

  async closePromise(fd) {
    return this.closeSync(fd);
  }

  closeSync(fd) {
    const entry = this.fds.get(fd);
    if (typeof entry === `undefined`) throw EBADF(`read`);
    this.fds.delete(fd);
  }

  createReadStream(p, {
    encoding
  } = {}) {
    if (p === null) throw new Error(`Unimplemented`);
    const stream = Object.assign(new external_stream_["PassThrough"](), {
      bytesRead: 0,
      path: p,
      close: () => {
        clearImmediate(immediate);
      }
    });
    const immediate = setImmediate(() => {
      try {
        const data = this.readFileSync(p, encoding);
        stream.bytesRead = data.length;
        stream.write(data);
        stream.end();
      } catch (error) {
        stream.emit(`error`, error);
        stream.end();
      }
    });
    return stream;
  }

  createWriteStream(p, {
    encoding
  } = {}) {
    if (this.readOnly) throw EROFS(`open '${p}'`);
    if (p === null) throw new Error(`Unimplemented`);
    const stream = Object.assign(new external_stream_["PassThrough"](), {
      bytesWritten: 0,
      path: p,
      close: () => {
        stream.end();
      }
    });
    const chunks = [];
    stream.on(`data`, chunk => {
      const chunkBuffer = Buffer.from(chunk);
      stream.bytesWritten += chunkBuffer.length;
      chunks.push(chunkBuffer);
    });
    stream.on(`end`, () => {
      this.writeFileSync(p, Buffer.concat(chunks), encoding);
    });
    return stream;
  }

  async realpathPromise(p) {
    return this.realpathSync(p);
  }

  realpathSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`lstat '${p}'`);
    return resolvedP;
  }

  async existsPromise(p) {
    return this.existsSync(p);
  }

  existsSync(p) {
    let resolvedP;

    try {
      resolvedP = this.resolveFilename(`stat '${p}'`, p);
    } catch (error) {
      return false;
    }

    return this.entries.has(resolvedP) || this.listings.has(resolvedP);
  }

  async accessPromise(p, mode) {
    return this.accessSync(p, mode);
  }

  accessSync(p, mode = external_fs_["constants"].F_OK) {
    const resolvedP = this.resolveFilename(`access '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`access '${p}'`);

    if (this.readOnly && mode & external_fs_["constants"].W_OK) {
      throw EROFS(`access '${p}'`);
    }
  }

  async statPromise(p) {
    return this.statSync(p);
  }

  statSync(p) {
    const resolvedP = this.resolveFilename(`stat '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`stat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw ENOTDIR(`stat '${p}'`);
    return this.statImpl(`stat '${p}'`, resolvedP);
  }

  async lstatPromise(p) {
    return this.lstatSync(p);
  }

  lstatSync(p) {
    const resolvedP = this.resolveFilename(`lstat '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`lstat '${p}'`);
    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw ENOTDIR(`lstat '${p}'`);
    return this.statImpl(`lstat '${p}'`, resolvedP);
  }

  statImpl(reason, p) {
    if (this.listings.has(p)) {
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = 0;
      const blksize = 512;
      const blocks = 0;
      const atimeMs = this.stats.mtimeMs;
      const birthtimeMs = this.stats.mtimeMs;
      const ctimeMs = this.stats.mtimeMs;
      const mtimeMs = this.stats.mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const mode = S_IFDIR | 0o755;
      return Object.assign(new StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    }

    const entry = this.entries.get(p);

    if (entry !== undefined) {
      const stat = sources.struct.statS();
      const rc = sources.statIndex(this.zip, entry, 0, 0, stat);
      if (rc === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
      const uid = this.stats.uid;
      const gid = this.stats.gid;
      const size = sources.struct.statSize(stat) >>> 0;
      const blksize = 512;
      const blocks = Math.ceil(size / blksize);
      const mtimeMs = (sources.struct.statMtime(stat) >>> 0) * 1000;
      const atimeMs = mtimeMs;
      const birthtimeMs = mtimeMs;
      const ctimeMs = mtimeMs;
      const atime = new Date(atimeMs);
      const birthtime = new Date(birthtimeMs);
      const ctime = new Date(ctimeMs);
      const mtime = new Date(mtimeMs);
      const mode = this.getUnixMode(entry, S_IFREG | 0o644);
      return Object.assign(new StatEntry(), {
        uid,
        gid,
        size,
        blksize,
        blocks,
        atime,
        birthtime,
        ctime,
        mtime,
        atimeMs,
        birthtimeMs,
        ctimeMs,
        mtimeMs,
        mode
      });
    }

    throw new Error(`Unreachable`);
  }

  getUnixMode(index, defaultMode) {
    const rc = sources.file.getExternalAttributes(this.zip, index, 0, 0, sources.uint08S, sources.uint32S);
    if (rc === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
    const opsys = sources.getValue(sources.uint08S, `i8`) >>> 0;
    if (opsys !== sources.ZIP_OPSYS_UNIX) return defaultMode;
    return sources.getValue(sources.uint32S, `i32`) >>> 16;
  }

  registerListing(p) {
    let listing = this.listings.get(p);
    if (listing) return listing;
    const parentListing = this.registerListing(ppath.dirname(p));
    listing = new Set();
    parentListing.add(ppath.basename(p));
    this.listings.set(p, listing);
    return listing;
  }

  registerEntry(p, index) {
    const parentListing = this.registerListing(ppath.dirname(p));
    parentListing.add(ppath.basename(p));
    this.entries.set(p, index);
  }

  resolveFilename(reason, p, resolveLastComponent = true) {
    if (!this.ready) throw EBUSY(`archive closed, ${reason}`);
    let resolvedP = ppath.resolve(PortablePath.root, p);
    if (resolvedP === `/`) return PortablePath.root;

    while (true) {
      const parentP = this.resolveFilename(reason, ppath.dirname(resolvedP), true);
      const isDir = this.listings.has(parentP);
      const doesExist = this.entries.has(parentP);
      if (!isDir && !doesExist) throw ENOENT(reason);
      if (!isDir) throw ENOTDIR(reason);
      resolvedP = ppath.resolve(parentP, ppath.basename(resolvedP));
      if (!resolveLastComponent) break;
      const index = sources.name.locate(this.zip, resolvedP);
      if (index === -1) break;

      if (this.isSymbolicLink(index)) {
        const target = this.getFileSource(index).toString();
        resolvedP = ppath.resolve(ppath.dirname(resolvedP), target);
      } else {
        break;
      }
    }

    return resolvedP;
  }

  allocateBuffer(content) {
    if (!Buffer.isBuffer(content)) content = Buffer.from(content);
    const buffer = sources.malloc(content.byteLength);
    if (!buffer) throw new Error(`Couldn't allocate enough memory`); // Copy the file into the Emscripten heap

    const heap = new Uint8Array(sources.HEAPU8.buffer, buffer, content.byteLength);
    heap.set(content);
    return {
      buffer,
      byteLength: content.byteLength
    };
  }

  allocateUnattachedSource(content) {
    const error = sources.struct.errorS();
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = sources.source.fromUnattachedBuffer(buffer, byteLength, 0, true, error);

    if (source === 0) {
      sources.free(error);
      throw new Error(sources.error.strerror(error));
    }

    return source;
  }

  allocateSource(content) {
    const {
      buffer,
      byteLength
    } = this.allocateBuffer(content);
    const source = sources.source.fromBuffer(this.zip, buffer, byteLength, 0, true);

    if (source === 0) {
      sources.free(buffer);
      throw new Error(sources.error.strerror(sources.getError(this.zip)));
    }

    return source;
  }

  setFileSource(p, content) {
    const target = ppath.relative(PortablePath.root, p);
    const lzSource = this.allocateSource(content);

    try {
      return sources.file.add(this.zip, target, lzSource, sources.ZIP_FL_OVERWRITE);
    } catch (error) {
      sources.source.free(lzSource);
      throw error;
    }
  }

  isSymbolicLink(index) {
    const attrs = sources.file.getExternalAttributes(this.zip, index, 0, 0, sources.uint08S, sources.uint32S);
    if (attrs === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
    const opsys = sources.getValue(sources.uint08S, `i8`) >>> 0;
    if (opsys !== sources.ZIP_OPSYS_UNIX) return false;
    const attributes = sources.getValue(sources.uint32S, `i32`) >>> 16;
    return (attributes & S_IFMT) === S_IFLNK;
  }

  getFileSource(index) {
    const stat = sources.struct.statS();
    const rc = sources.statIndex(this.zip, index, 0, 0, stat);
    if (rc === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
    const size = sources.struct.statSize(stat);
    const buffer = sources.malloc(size);

    try {
      const file = sources.fopenIndex(this.zip, index, 0, 0);
      if (file === 0) throw new Error(sources.error.strerror(sources.getError(this.zip)));

      try {
        const rc = sources.fread(file, buffer, size, 0);
        if (rc === -1) throw new Error(sources.error.strerror(sources.file.getError(file)));else if (rc < size) throw new Error(`Incomplete read`);else if (rc > size) throw new Error(`Overread`);
        const memory = sources.HEAPU8.subarray(buffer, buffer + size);
        const data = Buffer.from(memory);
        return data;
      } finally {
        sources.fclose(file);
      }
    } finally {
      sources.free(buffer);
    }
  }

  async chmodPromise(p, mask) {
    return this.chmodSync(p, mask);
  }

  chmodSync(p, mask) {
    if (this.readOnly) throw EROFS(`chmod '${p}'`);
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false); // We silently ignore chmod requests for directories

    if (this.listings.has(resolvedP)) return;
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const oldMod = this.getUnixMode(entry, S_IFREG | 0o000);
    const newMod = oldMod & ~0o777 | mask;
    const rc = sources.file.setExternalAttributes(this.zip, entry, 0, 0, sources.ZIP_OPSYS_UNIX, newMod << 16);

    if (rc === -1) {
      throw new Error(sources.error.strerror(sources.getError(this.zip)));
    }
  }

  async renamePromise(oldP, newP) {
    return this.renameSync(oldP, newP);
  }

  renameSync(oldP, newP) {
    throw new Error(`Unimplemented`);
  }

  async copyFilePromise(sourceP, destP, flags) {
    return this.copyFileSync(sourceP, destP, flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    if (this.readOnly) throw EROFS(`copyfile '${sourceP} -> '${destP}'`);
    if ((flags & external_fs_["constants"].COPYFILE_FICLONE_FORCE) !== 0) throw ENOSYS(`unsupported clone operation`, `copyfile '${sourceP}' -> ${destP}'`);
    const resolvedSourceP = this.resolveFilename(`copyfile '${sourceP} -> ${destP}'`, sourceP);
    const indexSource = this.entries.get(resolvedSourceP);
    if (typeof indexSource === `undefined`) throw EINVAL(`copyfile '${sourceP}' -> '${destP}'`);
    const resolvedDestP = this.resolveFilename(`copyfile '${sourceP}' -> ${destP}'`, destP);
    const indexDest = this.entries.get(resolvedDestP);
    if ((flags & (external_fs_["constants"].COPYFILE_EXCL | external_fs_["constants"].COPYFILE_FICLONE_FORCE)) !== 0 && typeof indexDest !== `undefined`) throw EEXIST(`copyfile '${sourceP}' -> '${destP}'`);
    const source = this.getFileSource(indexSource);
    const newIndex = this.setFileSource(resolvedDestP, source);

    if (newIndex !== indexDest) {
      this.registerEntry(resolvedDestP, newIndex);
    }
  }

  async appendFilePromise(p, content, opts) {
    return this.appendFileSync(p, content, opts);
  }

  appendFileSync(p, content, opts = {}) {
    if (this.readOnly) throw EROFS(`open '${p}'`);
    if (typeof opts === `undefined`) opts = {
      flag: `a`
    };else if (typeof opts === `string`) opts = {
      flag: `a`,
      encoding: opts
    };else if (typeof opts.flag === `undefined`) opts = Object.assign({
      flag: `a`
    }, opts);
    return this.writeFileSync(p, content, opts);
  }

  async writeFilePromise(p, content, opts) {
    return this.writeFileSync(p, content, opts);
  }

  writeFileSync(p, content, opts) {
    if (typeof p !== `string`) throw EBADF(`read`);
    if (this.readOnly) throw EROFS(`open '${p}'`);
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (this.listings.has(resolvedP)) throw EISDIR(`open '${p}'`);
    const index = this.entries.get(resolvedP);
    if (index !== undefined && typeof opts === `object` && opts.flag && opts.flag.includes(`a`)) content = Buffer.concat([this.getFileSource(index), Buffer.from(content)]);
    let encoding = null;
    if (typeof opts === `string`) encoding = opts;else if (typeof opts === `object` && opts.encoding) encoding = opts.encoding;
    if (encoding !== null) content = content.toString(encoding);
    const newIndex = this.setFileSource(resolvedP, content);

    if (newIndex !== index) {
      this.registerEntry(resolvedP, newIndex);
    }
  }

  async unlinkPromise(p) {
    return this.unlinkSync(p);
  }

  unlinkSync(p) {
    throw new Error(`Unimplemented`);
  }

  async utimesPromise(p, atime, mtime) {
    return this.utimesSync(p, atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    if (this.readOnly) throw EROFS(`utimes '${p}'`);
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p);
    return this.utimesImpl(resolvedP, mtime);
  }

  async lutimesPromise(p, atime, mtime) {
    return this.lutimesSync(p, atime, mtime);
  }

  lutimesSync(p, atime, mtime) {
    if (this.readOnly) throw EROFS(`lutimes '${p}'`);
    const resolvedP = this.resolveFilename(`chmod '${p}'`, p, false);
    return this.utimesImpl(resolvedP, mtime);
  }

  utimesImpl(resolvedP, mtime) {
    if (this.listings.has(resolvedP)) if (!this.entries.has(resolvedP)) this.hydrateDirectory(resolvedP);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const rc = sources.file.setMtime(this.zip, entry, 0, toUnixTimestamp(mtime), 0);

    if (rc === -1) {
      throw new Error(sources.error.strerror(sources.getError(this.zip)));
    }
  }

  async mkdirPromise(p, opts) {
    return this.mkdirSync(p, opts);
  }

  mkdirSync(p, opts) {
    if (opts && opts.recursive) return this.mkdirpSync(p, {
      chmod: opts.mode
    });
    if (this.readOnly) throw EROFS(`mkdir '${p}'`);
    const resolvedP = this.resolveFilename(`mkdir '${p}'`, p);
    if (this.entries.has(resolvedP) || this.listings.has(resolvedP)) throw EEXIST(`mkdir '${p}'`);
    this.hydrateDirectory(resolvedP);
  }

  async rmdirPromise(p) {
    return this.rmdirSync(p);
  }

  rmdirSync(p) {
    throw new Error(`Unimplemented`);
  }

  hydrateDirectory(resolvedP) {
    const index = sources.dir.add(this.zip, ppath.relative(PortablePath.root, resolvedP));
    if (index === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
    this.registerListing(resolvedP);
    this.registerEntry(resolvedP, index);
    return index;
  }

  async symlinkPromise(target, p) {
    return this.symlinkSync(target, p);
  }

  symlinkSync(target, p) {
    if (this.readOnly) throw EROFS(`symlink '${target}' -> '${p}'`);
    const resolvedP = this.resolveFilename(`symlink '${target}' -> '${p}'`, p);
    if (this.listings.has(resolvedP)) throw EISDIR(`symlink '${target}' -> '${p}'`);
    if (this.entries.has(resolvedP)) throw EEXIST(`symlink '${target}' -> '${p}'`);
    const index = this.setFileSource(resolvedP, target);
    this.registerEntry(resolvedP, index);
    const rc = sources.file.setExternalAttributes(this.zip, index, 0, 0, sources.ZIP_OPSYS_UNIX, (0o120000 | 0o777) << 16);

    if (rc === -1) {
      throw new Error(sources.error.strerror(sources.getError(this.zip)));
    }
  }

  async readFilePromise(p, encoding) {
    // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    switch (encoding) {
      case `utf8`:
        return this.readFileSync(p, encoding);

      default:
        return this.readFileSync(p, encoding);
    }
  }

  readFileSync(p, encoding) {
    if (typeof p !== `string`) throw EBADF(`read`); // This is messed up regarding the TS signatures

    if (typeof encoding === `object`) // @ts-ignore
      encoding = encoding ? encoding.encoding : undefined;
    const resolvedP = this.resolveFilename(`open '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`open '${p}'`); // Ensures that the last component is a directory, if the user said so (even if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw EISDIR(`read`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const data = this.getFileSource(entry);
    return encoding ? data.toString(encoding) : data;
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.readdirSync(p, {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    const resolvedP = this.resolveFilename(`scandir '${p}'`, p);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`scandir '${p}'`);
    const directoryListing = this.listings.get(resolvedP);
    if (!directoryListing) throw ENOTDIR(`scandir '${p}'`);
    const entries = [...directoryListing];
    if (!withFileTypes) return entries;
    return entries.map(name => {
      return Object.assign(this.statImpl(`lstat`, ppath.join(p, name)), {
        name
      });
    });
  }

  async readlinkPromise(p) {
    return this.readlinkSync(p);
  }

  readlinkSync(p) {
    const resolvedP = this.resolveFilename(`readlink '${p}'`, p, false);
    if (!this.entries.has(resolvedP) && !this.listings.has(resolvedP)) throw ENOENT(`readlink '${p}'`); // Ensure that the last component is a directory (if it is we'll throw right after with EISDIR anyway)

    if (p[p.length - 1] === `/` && !this.listings.has(resolvedP)) throw ENOTDIR(`open '${p}'`);
    if (this.listings.has(resolvedP)) throw EINVAL(`readlink '${p}'`);
    const entry = this.entries.get(resolvedP);
    if (entry === undefined) throw new Error(`Unreachable`);
    const rc = sources.file.getExternalAttributes(this.zip, entry, 0, 0, sources.uint08S, sources.uint32S);
    if (rc === -1) throw new Error(sources.error.strerror(sources.getError(this.zip)));
    const opsys = sources.getValue(sources.uint08S, `i8`) >>> 0;
    if (opsys !== sources.ZIP_OPSYS_UNIX) throw EINVAL(`readlink '${p}'`);
    const attributes = sources.getValue(sources.uint32S, `i32`) >>> 16;
    if ((attributes & 0o170000) !== 0o120000) throw EINVAL(`readlink '${p}'`);
    return this.getFileSource(entry).toString();
  }

  watch(p, a, b) {
    let persistent;

    switch (typeof a) {
      case `function`:
      case `string`:
      case `undefined`:
        {
          persistent = true;
        }
        break;

      default:
        {
          // @ts-ignore
          ({
            persistent = true
          } = a);
        }
        break;
    }

    if (!persistent) return {
      on: () => {},
      close: () => {}
    };
    const interval = setInterval(() => {}, 24 * 60 * 60 * 1000);
    return {
      on: () => {},
      close: () => {
        clearInterval(interval);
      }
    };
  }

}
;
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/ZipOpenFS.ts





const ZIP_FD = 0x80000000;
class ZipOpenFS_ZipOpenFS extends FakeFS_BasePortableFakeFS {
  constructor({
    baseFs = new NodeFS_NodeFS(),
    filter = null,
    readOnlyArchives = false,
    useCache = true
  } = {}) {
    super();
    this.fdMap = new Map();
    this.nextFd = 3;
    this.isZip = new Set();
    this.notZip = new Set();
    this.baseFs = baseFs;
    this.zipInstances = useCache ? new Map() : null;
    this.filter = filter;
    this.readOnlyArchives = readOnlyArchives;
    this.isZip = new Set();
    this.notZip = new Set();
  }

  static open(fn) {
    const zipOpenFs = new ZipOpenFS_ZipOpenFS();

    try {
      return fn(zipOpenFs);
    } finally {
      zipOpenFs.saveAndClose();
    }
  }

  static async openPromise(fn) {
    const zipOpenFs = new ZipOpenFS_ZipOpenFS();

    try {
      return await fn(zipOpenFs);
    } finally {
      zipOpenFs.saveAndClose();
    }
  }

  getRealPath() {
    return this.baseFs.getRealPath();
  }

  saveAndClose() {
    if (this.zipInstances) {
      for (const [path, zipFs] of this.zipInstances.entries()) {
        zipFs.saveAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  discardAndClose() {
    if (this.zipInstances) {
      for (const [path, zipFs] of this.zipInstances.entries()) {
        zipFs.discardAndClose();
        this.zipInstances.delete(path);
      }
    }
  }

  remapFd(zipFs, fd) {
    const remappedFd = this.nextFd++ | ZIP_FD;
    this.fdMap.set(remappedFd, [zipFs, fd]);
    return remappedFd;
  }

  async openPromise(p, flags, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.openPromise(p, flags, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, (await zipFs.openPromise(subPath, flags, mode)));
    });
  }

  openSync(p, flags, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.openSync(p, flags, mode);
    }, (zipFs, {
      subPath
    }) => {
      return this.remapFd(zipFs, zipFs.openSync(subPath, flags, mode));
    });
  }

  async readPromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.readPromise(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return await zipFs.readPromise(realFd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.readSync(fd, buffer, offset, length, position);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, read`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;
    return zipFs.readSync(realFd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return await this.baseFs.writePromise(fd, buffer, offset);
      } else {
        return await this.baseFs.writePromise(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return await zipFs.writePromise(realFd, buffer, offset);
    } else {
      return await zipFs.writePromise(realFd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if ((fd & ZIP_FD) === 0) {
      if (typeof buffer === `string`) {
        return this.baseFs.writeSync(fd, buffer, offset);
      } else {
        return this.baseFs.writeSync(fd, buffer, offset, length, position);
      }
    }

    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, write`), {
      code: `EBADF`
    });
    const [zipFs, realFd] = entry;

    if (typeof buffer === `string`) {
      return zipFs.writeSync(realFd, buffer, offset);
    } else {
      return zipFs.writeSync(realFd, buffer, offset, length, position);
    }
  }

  async closePromise(fd) {
    if ((fd & ZIP_FD) === 0) return await this.baseFs.closePromise(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return await zipFs.closePromise(realFd);
  }

  closeSync(fd) {
    if ((fd & ZIP_FD) === 0) return this.baseFs.closeSync(fd);
    const entry = this.fdMap.get(fd);
    if (typeof entry === `undefined`) throw Object.assign(new Error(`EBADF: bad file descriptor, close`), {
      code: `EBADF`
    });
    this.fdMap.delete(fd);
    const [zipFs, realFd] = entry;
    return zipFs.closeSync(realFd);
  }

  createReadStream(p, opts) {
    if (p === null) return this.baseFs.createReadStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createReadStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createReadStream(subPath, opts);
    });
  }

  createWriteStream(p, opts) {
    if (p === null) return this.baseFs.createWriteStream(p, opts);
    return this.makeCallSync(p, () => {
      return this.baseFs.createWriteStream(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.createWriteStream(subPath, opts);
    });
  }

  async realpathPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.realpathPromise(p);
    }, async (zipFs, {
      archivePath,
      subPath
    }) => {
      return this.pathUtils.resolve((await this.baseFs.realpathPromise(archivePath)), this.pathUtils.relative(PortablePath.root, (await zipFs.realpathPromise(subPath))));
    });
  }

  realpathSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.realpathSync(p);
    }, (zipFs, {
      archivePath,
      subPath
    }) => {
      return this.pathUtils.resolve(this.baseFs.realpathSync(archivePath), this.pathUtils.relative(PortablePath.root, zipFs.realpathSync(subPath)));
    });
  }

  async existsPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.existsPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.existsPromise(subPath);
    });
  }

  existsSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.existsSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.existsSync(subPath);
    });
  }

  async accessPromise(p, mode) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.accessPromise(p, mode);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.accessPromise(subPath, mode);
    });
  }

  accessSync(p, mode) {
    return this.makeCallSync(p, () => {
      return this.baseFs.accessSync(p, mode);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.accessSync(subPath, mode);
    });
  }

  async statPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.statPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.statPromise(subPath);
    });
  }

  statSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.statSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.statSync(subPath);
    });
  }

  async lstatPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.lstatPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.lstatPromise(subPath);
    });
  }

  lstatSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.lstatSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.lstatSync(subPath);
    });
  }

  async chmodPromise(p, mask) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.chmodPromise(p, mask);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.chmodPromise(subPath, mask);
    });
  }

  chmodSync(p, mask) {
    return this.makeCallSync(p, () => {
      return this.baseFs.chmodSync(p, mask);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.chmodSync(subPath, mask);
    });
  }

  async renamePromise(oldP, newP) {
    return await this.makeCallPromise(oldP, async () => {
      return await this.makeCallPromise(newP, async () => {
        return await this.baseFs.renamePromise(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, async (zipFsO, {
      subPath: subPathO
    }) => {
      return await this.makeCallPromise(newP, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, async (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return await zipFsO.renamePromise(subPathO, subPathN);
        }
      });
    });
  }

  renameSync(oldP, newP) {
    return this.makeCallSync(oldP, () => {
      return this.makeCallSync(newP, () => {
        return this.baseFs.renameSync(oldP, newP);
      }, async () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      });
    }, (zipFsO, {
      subPath: subPathO
    }) => {
      return this.makeCallSync(newP, () => {
        throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
          code: `EEXDEV`
        });
      }, (zipFsN, {
        subPath: subPathN
      }) => {
        if (zipFsO !== zipFsN) {
          throw Object.assign(new Error(`EEXDEV: cross-device link not permitted`), {
            code: `EEXDEV`
          });
        } else {
          return zipFsO.renameSync(subPathO, subPathN);
        }
      });
    });
  }

  async copyFilePromise(sourceP, destP, flags = 0) {
    const fallback = async (sourceFs, sourceP, destFs, destP) => {
      if ((flags & external_fs_["constants"].COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & external_fs_["constants"].COPYFILE_EXCL && (await this.existsPromise(sourceP))) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = await sourceFs.readFilePromise(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      await destFs.writeFilePromise(destP, content);
    };

    return await this.makeCallPromise(sourceP, async () => {
      return await this.makeCallPromise(destP, async () => {
        return await this.baseFs.copyFilePromise(sourceP, destP, flags);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        return await fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, async (zipFsS, {
      subPath: subPathS
    }) => {
      return await this.makeCallPromise(destP, async () => {
        return await fallback(zipFsS, subPathS, this.baseFs, destP);
      }, async (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return await fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return await zipFsS.copyFilePromise(subPathS, subPathD, flags);
        }
      });
    });
  }

  copyFileSync(sourceP, destP, flags = 0) {
    const fallback = (sourceFs, sourceP, destFs, destP) => {
      if ((flags & external_fs_["constants"].COPYFILE_FICLONE_FORCE) !== 0) throw Object.assign(new Error(`EXDEV: cross-device clone not permitted, copyfile '${sourceP}' -> ${destP}'`), {
        code: `EXDEV`
      });
      if (flags & external_fs_["constants"].COPYFILE_EXCL && this.existsSync(sourceP)) throw Object.assign(new Error(`EEXIST: file already exists, copyfile '${sourceP}' -> '${destP}'`), {
        code: `EEXIST`
      });
      let content;

      try {
        content = sourceFs.readFileSync(sourceP);
      } catch (error) {
        throw Object.assign(new Error(`EINVAL: invalid argument, copyfile '${sourceP}' -> '${destP}'`), {
          code: `EINVAL`
        });
      }

      destFs.writeFileSync(destP, content);
    };

    return this.makeCallSync(sourceP, () => {
      return this.makeCallSync(destP, () => {
        return this.baseFs.copyFileSync(sourceP, destP, flags);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        return fallback(this.baseFs, sourceP, zipFsD, subPathD);
      });
    }, (zipFsS, {
      subPath: subPathS
    }) => {
      return this.makeCallSync(destP, () => {
        return fallback(zipFsS, subPathS, this.baseFs, destP);
      }, (zipFsD, {
        subPath: subPathD
      }) => {
        if (zipFsS !== zipFsD) {
          return fallback(zipFsS, subPathS, zipFsD, subPathD);
        } else {
          return zipFsS.copyFileSync(subPathS, subPathD, flags);
        }
      });
    });
  }

  async appendFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.appendFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.appendFilePromise(subPath, content, opts);
    });
  }

  appendFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.appendFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.appendFileSync(subPath, content, opts);
    });
  }

  async writeFilePromise(p, content, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.writeFilePromise(p, content, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.writeFilePromise(subPath, content, opts);
    });
  }

  writeFileSync(p, content, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.writeFileSync(p, content, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.writeFileSync(subPath, content, opts);
    });
  }

  async unlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.unlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.unlinkPromise(subPath);
    });
  }

  unlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.unlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.unlinkSync(subPath);
    });
  }

  async utimesPromise(p, atime, mtime) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.utimesPromise(p, atime, mtime);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.utimesPromise(subPath, atime, mtime);
    });
  }

  utimesSync(p, atime, mtime) {
    return this.makeCallSync(p, () => {
      return this.baseFs.utimesSync(p, atime, mtime);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.utimesSync(subPath, atime, mtime);
    });
  }

  async mkdirPromise(p, opts) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.mkdirPromise(p, opts);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.mkdirPromise(subPath, opts);
    });
  }

  mkdirSync(p, opts) {
    return this.makeCallSync(p, () => {
      return this.baseFs.mkdirSync(p, opts);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.mkdirSync(subPath, opts);
    });
  }

  async rmdirPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.rmdirPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.rmdirPromise(subPath);
    });
  }

  rmdirSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.rmdirSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.rmdirSync(subPath);
    });
  }

  async symlinkPromise(target, p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.symlinkPromise(target, p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.symlinkPromise(target, subPath);
    });
  }

  symlinkSync(target, p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.symlinkSync(target, p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.symlinkSync(target, subPath);
    });
  }

  async readFilePromise(p, encoding) {
    return this.makeCallPromise(p, async () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return await this.baseFs.readFilePromise(p, encoding);

        default:
          return await this.baseFs.readFilePromise(p, encoding);
      }
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readFilePromise(subPath, encoding);
    });
  }

  readFileSync(p, encoding) {
    return this.makeCallSync(p, () => {
      // This weird switch is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
      switch (encoding) {
        case `utf8`:
          return this.baseFs.readFileSync(p, encoding);

        default:
          return this.baseFs.readFileSync(p, encoding);
      }
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readFileSync(subPath, encoding);
    });
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readdirPromise(p, {
        withFileTypes: withFileTypes
      });
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readdirPromise(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readdirSync(p, {
        withFileTypes: withFileTypes
      });
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readdirSync(subPath, {
        withFileTypes: withFileTypes
      });
    }, {
      requireSubpath: false
    });
  }

  async readlinkPromise(p) {
    return await this.makeCallPromise(p, async () => {
      return await this.baseFs.readlinkPromise(p);
    }, async (zipFs, {
      subPath
    }) => {
      return await zipFs.readlinkPromise(subPath);
    });
  }

  readlinkSync(p) {
    return this.makeCallSync(p, () => {
      return this.baseFs.readlinkSync(p);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.readlinkSync(subPath);
    });
  }

  watch(p, a, b) {
    return this.makeCallSync(p, () => {
      return this.baseFs.watch(p, // @ts-ignore
      a, b);
    }, (zipFs, {
      subPath
    }) => {
      return zipFs.watch(subPath, // @ts-ignore
      a, b);
    });
  }

  async makeCallPromise(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return await discard();
    const normalizedP = this.pathUtils.normalize(this.pathUtils.resolve(PortablePath.root, p));
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return await discard();
    if (requireSubpath && zipInfo.subPath === `/`) return await discard();
    return await this.getZipPromise(zipInfo.archivePath, async zipFs => await accept(zipFs, zipInfo));
  }

  makeCallSync(p, discard, accept, {
    requireSubpath = true
  } = {}) {
    if (typeof p !== `string`) return discard();
    const normalizedP = this.pathUtils.normalize(this.pathUtils.resolve(PortablePath.root, p));
    const zipInfo = this.findZip(normalizedP);
    if (!zipInfo) return discard();
    if (requireSubpath && zipInfo.subPath === `/`) return discard();
    return this.getZipSync(zipInfo.archivePath, zipFs => accept(zipFs, zipInfo));
  }

  findZip(p) {
    if (this.filter && !this.filter.test(p)) return null;
    const parts = p.split(/\//g);

    for (let t = 2; t <= parts.length; ++t) {
      const archivePath = parts.slice(0, t).join(`/`);
      if (this.notZip.has(archivePath)) continue;
      if (this.isZip.has(archivePath)) return {
        archivePath,
        subPath: this.pathUtils.resolve(PortablePath.root, parts.slice(t).join(`/`))
      };
      let realArchivePath = archivePath;
      let stat;

      while (true) {
        try {
          stat = this.baseFs.lstatSync(realArchivePath);
        } catch (error) {
          return null;
        }

        if (stat.isSymbolicLink()) {
          realArchivePath = this.pathUtils.resolve(this.pathUtils.dirname(realArchivePath), this.baseFs.readlinkSync(realArchivePath));
        } else {
          break;
        }
      }

      const isZip = stat.isFile() && this.pathUtils.extname(realArchivePath) === `.zip`;

      if (isZip) {
        this.isZip.add(archivePath);
        return {
          archivePath,
          subPath: this.pathUtils.resolve(PortablePath.root, parts.slice(t).join(`/`))
        };
      } else {
        this.notZip.add(archivePath);

        if (stat.isFile()) {
          return null;
        }
      }
    }

    return null;
  }

  async getZipPromise(p, accept) {
    const getZipOptions = async () => ({
      baseFs: this.baseFs,
      readOnly: this.readOnlyArchives,
      stats: await this.baseFs.statPromise(p)
    });

    if (this.zipInstances) {
      let zipFs = this.zipInstances.get(p);
      if (!zipFs) this.zipInstances.set(p, zipFs = new ZipFS_ZipFS(p, (await getZipOptions())));
      return await accept(zipFs);
    } else {
      const zipFs = new ZipFS_ZipFS(p, (await getZipOptions()));

      try {
        return await accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

  getZipSync(p, accept) {
    const getZipOptions = () => ({
      baseFs: this.baseFs,
      readOnly: this.readOnlyArchives,
      stats: this.baseFs.statSync(p)
    });

    if (this.zipInstances) {
      let zipFs = this.zipInstances.get(p);
      if (!zipFs) this.zipInstances.set(p, zipFs = new ZipFS_ZipFS(p, getZipOptions()));
      return accept(zipFs);
    } else {
      const zipFs = new ZipFS_ZipFS(p, getZipOptions());

      try {
        return accept(zipFs);
      } finally {
        zipFs.saveAndClose();
      }
    }
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/ProxiedFS.ts

class ProxiedFS_ProxiedFS extends FakeFS_FakeFS {
  resolve(path) {
    return this.mapFromBase(this.baseFs.resolve(this.mapToBase(path)));
  }

  getRealPath() {
    return this.mapFromBase(this.baseFs.getRealPath());
  }

  openPromise(p, flags, mode) {
    return this.baseFs.openPromise(this.mapToBase(p), flags, mode);
  }

  openSync(p, flags, mode) {
    return this.baseFs.openSync(this.mapToBase(p), flags, mode);
  }

  async readPromise(fd, buffer, offset, length, position) {
    return await this.baseFs.readPromise(fd, buffer, offset, length, position);
  }

  readSync(fd, buffer, offset, length, position) {
    return this.baseFs.readSync(fd, buffer, offset, length, position);
  }

  async writePromise(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return await this.baseFs.writePromise(fd, buffer, offset);
    } else {
      return await this.baseFs.writePromise(fd, buffer, offset, length, position);
    }
  }

  writeSync(fd, buffer, offset, length, position) {
    if (typeof buffer === `string`) {
      return this.baseFs.writeSync(fd, buffer, offset);
    } else {
      return this.baseFs.writeSync(fd, buffer, offset, length, position);
    }
  }

  closePromise(fd) {
    return this.baseFs.closePromise(fd);
  }

  closeSync(fd) {
    this.baseFs.closeSync(fd);
  }

  createReadStream(p, opts) {
    return this.baseFs.createReadStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  createWriteStream(p, opts) {
    return this.baseFs.createWriteStream(p !== null ? this.mapToBase(p) : p, opts);
  }

  async realpathPromise(p) {
    return this.mapFromBase((await this.baseFs.realpathPromise(this.mapToBase(p))));
  }

  realpathSync(p) {
    return this.mapFromBase(this.baseFs.realpathSync(this.mapToBase(p)));
  }

  existsPromise(p) {
    return this.baseFs.existsPromise(this.mapToBase(p));
  }

  existsSync(p) {
    return this.baseFs.existsSync(this.mapToBase(p));
  }

  accessSync(p, mode) {
    return this.baseFs.accessSync(this.mapToBase(p), mode);
  }

  accessPromise(p, mode) {
    return this.baseFs.accessPromise(this.mapToBase(p), mode);
  }

  statPromise(p) {
    return this.baseFs.statPromise(this.mapToBase(p));
  }

  statSync(p) {
    return this.baseFs.statSync(this.mapToBase(p));
  }

  lstatPromise(p) {
    return this.baseFs.lstatPromise(this.mapToBase(p));
  }

  lstatSync(p) {
    return this.baseFs.lstatSync(this.mapToBase(p));
  }

  chmodPromise(p, mask) {
    return this.baseFs.chmodPromise(this.mapToBase(p), mask);
  }

  chmodSync(p, mask) {
    return this.baseFs.chmodSync(this.mapToBase(p), mask);
  }

  renamePromise(oldP, newP) {
    return this.baseFs.renamePromise(this.mapToBase(oldP), this.mapToBase(newP));
  }

  renameSync(oldP, newP) {
    return this.baseFs.renameSync(this.mapToBase(oldP), this.mapToBase(newP));
  }

  copyFilePromise(sourceP, destP, flags = 0) {
    return this.baseFs.copyFilePromise(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  copyFileSync(sourceP, destP, flags = 0) {
    return this.baseFs.copyFileSync(this.mapToBase(sourceP), this.mapToBase(destP), flags);
  }

  appendFilePromise(p, content, opts) {
    return this.baseFs.appendFilePromise(this.fsMapToBase(p), content, opts);
  }

  appendFileSync(p, content, opts) {
    return this.baseFs.appendFileSync(this.fsMapToBase(p), content, opts);
  }

  writeFilePromise(p, content, opts) {
    return this.baseFs.writeFilePromise(this.fsMapToBase(p), content, opts);
  }

  writeFileSync(p, content, opts) {
    return this.baseFs.writeFileSync(this.fsMapToBase(p), content, opts);
  }

  unlinkPromise(p) {
    return this.baseFs.unlinkPromise(this.mapToBase(p));
  }

  unlinkSync(p) {
    return this.baseFs.unlinkSync(this.mapToBase(p));
  }

  utimesPromise(p, atime, mtime) {
    return this.baseFs.utimesPromise(this.mapToBase(p), atime, mtime);
  }

  utimesSync(p, atime, mtime) {
    return this.baseFs.utimesSync(this.mapToBase(p), atime, mtime);
  }

  mkdirPromise(p, opts) {
    return this.baseFs.mkdirPromise(this.mapToBase(p), opts);
  }

  mkdirSync(p, opts) {
    return this.baseFs.mkdirSync(this.mapToBase(p), opts);
  }

  rmdirPromise(p) {
    return this.baseFs.rmdirPromise(this.mapToBase(p));
  }

  rmdirSync(p) {
    return this.baseFs.rmdirSync(this.mapToBase(p));
  }

  symlinkPromise(target, p) {
    return this.baseFs.symlinkPromise(this.mapToBase(target), this.mapToBase(p));
  }

  symlinkSync(target, p) {
    return this.baseFs.symlinkSync(this.mapToBase(target), this.mapToBase(p));
  }

  readFilePromise(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === 'utf8') {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFilePromise(this.fsMapToBase(p), encoding);
    }
  }

  readFileSync(p, encoding) {
    // This weird condition is required to tell TypeScript that the signatures are proper (otherwise it thinks that only the generic one is covered)
    if (encoding === 'utf8') {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    } else {
      return this.baseFs.readFileSync(this.fsMapToBase(p), encoding);
    }
  }

  async readdirPromise(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirPromise(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  readdirSync(p, {
    withFileTypes
  } = {}) {
    return this.baseFs.readdirSync(this.mapToBase(p), {
      withFileTypes: withFileTypes
    });
  }

  async readlinkPromise(p) {
    return this.mapFromBase((await this.baseFs.readlinkPromise(this.mapToBase(p))));
  }

  readlinkSync(p) {
    return this.mapFromBase(this.baseFs.readlinkSync(this.mapToBase(p)));
  }

  watch(p, a, b) {
    return this.baseFs.watch(this.mapToBase(p), // @ts-ignore
    a, b);
  }

  fsMapToBase(p) {
    if (typeof p === `number`) {
      return p;
    } else {
      return this.mapToBase(p);
    }
  }

}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/VirtualFS.ts


 // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js

const escapeRegexp = s => s.replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');

class VirtualFS_VirtualFS extends ProxiedFS_ProxiedFS {
  constructor(virtual, {
    baseFs = new NodeFS_NodeFS()
  } = {}) {
    super(ppath);
    this.baseFs = baseFs;
    this.target = ppath.dirname(virtual);
    this.virtual = virtual;
    this.mapToBaseRegExp = new RegExp(`^(${escapeRegexp(this.virtual)})((?:/([^\/]+)(?:/([^/]+))?)?((?:/.*)?))$`);
  }

  static makeVirtualPath(base, component, to) {
    // Obtains the relative distance between the virtual path and its actual target
    const target = ppath.relative(ppath.dirname(base), to);
    const segments = target.split(`/`); // Counts how many levels we need to go back to start applying the rest of the path

    let depth = 0;

    while (depth < segments.length && segments[depth] === `..`) depth += 1;

    const finalSegments = segments.slice(depth);
    const fullVirtualPath = ppath.join(base, component, String(depth), ...finalSegments);
    return fullVirtualPath;
  }

  getRealPath() {
    return this.pathUtils.resolve(this.baseFs.getRealPath(), this.target);
  }

  realpathSync(p) {
    const match = p.match(this.mapToBaseRegExp);
    if (!match) return this.baseFs.realpathSync(p);
    if (!match[5]) return p;
    const realpath = this.baseFs.realpathSync(this.mapToBase(p));
    return VirtualFS_VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
  }

  async realpathPromise(p) {
    const match = p.match(this.mapToBaseRegExp);
    if (!match) return await this.baseFs.realpathPromise(p);
    if (!match[5]) return p;
    const realpath = await this.baseFs.realpathPromise(this.mapToBase(p));
    return VirtualFS_VirtualFS.makeVirtualPath(this.virtual, match[3], realpath);
  }

  mapToBase(p) {
    const match = p.match(this.mapToBaseRegExp);
    if (!match) return p;
    if (match[3]) return this.mapToBase(ppath.join(this.target, `../`.repeat(Number(match[4])), match[5]));
    return this.target;
  }

  mapFromBase(p) {
    return p;
  }

}
// EXTERNAL MODULE: external "module"
var external_module_ = __webpack_require__(1);
var external_module_default = /*#__PURE__*/__webpack_require__.n(external_module_);

// EXTERNAL MODULE: external "string_decoder"
var external_string_decoder_ = __webpack_require__(16);
var external_string_decoder_default = /*#__PURE__*/__webpack_require__.n(external_string_decoder_);

// CONCATENATED MODULE: ../yarnpkg-fslib/sources/index.ts
















function patchFs(patchedFs, fakeFs) {
  const SYNC_IMPLEMENTATIONS = new Set([`accessSync`, `appendFileSync`, `createReadStream`, `chmodSync`, `closeSync`, `copyFileSync`, `lstatSync`, `mkdirSync`, `openSync`, `readSync`, `readlinkSync`, `readFileSync`, `readdirSync`, `readlinkSync`, `realpathSync`, `renameSync`, `rmdirSync`, `statSync`, `symlinkSync`, `unlinkSync`, `utimesSync`, `watch`, `writeFileSync`, `writeSync`]);
  const ASYNC_IMPLEMENTATIONS = new Set([`accessPromise`, `appendFilePromise`, `chmodPromise`, `closePromise`, `copyFilePromise`, `lstatPromise`, `mkdirPromise`, `openPromise`, `readdirPromise`, `realpathPromise`, `readFilePromise`, `readdirPromise`, `readlinkPromise`, `renamePromise`, `rmdirPromise`, `statPromise`, `symlinkPromise`, `unlinkPromise`, `utimesPromise`, `writeFilePromise`, `writeSync`]);

  patchedFs.existsSync = p => {
    try {
      return fakeFs.existsSync(p);
    } catch (error) {
      return false;
    }
  };

  patchedFs.exists = (p, ...args) => {
    const hasCallback = typeof args[args.length - 1] === `function`;
    const callback = hasCallback ? args.pop() : () => {};
    process.nextTick(() => {
      fakeFs.existsPromise(p).then(exists => {
        callback(exists);
      }, () => {
        callback(false);
      });
    });
  };

  patchedFs.read = (p, buffer, ...args) => {
    const hasCallback = typeof args[args.length - 1] === `function`;
    const callback = hasCallback ? args.pop() : () => {};
    process.nextTick(() => {
      fakeFs.readPromise(p, buffer, ...args).then(bytesRead => {
        callback(null, bytesRead, buffer);
      }, error => {
        callback(error);
      });
    });
  };

  for (const fnName of ASYNC_IMPLEMENTATIONS) {
    const fakeImpl = fakeFs[fnName].bind(fakeFs);
    const origName = fnName.replace(/Promise$/, ``);

    patchedFs[origName] = (...args) => {
      const hasCallback = typeof args[args.length - 1] === `function`;
      const callback = hasCallback ? args.pop() : () => {};
      process.nextTick(() => {
        fakeImpl(...args).then(result => {
          callback(null, result);
        }, error => {
          callback(error);
        });
      });
    };
  }

  for (const fnName of SYNC_IMPLEMENTATIONS) {
    const fakeImpl = fakeFs[fnName].bind(fakeFs);
    const origName = fnName;
    patchedFs[origName] = fakeImpl;
  }

  patchedFs.realpathSync.native = patchedFs.realpathSync;
  patchedFs.realpath.native = patchedFs.realpath;
}
function extendFs(realFs, fakeFs) {
  const patchedFs = Object.create(realFs);
  patchFs(patchedFs, fakeFs);
  return patchedFs;
}
const xfs = Object.assign(new NodeFS_NodeFS(), {
  mktempSync(cb) {
    // We lazily load `tmp` because it injects itself into the `process`
    // events (to clean the folders at exit time), and it may lead to
    // large memory leaks. Better avoid loading it until we can't do
    // otherwise (ideally the fix would be for `tmp` itself to only
    // attach cleaners after the first call).
    const tmp = __webpack_require__(9);

    const {
      name,
      removeCallback
    } = tmp.dirSync({
      unsafeCleanup: true
    });

    if (typeof cb === `undefined`) {
      return npath.toPortablePath(name);
    } else {
      try {
        return cb(npath.toPortablePath(name));
      } finally {
        removeCallback();
      }
    }
  },

  mktempPromise(cb) {
    // We lazily load `tmp` because it injects itself into the `process`
    // events (to clean the folders at exit time), and it may lead to
    // large memory leaks. Better avoid loading it until we can't do
    // otherwise (ideally the fix would be for `tmp` itself to only
    // attach cleaners after the first call).
    const tmp = __webpack_require__(9);

    if (typeof cb === `undefined`) {
      return new Promise((resolve, reject) => {
        tmp.dir({
          unsafeCleanup: true
        }, (err, path) => {
          if (err) {
            reject(err);
          } else {
            resolve(npath.toPortablePath(path));
          }
        });
      });
    } else {
      return new Promise((resolve, reject) => {
        tmp.dir({
          unsafeCleanup: true
        }, (err, path, cleanup) => {
          if (err) {
            reject(err);
          } else {
            Promise.resolve(npath.toPortablePath(path)).then(cb).then(result => {
              cleanup();
              resolve(result);
            }, error => {
              cleanup();
              reject(error);
            });
          }
        });
      });
    }
  }

});
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/PosixFS.ts


class PosixFS_PosixFS extends ProxiedFS_ProxiedFS {
  constructor(baseFs) {
    super(npath);
    this.baseFs = baseFs;
  }

  mapFromBase(path) {
    return npath.fromPortablePath(path);
  }

  mapToBase(path) {
    return npath.toPortablePath(path);
  }

}
// CONCATENATED MODULE: ./sources/loader/internalTools.ts
var ErrorCode;

(function (ErrorCode) {
  ErrorCode["API_ERROR"] = "API_ERROR";
  ErrorCode["BLACKLISTED"] = "BLACKLISTED";
  ErrorCode["BUILTIN_NODE_RESOLUTION_FAILED"] = "BUILTIN_NODE_RESOLUTION_FAILED";
  ErrorCode["MISSING_DEPENDENCY"] = "MISSING_DEPENDENCY";
  ErrorCode["MISSING_PEER_DEPENDENCY"] = "MISSING_PEER_DEPENDENCY";
  ErrorCode["QUALIFIED_PATH_RESOLUTION_FAILED"] = "QUALIFIED_PATH_RESOLUTION_FAILED";
  ErrorCode["INTERNAL"] = "INTERNAL";
  ErrorCode["UNDECLARED_DEPENDENCY"] = "UNDECLARED_DEPENDENCY";
  ErrorCode["UNSUPPORTED"] = "UNSUPPORTED";
})(ErrorCode || (ErrorCode = {}));

; // Some errors are exposed as MODULE_NOT_FOUND for compatibility with packages
// that expect this umbrella error when the resolution fails

const MODULE_NOT_FOUND_ERRORS = new Set([ErrorCode.BLACKLISTED, ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, ErrorCode.MISSING_DEPENDENCY, ErrorCode.MISSING_PEER_DEPENDENCY, ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, ErrorCode.UNDECLARED_DEPENDENCY]);
/**
 * Simple helper function that assign an error code to an error, so that it can more easily be caught and used
 * by third-parties.
 */

function internalTools_makeError(pnpCode, message, data = {}) {
  const code = MODULE_NOT_FOUND_ERRORS.has(pnpCode) ? `MODULE_NOT_FOUND` : pnpCode;
  return Object.assign(new Error(message), {
    code,
    pnpCode,
    data
  });
}
/**
 * Returns the module that should be used to resolve require calls. It's usually the direct parent, except if we're
 * inside an eval expression.
 */

function getIssuerModule(parent) {
  let issuer = parent;

  while (issuer && (issuer.id === '[eval]' || issuer.id === '<repl>' || !issuer.filename)) issuer = issuer.parent;

  return issuer;
}
// CONCATENATED MODULE: ./sources/loader/applyPatch.ts
var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};






function applyPatch(pnpapi, opts) {
  // @ts-ignore
  const builtinModules = new Set(external_module_default.a.builtinModules || Object.keys(process.binding('natives'))); // The callback function gets called to wrap the return value of the module names matching the regexp

  const patchedModules = [];

  if (opts.compatibilityMode !== false) {
    // Modern versions of `resolve` support a specific entry point that custom resolvers can use
    // to inject a specific resolution logic without having to patch the whole package.
    //
    // Cf: https://github.com/browserify/resolve/pull/174
    patchedModules.push([/^\.\/normalize-options\.js$/, (issuer, normalizeOptions) => {
      if (!issuer || issuer.name !== 'resolve') return normalizeOptions;
      return (request, opts) => {
        opts = opts || {};
        if (opts.forceNodeResolution) return opts;
        opts.preserveSymlinks = true;

        opts.paths = function (request, basedir, getNodeModulesDir, opts) {
          // Extract the name of the package being requested (1=full name, 2=scope name, 3=local name)
          const parts = request.match(/^((?:(@[^\/]+)\/)?([^\/]+))/);
          if (!parts) throw new Error(`Assertion failed: Expected the "resolve" package to call the "paths" callback with package names only (got "${request}")`); // make sure that basedir ends with a slash

          if (basedir.charAt(basedir.length - 1) !== '/') basedir = external_path_default.a.join(basedir, '/'); // TODO Handle portable paths
          // This is guaranteed to return the path to the "package.json" file from the given package

          const manifestPath = pnpapi.resolveToUnqualified(`${parts[1]}/package.json`, basedir, {
            considerBuiltins: false
          });
          if (manifestPath === null) throw new Error(`Assertion failed: The resolution thinks that "${parts[1]}" is a Node builtin`); // The first dirname strips the package.json, the second strips the local named folder

          let nodeModules = external_path_default.a.dirname(external_path_default.a.dirname(manifestPath)); // Strips the scope named folder if needed

          if (parts[2]) nodeModules = external_path_default.a.dirname(nodeModules);
          return [nodeModules];
        };

        return opts;
      };
    }]);
  }
  /**
   * Used to disable the resolution hooks (for when we want to fallback to the previous resolution - we then need
   * a way to "reset" the environment temporarily)
   */


  let enableNativeHooks = true; // @ts-ignore

  process.versions.pnp = String(pnpapi.VERSIONS.std);

  function getRequireStack(parent) {
    const requireStack = [];

    for (let cursor = parent; cursor; cursor = cursor.parent) requireStack.push(cursor.filename || cursor.id);

    return requireStack;
  } // A small note: we don't replace the cache here (and instead use the native one). This is an effort to not
  // break code similar to "delete require.cache[require.resolve(FOO)]", where FOO is a package located outside
  // of the Yarn dependency tree. In this case, we defer the load to the native loader. If we were to replace the
  // cache by our own, the native loader would populate its own cache, which wouldn't be exposed anymore, so the
  // delete call would be broken.


  const originalModuleLoad = external_module_default.a._load;

  external_module_default.a._load = function (request, parent, isMain) {
    if (!enableNativeHooks) return originalModuleLoad.call(external_module_default.a, request, parent, isMain); // Builtins are managed by the regular Node loader

    if (builtinModules.has(request)) {
      try {
        enableNativeHooks = false;
        return originalModuleLoad.call(external_module_default.a, request, parent, isMain);
      } finally {
        enableNativeHooks = true;
      }
    } // The 'pnpapi' name is reserved to return the PnP api currently in use by the program


    if (request === `pnpapi`) return pnpapi; // Request `Module._resolveFilename` (ie. `resolveRequest`) to tell us which file we should load

    const modulePath = external_module_default.a._resolveFilename(request, parent, isMain); // Check if the module has already been created for the given file


    const cacheEntry = external_module_default.a._cache[modulePath];
    if (cacheEntry) return cacheEntry.exports; // Create a new module and store it into the cache
    // @ts-ignore

    const module = new external_module_default.a(modulePath, parent);
    external_module_default.a._cache[modulePath] = module; // The main module is exposed as global variable

    if (isMain) {
      // @ts-ignore
      process.mainModule = module;
      module.id = '.';
    } // Try to load the module, and remove it from the cache if it fails


    let hasThrown = true;

    try {
      module.load(modulePath);
      hasThrown = false;
    } finally {
      if (hasThrown) {
        delete external_module_default.a._cache[modulePath];
      }
    } // Some modules might have to be patched for compatibility purposes


    for (const [filter, patchFn] of patchedModules) {
      if (filter.test(request)) {
        const issuer = parent && parent.filename ? pnpapi.findPackageLocator(parent.filename) : null;
        module.exports = patchFn(issuer, module.exports);
      }
    }

    return module.exports;
  };

  const originalModuleResolveFilename = external_module_default.a._resolveFilename;

  external_module_default.a._resolveFilename = function (request, parent, isMain, options) {
    if (request === `pnpapi`) return pnpapi.resolveToUnqualified(`pnpapi`, null);
    if (!enableNativeHooks) return originalModuleResolveFilename.call(external_module_default.a, request, parent, isMain, options);

    if (options && options.plugnplay === false) {
      const {
        plugnplay
      } = options,
            rest = __rest(options, ["plugnplay"]); // Workaround a bug present in some version of Node (now fixed)
      // https://github.com/nodejs/node/pull/28078


      const forwardedOptions = Object.keys(rest).length > 0 ? rest : undefined;

      try {
        enableNativeHooks = false;
        return originalModuleResolveFilename.call(external_module_default.a, request, parent, isMain, forwardedOptions);
      } finally {
        enableNativeHooks = true;
      }
    }

    let issuers;

    if (options) {
      const optionNames = new Set(Object.keys(options));
      optionNames.delete(`paths`);
      optionNames.delete(`plugnplay`);

      if (optionNames.size > 0) {
        throw internalTools_makeError(ErrorCode.UNSUPPORTED, `Some options passed to require() aren't supported by PnP yet (${Array.from(optionNames).join(', ')})`);
      }

      if (options.paths) {
        issuers = options.paths.map(entry => {
          return `${external_path_default.a.normalize(entry)}/`;
        });
      }
    }

    if (!issuers) {
      const issuerModule = getIssuerModule(parent);
      const issuer = issuerModule ? issuerModule.filename : `${npath.toPortablePath(process.cwd())}/`;
      issuers = [issuer];
    } // When Node is called, it tries to require the main script but can't
    // because PnP already patched 'Module'
    // We test it for an absolute Windows path and convert it to a portable path.
    // We should probably always call toPortablePath and check for this directly


    if (/^[A-Z]:.*/.test(request)) request = npath.toPortablePath(request);
    let firstError;

    for (const issuer of issuers) {
      let resolution;

      try {
        resolution = pnpapi.resolveRequest(request, issuer);
      } catch (error) {
        firstError = firstError || error;
        continue;
      }

      return resolution !== null ? resolution : request;
    }

    const requireStack = getRequireStack(parent);
    firstError.requireStack = requireStack;
    if (requireStack.length > 0) firstError.message += `\nRequire stack:\n- ${requireStack.join(`\n- `)}`;
    throw firstError;
  };

  const originalFindPath = external_module_default.a._findPath;

  external_module_default.a._findPath = function (request, paths, isMain) {
    if (request === `pnpapi`) return false;
    if (!enableNativeHooks) return originalFindPath.call(external_module_default.a, request, paths, isMain);

    for (const path of paths || []) {
      let resolution;

      try {
        // TODO Convert path to portable path?
        resolution = pnpapi.resolveRequest(request, path);
      } catch (error) {
        continue;
      }

      if (resolution) {
        return resolution;
      }
    }

    return false;
  };

  patchFs(external_fs_default.a, new PosixFS_PosixFS(opts.fakeFs));
}
;
// CONCATENATED MODULE: ./sources/loader/hydrateRuntimeState.ts

function hydrateRuntimeState(data, {
  basePath
}) {
  const portablePath = npath.toPortablePath(basePath);
  const ignorePattern = data.ignorePatternData !== null ? new RegExp(data.ignorePatternData) : null;
  const packageRegistry = new Map(data.packageRegistryData.map(([packageName, packageStoreData]) => {
    return [packageName, new Map(packageStoreData.map(([packageReference, packageInformationData]) => {
      return [packageReference, {
        packageLocation: ppath.resolve(portablePath, packageInformationData.packageLocation),
        packageDependencies: new Map(packageInformationData.packageDependencies),
        packagePeers: new Set(packageInformationData.packagePeers),
        linkType: packageInformationData.linkType
      }];
    }))];
  }));
  const packageLocatorsByLocations = new Map();

  for (const [packageName, storeData] of data.packageRegistryData) {
    for (const [packageReference, packageInformationData] of storeData) {
      if (packageName === null !== (packageReference === null)) throw new Error(`Assertion failed: The name and reference should be null, or neither should`); // @ts-ignore: TypeScript isn't smart enough to understand the type assertion

      const packageLocator = {
        name: packageName,
        reference: packageReference
      };
      packageLocatorsByLocations.set(packageInformationData.packageLocation, packageLocator);
    }
  }

  for (const location of data.locationBlacklistData) packageLocatorsByLocations.set(location, null);

  const fallbackExclusionList = new Map(data.fallbackExclusionList.map(([packageName, packageReferences]) => {
    return [packageName, new Set(packageReferences)];
  }));
  const virtualRoots = data.virtualRoots.map(virtualRoot => {
    return ppath.resolve(portablePath, virtualRoot);
  });
  const dependencyTreeRoots = data.dependencyTreeRoots;
  const enableTopLevelFallback = data.enableTopLevelFallback;
  const packageLocationLengths = data.locationLengthData;
  return {
    basePath: portablePath,
    dependencyTreeRoots,
    enableTopLevelFallback,
    fallbackExclusionList,
    ignorePattern,
    packageLocationLengths,
    packageLocatorsByLocations,
    packageRegistry,
    virtualRoots
  };
}
// CONCATENATED MODULE: ../yarnpkg-fslib/sources/NoFS.ts



const NoFS_makeError = () => Object.assign(new Error(`ENOSYS: unsupported filesystem access`), {
  code: `ENOSYS`
});

class NoFS_NoFS extends FakeFS_FakeFS {
  constructor() {
    super(ppath);
  }

  getRealPath() {
    throw NoFS_makeError();
  }

  resolve() {
    throw NoFS_makeError();
  }

  async openPromise() {
    throw NoFS_makeError();
  }

  openSync() {
    throw NoFS_makeError();
  }

  async readPromise() {
    throw NoFS_makeError();
  }

  readSync() {
    throw NoFS_makeError();
  }

  async writePromise() {
    throw NoFS_makeError();
  }

  writeSync() {
    throw NoFS_makeError();
  }

  async closePromise() {
    throw NoFS_makeError();
  }

  closeSync() {
    throw NoFS_makeError();
  }

  createWriteStream() {
    throw NoFS_makeError();
  }

  createReadStream() {
    throw NoFS_makeError();
  }

  async realpathPromise() {
    throw NoFS_makeError();
  }

  realpathSync() {
    throw NoFS_makeError();
  }

  async readdirPromise() {
    throw NoFS_makeError();
  }

  readdirSync() {
    throw NoFS_makeError();
  }

  async existsPromise(p) {
    throw NoFS_makeError();
  }

  existsSync(p) {
    throw NoFS_makeError();
  }

  async accessPromise() {
    throw NoFS_makeError();
  }

  accessSync() {
    throw NoFS_makeError();
  }

  async statPromise() {
    throw NoFS_makeError();
  }

  statSync() {
    throw NoFS_makeError();
  }

  async lstatPromise(p) {
    throw NoFS_makeError();
  }

  lstatSync(p) {
    throw NoFS_makeError();
  }

  async chmodPromise() {
    throw NoFS_makeError();
  }

  chmodSync() {
    throw NoFS_makeError();
  }

  async mkdirPromise() {
    throw NoFS_makeError();
  }

  mkdirSync() {
    throw NoFS_makeError();
  }

  async rmdirPromise() {
    throw NoFS_makeError();
  }

  rmdirSync() {
    throw NoFS_makeError();
  }

  async symlinkPromise() {
    throw NoFS_makeError();
  }

  symlinkSync() {
    throw NoFS_makeError();
  }

  async renamePromise() {
    throw NoFS_makeError();
  }

  renameSync() {
    throw NoFS_makeError();
  }

  async copyFilePromise() {
    throw NoFS_makeError();
  }

  copyFileSync() {
    throw NoFS_makeError();
  }

  async appendFilePromise() {
    throw NoFS_makeError();
  }

  appendFileSync() {
    throw NoFS_makeError();
  }

  async writeFilePromise() {
    throw NoFS_makeError();
  }

  writeFileSync() {
    throw NoFS_makeError();
  }

  async unlinkPromise() {
    throw NoFS_makeError();
  }

  unlinkSync() {
    throw NoFS_makeError();
  }

  async utimesPromise() {
    throw NoFS_makeError();
  }

  utimesSync() {
    throw NoFS_makeError();
  }

  async readFilePromise() {
    throw NoFS_makeError();
  }

  readFileSync() {
    throw NoFS_makeError();
  }

  async readlinkPromise() {
    throw NoFS_makeError();
  }

  readlinkSync() {
    throw NoFS_makeError();
  }

  watch() {
    throw NoFS_makeError();
  }

}
NoFS_NoFS.instance = new NoFS_NoFS();
// CONCATENATED MODULE: ./sources/loader/makeApi.ts
/// <reference path="./module.d.ts"/>




function makeApi(runtimeState, opts) {
  // @ts-ignore
  const builtinModules = new Set(external_module_default.a.builtinModules || Object.keys(process.binding('natives'))); // Splits a require request into its components, or return null if the request is a file path

  const pathRegExp = /^(?![a-zA-Z]:[\\\/]|\\\\|\.{0,2}(?:\/|$))((?:@[^\/]+\/)?[^\/]+)\/?(.*|)$/; // Matches if the path starts with a valid path qualifier (./, ../, /)
  // eslint-disable-next-line no-unused-vars

  const isStrictRegExp = /^\.{0,2}\//; // Matches if the path must point to a directory (ie ends with /)

  const isDirRegExp = /\/$/; // We only instantiate one of those so that we can use strict-equal comparisons

  const topLevelLocator = {
    name: null,
    reference: null
  }; // Used for compatibility purposes - cf setupCompatibilityLayer

  const fallbackLocators = [];
  if (runtimeState.enableTopLevelFallback === true) fallbackLocators.push(topLevelLocator);

  if (opts.compatibilityMode !== false) {
    // ESLint currently doesn't have any portable way for shared configs to
    // specify their own plugins that should be used (cf issue #10125). This
    // will likely get fixed at some point but it'll take time, so in the
    // meantime we'll just add additional fallback entries for common shared
    // configs.
    // Similarly, Gatsby generates files within the `public` folder located
    // within the project, but doesn't pre-resolve the `require` calls to use
    // its own dependencies. Meaning that when PnP see a file from the `public`
    // folder making a require, it thinks that your project forgot to list one
    // of your dependencies.
    for (const name of [`react-scripts`, `gatsby`]) {
      const packageStore = runtimeState.packageRegistry.get(name);

      if (packageStore) {
        for (const reference of packageStore.keys()) {
          if (reference === null) {
            throw new Error(`Assertion failed: This reference shouldn't be null`);
          } else {
            fallbackLocators.push({
              name,
              reference
            });
          }
        }
      }
    }
  }
  /**
   * The setup code will be injected here. The tables listed below are guaranteed to be filled after the call to
   * the $$DYNAMICALLY_GENERATED_CODE function.
   */


  const {
    ignorePattern,
    packageRegistry,
    packageLocatorsByLocations,
    packageLocationLengths
  } = runtimeState;
  /**
   * Allows to print useful logs just be setting a value in the environment
   */

  function makeLogEntry(name, args) {
    return {
      fn: name,
      args: args,
      error: null,
      result: null
    };
  }

  function maybeLog(name, fn) {
    if (opts.allowDebug === false) return fn;
    const level = Number(process.env.PNP_DEBUG_LEVEL);

    if (Number.isFinite(level)) {
      if (level >= 2) {
        return (...args) => {
          const logEntry = makeLogEntry(name, args);

          try {
            return logEntry.result = fn(...args);
          } catch (error) {
            throw logEntry.error = error;
          } finally {
            console.error(logEntry);
          }
        };
      } else if (level >= 1) {
        return (...args) => {
          try {
            return fn(...args);
          } catch (error) {
            const logEntry = makeLogEntry(name, args);
            logEntry.error = error;
            console.error(logEntry);
            throw error;
          }
        };
      }
    }

    return fn;
  }
  /**
   * Returns information about a package in a safe way (will throw if they cannot be retrieved)
   */


  function getPackageInformationSafe(packageLocator) {
    const packageInformation = getPackageInformation(packageLocator);

    if (!packageInformation) {
      throw internalTools_makeError(ErrorCode.INTERNAL, `Couldn't find a matching entry in the dependency tree for the specified parent (this is probably an internal error)`);
    }

    return packageInformation;
  }
  /**
   * Returns whether the specified locator is a dependency tree root (in which case it's part of the project) or not
   */


  function isDependencyTreeRoot(packageLocator) {
    if (packageLocator.name === null) return true;

    for (const dependencyTreeRoot of runtimeState.dependencyTreeRoots) if (dependencyTreeRoot.name === packageLocator.name && dependencyTreeRoot.reference === packageLocator.reference) return true;

    return false;
  }
  /**
   * Implements the node resolution for folder access and extension selection
   */


  function applyNodeExtensionResolution(unqualifiedPath, candidates, {
    extensions
  }) {
    // We use this "infinite while" so that we can restart the process as long as we hit package folders
    while (true) {
      let stat;

      try {
        candidates.push(unqualifiedPath);
        stat = opts.fakeFs.statSync(unqualifiedPath);
      } catch (error) {} // If the file exists and is a file, we can stop right there


      if (stat && !stat.isDirectory()) return opts.fakeFs.realpathSync(unqualifiedPath); // If the file is a directory, we must check if it contains a package.json with a "main" entry

      if (stat && stat.isDirectory()) {
        let pkgJson;

        try {
          pkgJson = JSON.parse(opts.fakeFs.readFileSync(ppath.join(unqualifiedPath, toFilename(`package.json`)), `utf8`));
        } catch (error) {}

        let nextUnqualifiedPath;
        if (pkgJson && pkgJson.main) nextUnqualifiedPath = ppath.resolve(unqualifiedPath, pkgJson.main); // If the "main" field changed the path, we start again from this new location

        if (nextUnqualifiedPath && nextUnqualifiedPath !== unqualifiedPath) {
          const resolution = applyNodeExtensionResolution(nextUnqualifiedPath, candidates, {
            extensions
          });

          if (resolution !== null) {
            return resolution;
          }
        }
      } // Otherwise we check if we find a file that match one of the supported extensions


      const qualifiedPath = extensions.map(extension => {
        return `${unqualifiedPath}${extension}`;
      }).find(candidateFile => {
        candidates.push(candidateFile);
        return opts.fakeFs.existsSync(candidateFile);
      });
      if (qualifiedPath) return qualifiedPath; // Otherwise, we check if the path is a folder - in such a case, we try to use its index

      if (stat && stat.isDirectory()) {
        const indexPath = extensions.map(extension => {
          return ppath.format({
            dir: unqualifiedPath,
            name: toFilename(`index`),
            ext: extension
          });
        }).find(candidateFile => {
          candidates.push(candidateFile);
          return opts.fakeFs.existsSync(candidateFile);
        });

        if (indexPath) {
          return indexPath;
        }
      } // Otherwise there's nothing else we can do :(


      return null;
    }
  }
  /**
   * This function creates fake modules that can be used with the _resolveFilename function.
   * Ideally it would be nice to be able to avoid this, since it causes useless allocations
   * and cannot be cached efficiently (we recompute the nodeModulePaths every time).
   *
   * Fortunately, this should only affect the fallback, and there hopefully shouldn't have a
   * lot of them.
   */


  function makeFakeModule(path) {
    // @ts-ignore
    const fakeModule = new external_module_default.a(path, null);
    fakeModule.filename = path;
    fakeModule.paths = external_module_default.a._nodeModulePaths(path);
    return fakeModule;
  }
  /**
   * Normalize path to posix format.
   */


  function normalizePath(p) {
    return npath.toPortablePath(p);
  }
  /**
   * Forward the resolution to the next resolver (usually the native one)
   */


  function callNativeResolution(request, issuer) {
    if (issuer.endsWith(`/`)) issuer = ppath.join(issuer, toFilename(`internal.js`)); // Since we would need to create a fake module anyway (to call _resolveLookupPath that
    // would give us the paths to give to _resolveFilename), we can as well not use
    // the {paths} option at all, since it internally makes _resolveFilename create another
    // fake module anyway.

    return external_module_default.a._resolveFilename(request, makeFakeModule(npath.fromPortablePath(issuer)), false, {
      plugnplay: false
    });
  }
  /**
   * This key indicates which version of the standard is implemented by this resolver. The `std` key is the
   * Plug'n'Play standard, and any other key are third-party extensions. Third-party extensions are not allowed
   * to override the standard, and can only offer new methods.
   *
   * If an new version of the Plug'n'Play standard is released and some extensions conflict with newly added
   * functions, they'll just have to fix the conflicts and bump their own version number.
   */


  const VERSIONS = {
    std: 3,
    resolveVirtual: 1
  };
  /**
   * We export a special symbol for easy access to the top level locator.
   */

  const topLevel = topLevelLocator;
  /**
   * Gets the package information for a given locator. Returns null if they cannot be retrieved.
   */

  function getPackageInformation({
    name,
    reference
  }) {
    const packageInformationStore = packageRegistry.get(name);
    if (!packageInformationStore) return null;
    const packageInformation = packageInformationStore.get(reference);
    if (!packageInformation) return null;
    return packageInformation;
  }
  /**
   * Finds the package locator that owns the specified path. If none is found, returns null instead.
   */


  function findPackageLocator(location) {
    let relativeLocation = normalizePath(ppath.relative(runtimeState.basePath, location));
    if (!relativeLocation.match(isStrictRegExp)) relativeLocation = `./${relativeLocation}`;
    if (location.match(isDirRegExp) && !relativeLocation.endsWith(`/`)) relativeLocation = `${relativeLocation}/`;
    let from = 0; // If someone wants to use a binary search to go from O(n) to O(log n), be my guest

    while (from < packageLocationLengths.length && packageLocationLengths[from] > relativeLocation.length) from += 1;

    for (let t = from; t < packageLocationLengths.length; ++t) {
      const locator = packageLocatorsByLocations.get(relativeLocation.substr(0, packageLocationLengths[t]));
      if (typeof locator === `undefined`) continue; // Ensures that the returned locator isn't a blacklisted one.
      //
      // Blacklisted packages are packages that cannot be used because their dependencies cannot be deduced. This only
      // happens with peer dependencies, which effectively have different sets of dependencies depending on their
      // parents.
      //
      // In order to deambiguate those different sets of dependencies, the Yarn implementation of PnP will generate a
      // symlink for each combination of <package name>/<package version>/<dependent package> it will find, and will
      // blacklist the target of those symlinks. By doing this, we ensure that files loaded through a specific path
      // will always have the same set of dependencies, provided the symlinks are correctly preserved.
      //
      // Unfortunately, some tools do not preserve them, and when it happens PnP isn't able anymore to deduce the set of
      // dependencies based on the path of the file that makes the require calls. But since we've blacklisted those
      // paths, we're able to print a more helpful error message that points out that a third-party package is doing
      // something incompatible!

      if (locator === null) {
        throw internalTools_makeError(ErrorCode.BLACKLISTED, `A forbidden path has been used in the package resolution process - this is usually caused by one of your tools calling 'fs.realpath' on the return value of 'require.resolve'. Since we need to use symlinks to simultaneously provide valid filesystem paths and disambiguate peer dependencies, they must be passed untransformed to 'require'.\n\nForbidden path: ${location}`, {
          location
        });
      }

      return locator;
    }

    return null;
  }
  /**
   * Transforms a request (what's typically passed as argument to the require function) into an unqualified path.
   * This path is called "unqualified" because it only changes the package name to the package location on the disk,
   * which means that the end result still cannot be directly accessed (for example, it doesn't try to resolve the
   * file extension, or to resolve directories to their "index.js" content). Use the "resolveUnqualified" function
   * to convert them to fully-qualified paths, or just use "resolveRequest" that do both operations in one go.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */


  function resolveToUnqualified(request, issuer, {
    considerBuiltins = true
  } = {}) {
    // The 'pnpapi' request is reserved and will always return the path to the PnP file, from everywhere
    if (request === `pnpapi`) return npath.toPortablePath(opts.pnpapiResolution); // Bailout if the request is a native module

    if (considerBuiltins && builtinModules.has(request)) return null; // We allow disabling the pnp resolution for some subpaths. This is because some projects, often legacy,
    // contain multiple levels of dependencies (ie. a yarn.lock inside a subfolder of a yarn.lock). This is
    // typically solved using workspaces, but not all of them have been converted already.

    if (ignorePattern && issuer && ignorePattern.test(normalizePath(issuer))) {
      const result = callNativeResolution(request, issuer);

      if (result === false) {
        throw internalTools_makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer was explicitely ignored by the regexp)\n\nRequire request: "${request}"\nRequired by: ${issuer}\n`, {
          request,
          issuer
        });
      }

      return npath.toPortablePath(result);
    }

    let unqualifiedPath; // If the request is a relative or absolute path, we just return it normalized

    const dependencyNameMatch = request.match(pathRegExp);

    if (!dependencyNameMatch) {
      if (ppath.isAbsolute(request)) {
        unqualifiedPath = ppath.normalize(request);
      } else {
        if (!issuer) {
          throw internalTools_makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request,
            issuer
          });
        }

        if (issuer.match(isDirRegExp)) {
          unqualifiedPath = ppath.normalize(ppath.resolve(issuer, request));
        } else {
          unqualifiedPath = ppath.normalize(ppath.resolve(ppath.dirname(issuer), request));
        }
      } // No need to use the return value; we just want to check the blacklist status


      findPackageLocator(unqualifiedPath);
    } // Things are more hairy if it's a package require - we then need to figure out which package is needed, and in
    // particular the exact version for the given location on the dependency tree
    else {
        if (!issuer) {
          throw internalTools_makeError(ErrorCode.API_ERROR, `The resolveToUnqualified function must be called with a valid issuer when the path isn't a builtin nor absolute`, {
            request,
            issuer
          });
        }

        const [, dependencyName, subPath] = dependencyNameMatch;
        const issuerLocator = findPackageLocator(issuer); // If the issuer file doesn't seem to be owned by a package managed through pnp, then we resort to using the next
        // resolution algorithm in the chain, usually the native Node resolution one

        if (!issuerLocator) {
          const result = callNativeResolution(request, issuer);

          if (result === false) {
            throw internalTools_makeError(ErrorCode.BUILTIN_NODE_RESOLUTION_FAILED, `The builtin node resolution algorithm was unable to resolve the requested module (it didn't go through the pnp resolver because the issuer doesn't seem to be part of the Yarn-managed dependency tree)\n\nRequire path: "${request}"\nRequired by: ${issuer}\n`, {
              request,
              issuer
            });
          }

          return npath.toPortablePath(result);
        }

        const issuerInformation = getPackageInformationSafe(issuerLocator); // We obtain the dependency reference in regard to the package that request it

        let dependencyReference = issuerInformation.packageDependencies.get(dependencyName); // If we can't find it, we check if we can potentially load it from the packages that have been defined as potential fallbacks.
        // It's a bit of a hack, but it improves compatibility with the existing Node ecosystem. Hopefully we should eventually be able
        // to kill this logic and become stricter once pnp gets enough traction and the affected packages fix themselves.

        if (issuerLocator.name !== null) {
          // To allow programs to become gradually stricter, starting from the v2 we enforce that workspaces cannot depend on fallbacks.
          // This works by having a list containing all their locators, and checking when a fallback is required whether it's one of them.
          const exclusionEntry = runtimeState.fallbackExclusionList.get(issuerLocator.name);
          const canUseFallbacks = !exclusionEntry || !exclusionEntry.has(issuerLocator.reference);

          if (canUseFallbacks) {
            for (let t = 0, T = fallbackLocators.length; dependencyReference === undefined && t < T; ++t) {
              const fallbackInformation = getPackageInformationSafe(fallbackLocators[t]);
              const fallbackReference = fallbackInformation.packageDependencies.get(dependencyName);

              if (fallbackReference !== null) {
                dependencyReference = fallbackReference;
              }
            }
          }
        } // If we can't find the path, and if the package making the request is the top-level, we can offer nicer error messages


        if (dependencyReference === null) {
          if (isDependencyTreeRoot(issuerLocator)) {
            throw internalTools_makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `Something that got detected as your top-level application (because it doesn't seem to belong to any package) tried to access a peer dependency; this isn't allowed as the peer dependency cannot be provided by any parent package\n\nRequired package: ${dependencyName} (via "${request}")\nRequired by: ${issuer}\n`, {
              request,
              issuer,
              dependencyName
            });
          } else {
            throw internalTools_makeError(ErrorCode.MISSING_PEER_DEPENDENCY, `A package is trying to access a peer dependency that should be provided by its direct ancestor but isn't\n\nRequired package: ${dependencyName} (via "${request}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuer})\n`, {
              request,
              issuer,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName
            });
          }
        } else if (dependencyReference === undefined) {
          if (isDependencyTreeRoot(issuerLocator)) {
            throw internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `Something that got detected as your top-level application (because it doesn't seem to belong to any package) tried to access a package that is not declared in your dependencies\n\nRequired package: ${dependencyName} (via "${request}")\nRequired by: ${issuer}\n`, {
              request,
              issuer,
              dependencyName
            });
          } else {
            const candidates = Array.from(issuerInformation.packageDependencies.keys());
            throw internalTools_makeError(ErrorCode.UNDECLARED_DEPENDENCY, `A package is trying to access another package without the second one being listed as a dependency of the first one\n\nRequired package: ${dependencyName} (via "${request}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuer})\n`, {
              request,
              issuer,
              issuerLocator: Object.assign({}, issuerLocator),
              dependencyName,
              candidates
            });
          }
        } // We need to check that the package exists on the filesystem, because it might not have been installed


        const dependencyLocator = Array.isArray(dependencyReference) ? {
          name: dependencyReference[0],
          reference: dependencyReference[1]
        } : {
          name: dependencyName,
          reference: dependencyReference
        };
        const dependencyInformation = getPackageInformationSafe(dependencyLocator);

        if (!dependencyInformation.packageLocation) {
          throw internalTools_makeError(ErrorCode.MISSING_DEPENDENCY, `A dependency seems valid but didn't get installed for some reason. This might be caused by a partial install, such as dev vs prod.\n\nRequired package: ${dependencyLocator.name}@${dependencyLocator.reference} (via "${request}")\nRequired by: ${issuerLocator.name}@${issuerLocator.reference} (via ${issuer})\n`, {
            request,
            issuer,
            dependencyLocator: Object.assign({}, dependencyLocator)
          });
        } // Now that we know which package we should resolve to, we only have to find out the file location


        const dependencyLocation = ppath.resolve(runtimeState.basePath, dependencyInformation.packageLocation);

        if (subPath) {
          unqualifiedPath = ppath.resolve(dependencyLocation, subPath);
        } else {
          unqualifiedPath = dependencyLocation;
        }
      }

    return ppath.normalize(unqualifiedPath);
  }

  ;
  /**
   * Transforms an unqualified path into a qualified path by using the Node resolution algorithm (which automatically
   * appends ".js" / ".json", and transforms directory accesses into "index.js").
   */

  function resolveUnqualified(unqualifiedPath, {
    extensions = Object.keys(external_module_default.a._extensions)
  } = {}) {
    const candidates = [];
    const qualifiedPath = applyNodeExtensionResolution(unqualifiedPath, candidates, {
      extensions
    });

    if (qualifiedPath) {
      return ppath.normalize(qualifiedPath);
    } else {
      throw internalTools_makeError(ErrorCode.QUALIFIED_PATH_RESOLUTION_FAILED, `Couldn't find a suitable Node resolution for the specified unqualified path\n\nSource path: ${unqualifiedPath}\n${candidates.map(candidate => `Rejected resolution: ${candidate}\n`).join(``)}`, {
        unqualifiedPath
      });
    }
  }

  ;
  /**
   * Transforms a request into a fully qualified path.
   *
   * Note that it is extremely important that the `issuer` path ends with a forward slash if the issuer is to be
   * treated as a folder (ie. "/tmp/foo/" rather than "/tmp/foo" if "foo" is a directory). Otherwise relative
   * imports won't be computed correctly (they'll get resolved relative to "/tmp/" instead of "/tmp/foo/").
   */

  function resolveRequest(request, issuer, {
    considerBuiltins,
    extensions
  } = {}) {
    let unqualifiedPath = resolveToUnqualified(request, issuer, {
      considerBuiltins
    });
    if (unqualifiedPath === null) return null;

    try {
      return resolveUnqualified(unqualifiedPath, {
        extensions
      });
    } catch (resolutionError) {
      if (resolutionError.pnpCode === 'QUALIFIED_PATH_RESOLUTION_FAILED') Object.assign(resolutionError.data, {
        request,
        issuer
      });
      throw resolutionError;
    }
  }

  ;
  /**
   * Note: this function is an extension provided under the `resolveVirtual`
   * version keyword. Not all PnP implementation will have it.
   */

  const virtualMappers = runtimeState.virtualRoots.map(root => {
    return new VirtualFS_VirtualFS(root, {
      baseFs: NoFS_NoFS.instance
    });
  });

  function resolveVirtual(request) {
    const initialRequest = ppath.normalize(request);
    let currentRequest = request;
    let nextRequest = request;

    do {
      currentRequest = nextRequest;

      for (const mapper of virtualMappers) {
        nextRequest = mapper.mapToBase(nextRequest);

        if (nextRequest !== currentRequest) {
          break;
        }
      }
    } while (nextRequest !== currentRequest);

    if (currentRequest !== initialRequest) {
      return currentRequest;
    } else {
      return null;
    }
  }

  return {
    VERSIONS,
    topLevel,
    getLocator: (name, referencish) => {
      if (Array.isArray(referencish)) {
        return {
          name: referencish[0],
          reference: referencish[1]
        };
      } else {
        return {
          name,
          reference: referencish
        };
      }
    },
    getDependencyTreeRoots: () => {
      return [...runtimeState.dependencyTreeRoots];
    },
    getPackageInformation: locator => {
      const info = getPackageInformation(locator);
      if (info === null) return null;
      const packageLocation = npath.fromPortablePath(info.packageLocation);
      const nativeInfo = Object.assign(Object.assign({}, info), {
        packageLocation
      });
      return nativeInfo;
    },
    findPackageLocator: path => {
      return findPackageLocator(npath.toPortablePath(path));
    },
    resolveToUnqualified: maybeLog(`resolveToUnqualified`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveToUnqualified(npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveUnqualified: maybeLog(`resolveUnqualified`, (unqualifiedPath, opts) => {
      return npath.fromPortablePath(resolveUnqualified(npath.toPortablePath(unqualifiedPath), opts));
    }),
    resolveRequest: maybeLog(`resolveRequest`, (request, issuer, opts) => {
      const portableIssuer = issuer !== null ? npath.toPortablePath(issuer) : null;
      const resolution = resolveRequest(npath.toPortablePath(request), portableIssuer, opts);
      if (resolution === null) return null;
      return npath.fromPortablePath(resolution);
    }),
    resolveVirtual: maybeLog(`resolveVirtual`, path => {
      const result = resolveVirtual(npath.toPortablePath(path));

      if (result !== null) {
        return npath.fromPortablePath(result);
      } else {
        return null;
      }
    })
  };
}
// CONCATENATED MODULE: ./sources/loader/_entryPoint.ts
var _entryPoint_rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};








 // We must copy the fs into a local, because otherwise
// 1. we would make the NodeFS instance use the function that we patched (infinite loop)
// 2. Object.create(fs) isn't enough, since it won't prevent the proto from being modified

const localFs = Object.assign({}, external_fs_default.a);
const nodeFs = new NodeFS_NodeFS(localFs);
const defaultRuntimeState = $$SETUP_STATE(hydrateRuntimeState);
const defaultPnpapiResolution = external_path_default.a.resolve(__dirname, __filename);
let defaultFsLayer = new ZipOpenFS_ZipOpenFS({
  baseFs: nodeFs,
  readOnlyArchives: true
});

for (const virtualRoot of defaultRuntimeState.virtualRoots) defaultFsLayer = new VirtualFS_VirtualFS(virtualRoot, {
  baseFs: defaultFsLayer
});

const defaultApi = Object.assign(makeApi(defaultRuntimeState, {
  fakeFs: defaultFsLayer,
  pnpapiResolution: defaultPnpapiResolution
}), {
  /**
   * Can be used to generate a different API than the default one (for example
   * to map it on `/` rather than the local directory path, or to use a
   * different FS layer than the default one).
   */
  makeApi: _a => {
    var {
      basePath = undefined,
      fakeFs = defaultFsLayer,
      pnpapiResolution = defaultPnpapiResolution
    } = _a,
        rest = _entryPoint_rest(_a, ["basePath", "fakeFs", "pnpapiResolution"]);

    const apiRuntimeState = typeof basePath !== `undefined` ? $$SETUP_STATE(hydrateRuntimeState, basePath) : defaultRuntimeState;
    return makeApi(apiRuntimeState, Object.assign({
      fakeFs,
      pnpapiResolution
    }, rest));
  },

  /**
   * Will inject the specified API into the environment, monkey-patching FS. Is
   * automatically called when the hook is loaded through `--require`.
   */
  setup: api => {
    applyPatch(api || defaultApi, {
      fakeFs: defaultFsLayer
    });
  }
}); // eslint-disable-next-line arca/no-default-export

/* harmony default export */ var _entryPoint = __webpack_exports__["default"] = (defaultApi);

if (__non_webpack_module__.parent && __non_webpack_module__.parent.id === 'internal/preload') {
  defaultApi.setup();

  if (__non_webpack_module__.filename) {
    // We delete it from the cache in order to support the case where the CLI resolver is invoked from "yarn run"
    // It's annoying because it might cause some issues when the file is multiple times in NODE_OPTIONS, but it shouldn't happen anyway.
    // @ts-ignore
    delete external_module_default.a._cache[__non_webpack_module__.filename];
  }
} // @ts-ignore


if (process.mainModule === __non_webpack_module__) {
  const reportError = (code, message, data) => {
    process.stdout.write(`${JSON.stringify([{
      code,
      message,
      data
    }, null])}\n`);
  };

  const reportSuccess = resolution => {
    process.stdout.write(`${JSON.stringify([null, resolution])}\n`);
  };

  const processResolution = (request, issuer) => {
    try {
      reportSuccess(defaultApi.resolveRequest(request, issuer));
    } catch (error) {
      reportError(error.code, error.message, error.data);
    }
  };

  const processRequest = data => {
    try {
      const [request, issuer] = JSON.parse(data);
      processResolution(request, issuer);
    } catch (error) {
      reportError(`INVALID_JSON`, error.message, error.data);
    }
  };

  if (process.argv.length > 2) {
    if (process.argv.length !== 4) {
      process.stderr.write(`Usage: ${process.argv[0]} ${process.argv[1]} <request> <issuer>\n`);
      process.exitCode = 64;
      /* EX_USAGE */
    } else {
      processResolution(process.argv[2], process.argv[3]);
    }
  } else {
    let buffer = '';
    const decoder = new external_string_decoder_default.a.StringDecoder();
    process.stdin.on('data', chunk => {
      buffer += decoder.write(chunk);

      do {
        const index = buffer.indexOf('\n');
        if (index === -1) break;
        const line = buffer.slice(0, index);
        buffer = buffer.slice(index + 1);
        processRequest(line);
      } while (true);
    });
  }
}

/***/ })
/******/ ])["default"];
});